
# 
<a name="SxhUy"></a>
# 一、线性表的定义：

<br />具有相同数据类型的n个数据元素的有限序列<br />线性表是一种逻辑结构，表示元素之间一对一的逻辑关系。顺序表和链表是表示存储结构。<br />

<a name="d25cf69d"></a>
# 二、顺序表


<a name="0356005f"></a>
## 1. 顺序表定义：

<br />线性表的顺序存储<br />

```c
typedef struct{
    int data[50];
    int length;
} SqList;
```

<br />**逻辑上相邻的两个元素在物理位置上也相邻**<br />
<br />特点：<br />

- 随机访问（通过首地址和元素序号可在时间O(1)内找到元素）
- 插入和删除需要移动大量元素
- 存储密度高，每个结点只存储数据元素



<a name="742ddd59"></a>
## 2. 顺序表基本操作


<a name="9bdb07e7"></a>
### 插入

<br />在第i个位置(下标i-1)插入元素e<br />

```c
 //第i个元素及其之后的元素后移
for (int j = length; j >= i; j--)
    L[j] = L[j - 1];
L[i - 1] = e;
length++;
```


- 最好情况：在表尾插入，时间复杂度 O(1)
- 最坏情况：在表头插入，时间复杂度 O(n)
- 平均情况：时间复杂度 O(n)



<a name="2f4aaddd"></a>
### 删除

<br />删除第i个位置的元素，用e返回<br />

```c
e = L[i-1];
//从第i个位置元素前移
for(int j = i; j<length;j++) 
    L[j-1] = L[j];
length --;
```


- 最好情况：删除表尾元素，O(1)
- 最坏情况：删除表头元素，O(n)
- 平均情况：O(n)



<a name="ece70ab9"></a>
### 按值查找


```c
for (int i = 0; i < length; i++)
    if (L[i] == e)
        return i;
```


- 最好情况：查找元素在表头，O(1)
- 最坏情况：查找元素在表尾，O(n)
- 平均情况：O(n)



<a name="b1a0d7cc"></a>
# 三、链表

<br />链表分为：<br />

- 单链表
- 双链表
- 循环单链表（判空条件：表尾结点的next是否是等于头指针）
- 循环双链表



<a name="43da22aa"></a>
## 1. 单链表


<a name="7ac32497"></a>
### 定义


```c
typedef struct LNode{
    ElemType data;
    struct LNode* next;
}LNode,*LinkList;
```

<br />**单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点**<br />
<br />单链表是非随机存储的存储结构：即不能直接找到表中某个特点的结点。需要从头开始遍历。<br />
<br />------> 单链表访问前驱的时间复杂度为O(n),访问后继O(1)<br />
<br />**引入头节点的优点：**<br />

- 链表的第一个元素位置上的操作与其他位置的元素操作一样，无须进行特殊处理
- 无论链表是否为空，其头指针都是指向头节点的非空指针，空表和非空表的处理得到了统一<br />
（头指针始终指向第一个结点，有头节点则指向头节点，无头节点则指向第一个元素结点）



<a name="b7b05952"></a>
### 基本操作


<a name="35410e93"></a>
#### 头插法：(读入顺序和生成顺序相反）


```c
s->next = L->next;
L->next = s;
```


<a name="4e7c660a"></a>
#### 尾插法：(读入顺序和生成顺序相同）


```c
//尾指针r
r->next = s;
r = s;
```


<a name="0d32f045"></a>
#### 按序号查找


<a name="ece70ab9-1"></a>
#### 按值查找


<a name="2aff0caa"></a>
#### 插入结点：

<br />p之后插入s(p的位置需要自行查找)<br />![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069585694-cbd42295-b637-46e2-8914-cb2ad39d8c32.png#align=left&display=inline&height=303&originHeight=303&originWidth=653&size=0&status=done&style=none&width=653)<br />

```c
s->next = p->next;
p->next = s;
```


<a name="afc107db"></a>
#### 删除结点：


```c
//删除p之后的q
q = p->next;
p->next = q->next;
free(q); //释放结点的存储空间
```


<a name="77fcb1a1"></a>
#### 求表长


<a name="4ce94287"></a>
## 2. 双链表


<a name="7ac32497-1"></a>
### 定义

<br />就是同时具有前驱指针和后继指针的链表<br />
<br />访问前驱和后继结点时间复杂度都是O(1)<br />![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069585747-a36a9d0a-34ce-4ae9-a0bf-a5c6108d1baf.png#align=left&display=inline&height=215&originHeight=215&originWidth=583&size=0&status=done&style=none&width=583)<br />

```c
typedef struct DNode{
    int data;
    struct DNode* next,*prior;
}DNode,*DinkList;
```


<a name="b7b05952-1"></a>
### 基本操作


<a name="bd697fa2"></a>
#### 插入：

<br />p之后插入s<br />![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069585701-4be087d0-8e85-466e-b280-32825ae170bd.png#align=left&display=inline&height=400&originHeight=400&originWidth=687&size=0&status=done&style=none&width=687)<br />

```c
s->next = p->next;
p->next->prior = s;
p->next = s;
s->prior = p;
```


<a name="d9df302c"></a>
#### 删除：


```c
//删除p之后的s
p->next = s->next;
s->next->prior = p;
free(s);
```


<a name="03fb80ac"></a>
# 四、顺序表和链表的比较

<br />![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069585778-6ecb9e14-2ff6-42c0-abf2-66f560414772.png#align=left&display=inline&height=247&originHeight=247&originWidth=750&size=0&status=done&style=none&width=750)
