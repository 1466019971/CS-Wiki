# 💯  数据结构 面试指南

算法 + 数据结构 = 程序

## 一、基本概念

### 什么是数据结构

简单地说，**数据结构是以某种特定的布局方式存储数据的容器**。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。

### 时间复杂度

**时间复杂度是指执行算法所需要的计算工作量**，因为整个算法的执行时间与基本操作重复执行的次数成正 比，所以将算法中基本操作的次数作为算法时间复杂度的度量，一般情况下，按照基本操作次数最多的输 入来计算时间复杂度，并且多数情况下我们去最深层循环内的语句所描述的操作作为基本操作



## 二、线性表

### 数组/顺序表和链表的区别

**从逻辑结构上来看**

- 数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费

- 链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。

**从内存存储的角度看**

- 数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；
- 链表从堆中分配空间，自由度大但是申请管理比较麻烦。

**从访问方式类看**

- 数组在内存中是连续的存储，逻辑上相邻，物理位置也相邻，因此可以实现随机存取，利用下标索引进行访问；
- 链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。

![](https://gitee.com/veal98/images/raw/master/img/20200416151037.png)



## 三、栈和队列

### 循环队列的顺序表中，为什么要空一个位置？ 

这是为了用来区分队空与队满的情况。如果不空一个位置，则判断队空和队满的条件是一样的。

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069628893-2e862333-bb9c-439e-95c8-a4fddaed591d.png" alt="img" style="zoom:67%;" />

## 四、树

### 二叉树的存储方式

- 顺序存储结构：

  用一个数组来存储一颗二叉树，二叉树中的结点值按照编号依次存入一个一维数组中。 适用于完全二叉树，若用于一般的二叉树则会浪 费大量 存储空间。

- 链式存储结构：

  二叉树中的每一个结点用一个链结点来存放，拥有左右孩子结点

  <img src="https://gitee.com/veal98/images/raw/master/img/20200416153349.png" style="zoom: 80%;" />

### 完全二叉树

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

### 什么是堆？有什么作用？ 

**定义：**

堆是一种数据结构，**可以把堆看成一个完全二叉树**，并且这个完全二叉树满足： **任何一个非叶节点的值都不大于（或不小于）其左右子树的结点的值**。若父亲大孩子小，则为大顶堆，若 父亲肖孩子大，则为小顶堆。 

**作用：**

应用于堆排序

### 二叉排序树 BST

**定义：**

二叉排序树又称二叉搜索树，它或者是一颗空树，或者满足一下性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于根节点的值； 

- 若右子树不空，则右子树上所有结点的值均大于根节点的值；

- 左右子树也分别是二叉排序树。 

**查找过程：**

- 若根结点的关键字值等于查找的关键字，成功。 
- 否则，若小于根结点的关键字值，递归查左子树。 
- 若大于根结点的关键字值，递归查右子树。 
- 若子树为空，查找不成功。

### 平衡二叉树 AVL

**定义：**平衡二叉树又称AVL树，<u>是一种特殊的二叉排序树</u>，其左右子树都是平衡二叉树，且左右子树的高度差的 绝对值不超过1. 

**平衡因子：** 左子树高度减去右子树高度的差。 

**平衡调整：** 先找到<u>失去平衡的最小子树</u>，即以距离插入结点最近，且平衡因子绝对值大于 1 的结点作为为根节点的子树，分为LL,LR,RL,RR四种调节方式。 

### 哈夫曼树 

**定义：** 

给定n个权值作为n个叶子结点，构造一棵二叉树，若**带权路径长度达到最小**，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 

**构造方法：** 

假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 w1、w2、…、wn，则哈夫 曼树的构造规则为： 

- 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 

- 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其 左、右子树根结点权值之和； 

- 从森林中删除选取的两棵树，并将新树加入森林； 

- 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 

**特点：**

- 权值越大的结点，距离根节点越近； 

- **树中没有度为一的结点。** 

**应用：** 

哈夫曼编码，减少编码的长度。哈夫曼编码就是长度最短的前缀编码



## 五、图

### 图的相关概念

- **图：**由结点的有穷集合V和边的集合E组成。 

- **类别**：有向图和无向图。 

- **顶点的度**：出度和入度。 

- **有向完全图和无向完全图**：  

  若有向图有n个顶点，则最多有 n(n-1) 条边，则称为有向完全图

  无向图有n个顶点，则最多有 n(n-1)/2 条边，则称为无向完全图。 

- **路径：**相邻顶点序偶所构成的序列。 

- **简单路径**：<u>序列中的顶点不重复出现的路径</u>。 

- **回路**：路径中第一个顶点和最后一个顶点相同的路径。 

- **连通**： 

  无向图中，如果Vi到Vj有路径，则称这两个顶点**连通**。如果图中任意两个顶点之间都连通，则称该图为**连通图**。 

  有向图中，如果 Vi 到 Vj 有路径，则称这两个顶点**强连通**。如果图中每一对顶点Vi和Vj，从 Vi到 Vj和Vj到Vi都有路径，则称改图为**强连通图**。 

 

### 图的存储方式 

- **邻接矩阵**：是图的顺序存储结构，用两个数组分别存储数据元素（顶点）信息和数据元素之间的关系（边/弧）的信息。<u>一维数组存储顶点集，二维数组存储边集</u>。图的邻接矩阵表示是唯一的，无向图的邻接矩阵是对称 的。
- **邻接表**：是图的链式存储结构，一个单链表表示该顶点的边表；各个单链表的头指针和顶点采用顺序存储连接起来表示顶点表
- **十字链表**：有向图的另一种链式存储结构。 
- **邻接多重表**：无向图的链式存储结构。 

### 深度优先搜索遍历和广度优先搜索遍历的过程 

**BFS:** 类似于层次遍历

基本思想 ：利用 `队列` 实现。

- 首先访问起始顶点 V 并将其入队
- V出队，并遍历V的所有邻接点 w1，w2，….，wn并依次入队
- w1出队，并遍历 w1 的全部邻接点(不包括已经被访问的点)
- w2出队，并遍历w2的全部邻接点(不包括已经被访问的点)
- ....... 以此类推

**DFS:** 类似于先序遍历

基本思想：利用 `递归/栈` 实现。当不能继续向下访问时，依次回退到最近的被访问结点

- 首先访问顶点V，并将其标记为已访问
- 然后访问与顶点V的其中**一个**未被访问的邻接点W，并将其标记为已访问
- 再访问W的其中一个未被访问的邻接点，并将其标记为已访问
- 依次类推..... **当一个顶点所有的邻接顶点都被访问过时，则依次退回最近被访问过的顶点**

> **图的深度遍历是否唯一** 
>
> 不一定唯一。因为我们可以取图中任一顶点进行深度遍历。

### 最小生成树

**概念：**

一个<u>包含原图中所有结点</u>的连通图的生成树就是原图的极小连通子图，并且<u>拥有保持图连通的最少的边</u>。如果在最小生成树中添加一条边，必定成一个环。

N个结点的最小生成树有 N 个结点，N-1 条边。

<img src="https://gitee.com/veal98/images/raw/master/img/20200416152901.png" style="zoom:80%;" />

**相关算法：**

- `Prim 算法`

  每次都在互相连通的基础上选取**相对**最小的边。需保证无环

- `Kruscal 算法`

  每次选取最小的边，无须保证此过程是否连通。需保证无环

### 迪杰斯特拉 Dijkstra 算法的过程 

该算法可以求得某一顶点到其余各顶点的最短路径。

算法思想：

- 设有两个顶点集合 S 和 T，其中**集合 S 中存放的是图中已找到最短路径的顶点**，集合 T 中存放 的是图中的剩余顶点。
- 初始状态时，集合 S 中只包含源点 V0，然后不断从集合 T 中选取到顶点 V0 路径最短的顶点 Vu 并加入集合 S 中，之后的路径可通过该结点
- **集合 S 每加入一个新的顶点 Vu，都要修改 V0 到集合 T 中各个顶点的最短路径的长度值**。
- 不断重 复这个过程，直至集合T中的顶点全部并入到 S 中为止。

##  六、查找

###  什么是哈希冲突？以及如何解决。 

**散列（哈希）表：** 根据关键码值(Key value)而直接进行访问的数据结构。根据给定的关键字来计算出关键字在表中的地址，以加快查找的速度。 

**哈希冲突：**指的是多个关键字映射同一个地址的情况。 

**解决办法：** 

- 开放定址法 
  - ① 线性探查法（产生堆积问题）； 
  - ② 平方探查法（不能探查到哈希表上所有的地址，但至少能探查到一半的地址） 
  
- 链地址法 

  把所有的同义词用单链表连接起来。 

**常见的哈希函数构造方法**

- 直接定址法
- 数字分析法
- 平方取中法
- 除留余数法

###  M阶B树和M阶B+树的主要区别 

B/B+树一种平衡的多路查找树，一般被用在文件系统（我们常说的B树其实是叫 B- 树）

| B 树 M阶                                                     | B+ 树 M阶                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **① 关键字个数 + 1 = 子树个数**                              | **① 关键字个数 = 子树个数**                                  |
| ② 根节点至少2棵子树（1个关键字），至多M棵子树（M-1个关键字） | ② 根节点至少2棵子树（2个关键字），至多M棵子树（M个关键字）   |
| ③ 除根节点的分支结点至少 M/2 取上整 棵子树（至少 M/2 取上整 - 1 个关键字），至多 M 棵子树（至多 M - 1个关键字） | ③ 除根节点的分支结点至少 M/2 取上整 棵子树至少 M/2 取上整 -个关键字），至多 M 棵子树至多 M 个关键字） |
| **④ B 树的叶节点不带任何信息，所有的信息（key，value）都存在分支结点中** | **④ B+树叶子结点携带所有结点的全部信息（key，value），且按照大小顺序通过指针链接起来，分支结点仅携带索引信息（key）起索引作用**。所以B+ 树的查找更稳定，因为每次都是从根节点到叶节点的查找路径 |

下图为 B+ 树

![](https://gitee.com/veal98/images/raw/master/img/20200416155030.png)

## 七、排序

