

> 算法 + 数据结构 = 程序

# 一、基本概念

## 1. 什么是数据结构

简单地说，**数据结构是以某种特定的布局方式存储数据的容器**。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。

## 2. 时间复杂度

**时间复杂度是指执行算法所需要的计算工作量**，因为整个算法的执行时间与基本操作重复执行的次数成正 比，所以将算法中基本操作的次数作为算法时间复杂度的度量，一般情况下，按照基本操作次数最多的输 入来计算时间复杂度，并且多数情况下我们去最深层循环内的语句所描述的操作作为基本操作



# 二、线性表

## 1. 数组/顺序表和链表的区别

**从逻辑结构上来看**

- 数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费

- 链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。

**从内存存储的角度看**

- 数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；
- 链表从堆中分配空间，自由度大但是申请管理比较麻烦。

**从访问方式类看**

- 数组在内存中是连续的存储，逻辑上相邻，物理位置也相邻，因此可以实现随机存取，利用下标索引进行访问；
- 链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。

![](https://gitee.com/veal98/images/raw/master/img/20200416151037.png)

## 2. 常见算法题

### ① 一个单链表如何判断有没有环，若有环，环的长度是多少，如何找出环的入口点，带环链表的长度是多少

- **第一个问题：如何判断单链表是否有环**

  使用二指针法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出

- **第二个问题：环的长度是多少**

  记录下 问题1 的碰撞点p，slow、fast 从该点开始，再次碰撞所走过的操作数就是环的长度s

- **第三个问题：找出环的入口点**

  有定理：碰撞点 p 到入口点的距离 = 头指针到入口点的距离，因此，分别从碰撞点、头指针开始走，相遇的那个点就是入口点。

- **第四个问题：带环链表的长度**

  问题3中已经求出连接点距离头指针的长度，加上问题2中求出的环的长度，二者之和就是带环单链表的长度

### ② 单链表反转

**头插法**

```cpp
//摘下头结点
LinkList Reverse(LinkList &L){
    LNode *p=L->next, *r=L;//r为后继结点，防止断链
    L->next = NULL; //摘下头节点
    while(p){
        r = p->next;
        p->next = L->next;
        L->next = p;
        p = r; //继续插入
    }
    return L;
}
```

### ③ 查找单链表中倒数第K个结点

**快慢指针法**：快指针先走k步，随后快慢指针同时依次后移，快指针到达链表尾部时，慢指针正好访问倒数第k个位置结点

```cpp
int Search_k(LinkList L, int k){
  LNode *p = L->next, *q = L->next;
  int count = 0;
  while(p!=Null){
    if(conut < k){
      p = p->next;
      count++;
    }
    else{
      p = p->next;
      q = q->next;
    }
  }
  if(count > k) //k值超过了线性表长度
    return 0;
  else 
    return 1;
}
```

### ④ 查找单链表的中间结点

此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空、链表结点个数为1和2的情况。时间复杂度O（n）。

```cpp
// 获取单链表中间结点，若链表长度为n(n>0)，则返回第n/2+1个结点  
ListNode * GetMiddleNode(ListNode * pHead)  {  
      if(pHead == NULL || pHead->m_pNext == NULL) // 链表为空或只有一个结点，返回头指针  
          return pHead;  
    
      ListNode * pAhead = pHead;  
      ListNode * pBehind = pHead;  
      while(pAhead->m_pNext != NULL) // 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步 
      {  
           pAhead = pAhead->m_pNext;  
      	   pBehind = pBehind->m_pNext;  
           if(pAhead->m_pNext != NULL)  
            	pAhead = pAhead->m_pNext;  
       }  
       return pBehind; // 后面的指针所指结点即为中间结点  
 } 
```

### ⑤ 从尾到头打印单链表

用递归或栈

```cpp
void rprint(LinkList L){
    if(L->next!=NULL)
        rprint(L->next);
    cout<<L->data<<" ";
}
```

### ⑥ 将两个有序顺序表合成一个有序顺序表

类似归并排序，两个顺序表A、B分别设置一个指针，依次比较，较小值放入结果顺序表C，并将当前较小值的指针移动至下一位；较大值指针不动，继续进行下一次比较。

```cpp
typedef struct{
    int data[50];
    int length;
} SqList;

bool merge(SqList a,SqList b,SqList &c){
    if(a.length+b.length>50)
        return false;
    int i=0,j=0,k=0;
    while(i<a.length && j<b.length){
        if(a.data[i]<b.data[j]){ //a表元素较小
            c.data[k++] = a.data[i++];
        }
        else //b表元素较小
            c.data[k++] = b.data[j++];
    }
    //若a表未比较完
    while(i<a.length){
        c.data[k++] = a.data[i++];
    }
    while(j<b.length){
        c.data[k++] = b.data[j++];
    }
    c.length = k;
    return true;
}
```

### ⑦ 判断两个单链表是否相交，找出两个链表的公共结点

如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的，呈现Y型；

**对于如何判断是否相交：**先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交

**对于如何找出公共结点：**先走完较长链表的多出来的一部分，到达同样长度后再同步比较，代码如下：

```cpp
// 找出两个链表的公共结点
LinkList Search_Common(LinkList L1, LinkList L2)
{
    int len1 = L1.length;
    int len2 = L2.length;
    int longlist, shortlist;
    if (len1 > len2)
        longlist = L1->next;
    shortlist = L2->next;
    dist = len1 - len2;
    else longlist = L2;
    shortlist = L1;
    dist = len2 - len1;
    while (dist--)
        longlist = longlist->next;
    while (longlist != Null)
    {
        if (longlist == shortlist)
            return longlist;
        else
        {
            longlist = longlist->next;
            shortlist = shortlist->next;
        }
    }
}
```

### ⑧ 删除单链表中指定结点，要求时间复杂度O(1)

对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。

因为链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。



<br>

# 三、栈和队列

## 1. 栈和队列的区别

- **队列先进先出，栈先进后出。**

- **对插入和删除操作的"限定"不同。**

  栈是限定只能在表的同一端进行插入和删除操作的线性表。   

  队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 

- **遍历数据速度不同。**

  栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。

  队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多

## 2. 循环队列的优缺点

- **循环队列的优点：**

  可以有效的利用资源。用数组实现队列时，如果不移动，随着数据的不断读写，会出现假满队列的情况。即尾数组已满但头数组还是空的；循环队列也是一种数组，只是它在逻辑上把数组的头和尾相连，形成循环队列，当数组尾满的时候，要判断数组头是否为空，不为空继续存放数据。

- **循环队列的缺点：**

  循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件front==rear来判别队列是"空"是"满"。

  解决这个问题有两个办法：一是增加一个参数，用来记录数组中当前元素的个数；第二个办法是，少用一个存储空间，也就是数组的最后一个存数空间不用，当（rear+1）%maxsize=front 时，队列满

  这也就是为什么**循环队列的顺序表中要空一个位置**（用来区分队列空和队列满）。

  <img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069628893-2e862333-bb9c-439e-95c8-a4fddaed591d.png" alt="img" style="zoom: 50%;" />

## 3. 堆和栈的区别

首先：讨论的堆和栈是内存中的 堆区 和 栈区，而不是数据结构中的堆和栈

C++中的内存区域分为5个区：堆区、栈区、全局/静态存储区、常量存储区、代码程序区

- **栈（stack）**：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限。

- **堆（heap）**：由程序员控制内存的分配和释放的存储区，是不连续的存储空间，堆的分配(new)和释放(delete)有程序员控制，容易造成二次删除和内存泄漏，堆的分配方式类似于链表

  ```cpp
  void fun(){
      int *p = new int[5];
  }
  ```

  在上述代码中就包含了堆和栈，看到new，我们就知道分配了一块堆内存，那么指针p呢，它分配的是一块栈内存。即**在栈内存中存放了一个指向一块堆内存的指针p**

- **静态存储区（static）**：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间

- **常量存储区（const）**：存放常量字符串的存储区，只能读不能写

- **程序代码区**：存放源程序二进制代码

<br>

了解上述知识后我们再来明确**堆和栈的区别**：

| 不同点                 |                              栈                              |                              堆                              |
| :--------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **① 管理方式不同**     |                     编译器自动分配和释放                     |              程序员手动分配(new)和释放(delete)               |
| **② 空间大小不同**     |                   可分配的栈区内存空间较小                   | 可分配的堆区内存较大。<br>一般在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的 |
| **③ 能否产生碎片不同** | 栈不存在碎片问题，因为它是严格的先进先出，在某个数据弹出之前，它上面的后进入的内容已经被全部弹出了 | 对于堆来说，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的内存碎片 |
| **④ 地址生长方向不同** |           生长方向向下，向着内存地址减小的方向增长           |           生长方向向上，向着内存地址增加的方向增长           |
| **⑤ 分配方式不同**     | 栈有2种分配方式：静态分配和动态分配。<br>静态分配是编译器完成的，比如局部变量的分配，动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 |             堆都是动态分配的，没有静态分配的堆。             |
| **⑥ 分配效率不同**     | 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 | 堆则是C/C++函数库提供的，它的机制是很复杂的，堆的效率比栈要低得多 |

<br>

# 四、树

## 1. 二叉树的存储方式

- 顺序存储结构：

  用一个数组来存储一颗二叉树，二叉树中的结点值按照编号依次存入一个一维数组中。 适用于完全二叉树，若用于一般的二叉树则会浪 费大量 存储空间。

- 链式存储结构：

  二叉树中的每一个结点用一个链结点来存放，拥有左右孩子结点

  <img src="https://gitee.com/veal98/images/raw/master/img/20200416153349.png" style="zoom: 80%;" />

## 2. 什么是堆？有什么作用？ 

**定义：**

堆是一种数据结构，**可以把堆看成一个完全二叉树**，并且这个完全二叉树满足： **任何一个非叶节点的值都不大于（或不小于）其左右子树的结点的值**。若父亲大孩子小，则为大顶堆，若 父亲小孩子大，则为小顶堆。 

**作用：**

应用于堆排序

## 3. 完全二叉树

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

## 4. 完全二叉树的判定

**思路：** 完全二叉树的结点编码是连续的，根据**层次遍历**，把所有结点依次入队，包括空结点，若空结点之后还有非空结点，就不是完全二叉树

代码：

```cpp
bool isComplete(BiTree T){
    if(!T)
        return true;
    InitQueue(Q);
    BiTNode *p = T;
    EnQueue(Q,T);
    while(!isEmpty(Q)){
        DeQueue(Q,p);
        if(p){
            EnQueue(Q,p->lchild);
            EnQueue(Q,p->rchild);
        }
        else{
            while(!isEmpty(Q)){
                DeQueue(Q,p);
                if(p)
                    return false;
            }
        }
    }
    return true;
}
```

## 5. 二叉排序树 BST 

**定义：**

二叉排序树又称二叉搜索树，它或者是一颗空树，或者满足一下性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于根节点的值； 

- 若右子树不空，则右子树上所有结点的值均大于根节点的值；

- 左右子树也分别是二叉排序树。 

**查找过程：**

- 若根结点的关键字值等于查找的关键字，成功。 
- 否则，若小于根结点的关键字值，递归查左子树。 
- 若大于根结点的关键字值，递归查右子树。 
- 若子树为空，查找不成功。

## 6. 二叉排序树的判定

思路：二叉排序树的**中序遍历**序列一定为递增序列

代码：

```cpp
//利用中序遍历为递增
bool isBST(BiTree T){
    if(T==NULL)
        return true;
    else{
        bool bl = isBST(T->lchild);
        if(bl==false || pre>T->data)
            return false;
        pre = T->data;
        bool br = isBST(T->rchild);
        return br;
    }
}
```



## 7. 平衡二叉树 AVL

**定义：**平衡二叉树又称AVL树，<u>是一种特殊的二叉排序树</u>，其左右子树都是平衡二叉树，且左右子树的高度差的 绝对值不超过1. 

**平衡因子：** 左子树高度减去右子树高度的差。 

**平衡调整：** 先找到<u>失去平衡的最小子树</u>，即以距离插入结点最近，且平衡因子绝对值大于 1 的结点作为为根节点的子树，分为LL,LR,RL,RR四种调节方式。 

## 8. 平衡二叉树的判定

思路：平衡二叉树的每一个结点都是平衡的，利用**后序遍历**按照左右根的次序依次判断是否平衡二叉树

```cpp
int isAVL(BiTree T,int &h,int &balance){
    int bl,br,hl,hr; //左右子树的高度和平衡性
    if(T==NULL){
        balance = 1;
        h = 0;
    }
    else if(!T->lchild && !T->rchild){ //左右孩子均不存在
        balance = 1;
        h = 1;
    }
    else{
        isAVL(T->lchild,hl,bl); //判定左子树
        isAVL(T->rchild,hr,br); //判定右子树
        h = hl>hr?hl:hr;
        if(bl&&br && abs(hl-hr)<2) //若左右子树均平衡且高度差小于等于1
            balance = 1;
        else
            balance = 0;
    }
}
```

## 9. 哈夫曼树 

**定义：** 

给定n个权值作为n个叶子结点，构造一棵二叉树，若**带权路径长度达到最小**，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 

**构造方法：** 

假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 w1、w2、…、wn，则哈夫 曼树的构造规则为： 

- 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 

- 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其 左、右子树根结点权值之和； 

- 从森林中删除选取的两棵树，并将新树加入森林； 

- 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 

**特点：**

- 权值越大的结点，距离根节点越近； 

- **树中没有度为一的结点。** 

**应用：** 

哈夫曼编码，减少编码的长度。哈夫曼编码就是长度最短的前缀编码

<br>

# 五、图

## 1. 图的相关概念

- **图：**由结点的有穷集合V和边的集合E组成。 

- **类别**：有向图和无向图。 

- **顶点的度**：出度和入度。 

- **有向完全图和无向完全图**：  

  若有向图有n个顶点，则最多有 n(n-1) 条边，则称为有向完全图

  无向图有n个顶点，则最多有 n(n-1)/2 条边，则称为无向完全图。 

- **路径：**相邻顶点序偶所构成的序列。 

- **简单路径**：<u>序列中的顶点不重复出现的路径</u>。 

- **回路**：路径中第一个顶点和最后一个顶点相同的路径。 

- **连通**： 

  无向图中，如果Vi到Vj有路径，则称这两个顶点**连通**。如果图中任意两个顶点之间都连通，则称该图为**连通图**。 

  有向图中，如果 Vi 到 Vj 有路径，则称这两个顶点**强连通**。如果图中每一对顶点Vi和Vj，从 Vi到 Vj和Vj到Vi都有路径，则称改图为**强连通图**。 

## 2. 图的存储方式 

- **邻接矩阵**：是图的顺序存储结构，用两个数组分别存储数据元素（顶点）信息和数据元素之间的关系（边/弧）的信息。<u>一维数组存储顶点集，二维数组存储边集</u>。图的邻接矩阵表示是唯一的，无向图的邻接矩阵是对称 的。
- **邻接表**：是图的链式存储结构，一个单链表表示该顶点的边表；各个单链表的头指针和顶点采用顺序存储连接起来表示顶点表
- **十字链表**：有向图的另一种链式存储结构。 
- **邻接多重表**：无向图的链式存储结构。 

## 3. 邻接矩阵和邻接表对比

| 邻接矩阵                                                     | 邻接表                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ① 顺序存储                                                   | ① 链式存储                                                   |
| ② **无向图**的邻接矩阵第i行（列）非零元素的个数表示该顶点的度 | ② **无向图**的同一条边在邻接表中存储的两次。如果想要知道顶点的度，只需要求出所对应链表的结点个数即可。 |
| ③ **有向图**的邻接矩阵第i行（列）非零元素的个数表示该顶点的出度（入度） | ③ **有向图**中每条边在邻接表中只出现一次，求顶点的出度只需要遍历所对应链表即可。求入度则需要遍历其他顶点的链表。 |
| ④ 无向图的邻接矩阵是对称的                                   |                                                              |
| **邻接矩阵的优点是可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边**。而其缺点是如果顶点之间的边比较少，会比较浪费空间，因为是一个 n∗n 的矩阵。 | **邻接表的优点是节省空间，只存储实际存在的边**，可以方便的找出一顶点的所有领边。其缺点是求解顶点的入度时，就可能需要遍历一个链表。 |

## 4. 深度优先搜索遍历和广度优先搜索遍历的过程 

**BFS:** 类似于层次遍历

基本思想 ：利用 `队列` 实现。

- 首先访问起始顶点 V 并将其入队
- V出队，并遍历V的所有邻接点 w1，w2，….，wn并依次入队
- w1出队，并遍历 w1 的全部邻接点(不包括已经被访问的点)
- w2出队，并遍历w2的全部邻接点(不包括已经被访问的点)
- ....... 以此类推

**DFS:** 类似于先序遍历

基本思想：利用 `递归/栈` 实现。当不能继续向下访问时，依次回退到最近的被访问结点

- 首先访问顶点V，并将其标记为已访问
- 然后访问与顶点V的其中**一个**未被访问的邻接点W，并将其标记为已访问
- 再访问W的其中一个未被访问的邻接点，并将其标记为已访问
- 依次类推..... **当一个顶点所有的邻接顶点都被访问过时，则依次退回最近被访问过的顶点**

> **图的深度遍历是否唯一** 
>
> 不一定唯一。因为我们可以取图中任一顶点进行深度遍历。

## 5. 最小生成树及相关算法

**概念：**

一个<u>包含原图中所有结点</u>的连通图的生成树就是原图的极小连通子图，并且<u>拥有保持图连通的最少的边</u>。如果在最小生成树中添加一条边，必定成一个环。

N个结点的最小生成树有 N 个结点，N-1 条边。

<img src="https://gitee.com/veal98/images/raw/master/img/20200416152901.png" style="zoom:80%;" />

**相关算法：**

- `Prim 算法`

  每次都在互相连通的基础上选取**相对**最小的边。需保证无环

- `Kruscal 算法`

  每次选取最小的边，无须保证此过程是否连通。需保证无环

## 5. 最短路径及相关算法

**Dijkstra 算法**

该算法可以求得某一顶点到其余各顶点的最短路径。

算法思想：

- 设有两个顶点集合 S 和 T，其中**集合 S 中存放的是图中已找到最短路径的顶点**，集合 T 中存放 的是图中的剩余顶点。
- 初始状态时，集合 S 中只包含源点 V0，然后不断从集合 T 中选取到顶点 V0 路径最短的顶点 Vu 并加入集合 S 中，之后的路径可通过该结点
- **集合 S 每加入一个新的顶点 Vu，都要修改 V0 到集合 T 中各个顶点的最短路径的长度值**。
- 不断重 复这个过程，直至集合T中的顶点全部并入到 S 中为止。

<br>

**Floyd算法**

每次都试图在路径上添加新的中间结点

## 7. 拓扑排序

**什么图可以进行拓扑排序？** 有向无环图

**基本思想** ：每次去除一个入度为0的结点和该与顶结点相连的边

若图中存在一条A——>B的路径，则在拓扑排序中表示B事件在A事件的后面

#  六、查找

##  1. 什么是哈希冲突？以及如何解决。 

**散列（哈希）表：** 根据关键码值(Key value)而直接进行访问的数据结构。根据给定的关键字来计算出关键字在表中的地址，以加快查找的速度。 

**哈希冲突：**<u>指的是多个关键字映射同一个地址的情况</u>。 

**解决办法：** 

- 开放定址法 
  - ① 线性探查法（产生堆积问题）：冲突发生时顺序查找下一个位置
  - ② 平方探查法（不能探查到哈希表上所有的地址，但至少能探查到一半的地址） 
  
- 链地址法 

  所有的同义词都存储在一个线性链表中。 

**常见的哈希函数构造方法**

- 直接定址法

  `H(key) = a*key + b`

- 数字分析法

- 平方取中法

- 除留余数法

  `H(key) = key % p` (p为不大于m的最大质数)

## 2. KMP 算法

在一个字符串中查找是否包含目标的匹配字符串。其主要思想是每趟比较过程让子串先后滑动一个合适的位置。当发生不匹配的情况时，不是右移一位，而是移动（当前匹配的长度– 当前匹配子串的部分匹配值）位。**使用一个next数组维护每个字符对应的移动位数**。

##  3. M阶B树和M阶B+树的主要区别 

B/B+树一种平衡的多路查找树，一般被用在文件系统（我们常说的B树其实是叫 B- 树）

| B 树 M阶                                                     | B+ 树 M阶                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **① 关键字个数 + 1 = 子树个数**                              | **① 关键字个数 = 子树个数**                                  |
| ② 根节点至少2棵子树（1个关键字），至多M棵子树（M-1个关键字） | ② 根节点至少2棵子树（2个关键字），至多M棵子树（M个关键字）   |
| ③ 除根节点的分支结点至少 M/2 取上整 棵子树（至少 M/2 取上整 - 1 个关键字），至多 M 棵子树（至多 M - 1个关键字） | ③ 除根节点的分支结点至少 M/2 取上整 棵子树至少 M/2 取上整 -个关键字），至多 M 棵子树至多 M 个关键字） |
| **④ B 树的叶节点不带任何信息，所有的信息（key，value）都存在分支结点中** | **④ B+树叶子结点携带所有结点的全部信息（key，value），且按照大小顺序通过指针链接起来，分支结点仅携带索引信息（key）起索引作用**。所以B+ 树的查找更稳定，因为每次都是从根节点到叶节点的查找路径 |

下图为 B+ 树

![](https://gitee.com/veal98/images/raw/master/img/20200416155030.png)

# 七、排序

## 1. 各类排序算法对比

![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069772529-7279863d-ac0d-4146-a092-40a4a98e8945.png)

## 2. 如何选择排序算法

**选择排序算法准则：**

一般而言，需要考虑的因素有以下四点：

设待排序元素的个数为n.

- **当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。**

- **当n较大，内存空间允许，且要求稳定性：归并排序**

- 当n较小，可采用直接插入或直接选择排序。

  直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。

  简单选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序

- 一般不使用或不直接使用传统的冒泡排序。

- 基数排序：它是一种稳定的排序算法，但有一定的局限性
  - 关键字可分解。
  - 记录的关键字位数较少，如果密集更好
  - 如果是数字时，最好是无符号的

 ## 3. 冒泡排序算法的改进

设置一个 flag 位，用于标识这趟排序有没有发生交换，如果本趟遍历后没有发生交换，则说明元素已经有序了，则退出排序过程。

## 4. 快排、堆排、归并排序对比

这三个排序算法都是O(nlog2n)