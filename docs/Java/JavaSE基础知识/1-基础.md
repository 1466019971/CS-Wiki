# 一、Java 概述

## 1. JVM、JRE和JDK的关系

**JVM**
Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。

**JRE**
Java Runtime Environment 包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包

如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

**JDK**
Java Development Kit 是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等

<img src="https://gitee.com/veal98/images/raw/master/img/20200501195231.png" style="zoom: 50%;" />

## 2. 什么是跨平台性

所谓跨平台性，是指java语言编写的程序，**一次编译后，可以在多个系统平台上运行**。

实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。

## 3. 什么是Java程序的主类

一个程序中可以有多个类，但只能有一个类是主类（主类一般以文件名命名）。在Java应用程序中，**这个主类是指包含main()方法的类。**

## 4. Java 和 C++ 的区别
- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存
  

# 二、数据类型

## 1. Java 基本类型

| 基本类型 | 占用字节 Byte (1字节 =  32位) |
| -------- | ----------------------------- |
| byte     | 1                             |
| char     | 2                             |
| short    | 2                             |
| int      | 4                             |
| float    | 4                             |
| long     | 8                             |
| double   | 8                             |
| boolean  |                               |



## 2. 包装类型

### ① 概述

Java提供了两个类型系统，**基本类型与引用类型**，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：

| 基本类型 | 对应的包装类（位于java.lang包中） |
| -------- | --------------------------------- |
| byte     | Byte                              |
| short    | Short                             |
| int      | **Integer**                       |
| long     | Long                              |
| float    | Float                             |
| double   | Double                            |
| char     | **Character**                     |
| boolean  | Boolean                           |

### ② 装箱与拆箱

基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：

- **装箱**：从基本类型转换为对应的包装类对象。
- **拆箱**：从包装类对象转换为对应的基本类型。

用Integer与 int为例：

基本数值----> 包装对象：装箱

```java
Integer i = new Integer(4);//使用构造函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法，详细如下
```

包装对象---->基本数值：拆箱

```java
int num = i.intValue();
```

### ③ 自动装箱与自动拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

### ④ 基本类型与字符串之间的转换

#### 基本类型转换为String

基本类型转换String总共有三种方式，这里只讲最简单的一种方式：

基本类型直接用 ” ” 相连接即可；如：`34+""`

#### String转换成对应的基本类型

除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

代码使用（仅以Integer类的静态方法parseXxx为例）如：

```java
public class Demo18WrapperParse {
    public static void main(String[] args) {
        int num = Integer.parseInt("100");
    }
}
```

> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

## 3. 缓存池 valueOf

new Integer(123) 与 Integer.valueOf(123) 的区别在于：

- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，**多次调用会取得同一个对象的引用**。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // trueCopy to clipboardErrorCopied
```

valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。

```java
Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
```

基本类型对应的缓冲池大小如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。

在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=< size > 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。

<br>



# 三、数组

## 1. Java 虚拟机的内存划分

内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 

Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。

为了提高运算效率，就对空间进行了不同区域的划分，**每一片区域都有特定的处理数据方式和内存管理方式。**

<img src="https://gitee.com/veal98/images/raw/master/img/20200430160846.png" style="zoom:90%;" />

## 2. 数组在内存中的存储

### ① 一个数组内存图

```java
int [] arr = new int[3];
System.out.println(arr);
```

**数组名 = 数组的地址**

程序执行流程：

- main 方法进入方法栈执行
- 动态创建数组，JVM 会在堆内存中开辟控件，存储数组
- 数组在内存中会有自己的内存地址，十六进制表示
- 数组中有三个元素，默认值为 0 
- JVM 将数组的首地址赋给**引用类型变量 arr**
- 变量 arr 保存的是数组在内存中的地址，而不是一个具体的数值，因此称为引用类型变量

<img src="https://gitee.com/veal98/images/raw/master/img/20200430161327.png" style="zoom:80%;" />

### ② 两个数组内存图

```java
public static void main(String[] args) {
	int[] arr = new int[3];
	int[] arr2 = new int[2];
	System.out.println(arr);
	System.out.println(arr2);
}

```

<img src="https://gitee.com/veal98/images/raw/master/img/20200430161408.png" style="zoom:80%;" />

## 3. 数组的反转

```java
public void reverse(int [] arr,int low, int high){
    int temp = arr[low];
    arr[low] = arr[high];
    arr[high] = temp;
    low ++;
    high --;
}
```



<br>



# 四、参数传递

**🚨Java 语言的方法调用只支持参数的值传递，不支持引用传递**，和C++不同 

```java
int swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}
```

这种在C++中的常见写法在Java中是错误的

## 1. 为什么 Java 中只有值传递

Java程序设计语言总是采用按值调用。函数得到的是参数值的一个拷贝，也就是说，**函数不能修改传递给它的任何参数变量的内容。**

我们已经知道了一个方法不能修改一个基本数据类型的参数，而**对象引用作为参数**就不一样

```java
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }
```

array 被 arr 的拷贝所初始化，也就是一个对象的引用，也就是说 array 和 arr 指向同一个数组对象， 因此，外部对引用对象的改变会反映到所对应的对象上。

总结一下Java中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

## 2. 值传递和引用传递有什么区别
**值传递**：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

**引用传递**：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个内存空间。

## 3. 可变参数

在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：

```java
修饰符 返回值类型 方法名(参数类型... 形参名){  }
```

其实这个书写完全等价与

```java
修饰符 返回值类型 方法名(参数类型[] 形参名){  }
```

只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。

**JDK1.5**以后。出现了简化操作。**...** 用在参数上，称之为可变参数。

**同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递**，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。

代码演示：    

```java
public class ChangeArgs {
    public static void main(String[] args) {
        int[] arr = { 1, 4, 62, 431, 2 };
        int sum = getSum(arr);
        System.out.println(sum);
        //  6  7  2 12 2121
        // 求 这几个元素和 6  7  2 12 2121
        int sum2 = getSum(6, 7, 2, 12, 2121);
        System.out.println(sum2);
    }

    /*
     * 完成数组  所有元素的求和 原始写法
     
      public static int getSum(int[] arr){
        int sum = 0;
        for(int a : arr){
            sum += a;
        }
        
        return sum;
      }
    */
    //可变参数写法
    public static int getSum(int... arr) {
        int sum = 0;
        for (int a : arr) {
            sum += a;
        }
        return sum;
    }
}
```

> 🚨 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，**可变参数一定要写在参数列表的末尾位置。**


<br>



# 五、封装

## 1. 成员变量和局部变量的区别

```java
public class Car{
	private String color; // 成员变量
    public void drive(){
        int speed = 20; // 局部变量
    }
}
```

**在类中的位置不同** 

- 成员变量：类中，方法外 

- 局部变量：方法中或者方法声明上(形式参数) 

**作用范围不一样** 

- 成员变量：类中 

- 局部变量：方法中 

**初始化值的不同**

- 成员变量：有默认值 
- 局部变量：没有默认值。必须先定义，赋值，最后使用 
  

**在内存中的位置不同** 

- 成员变量：堆内存 
- 局部变量：栈内存 

**生命周期不同** 

- 成员变量：随着对象的创建而存在，随着对象的消失而消失 
- 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失

## 2. this 关键字

如下代码所示，形参名和成员变量名重名，导致成员变量名被隐藏，方法中的变量名无法访问到成员变量，从而赋值失败。所以，此时我们只能使用 this 关键字来解决这个重名问题

```java
public class Student {
	private String name;
	private int age;
	public void setName(String name) {
		name = name; // error
	}
	public void setAge(int age) {
		this.age = age; // right
	}
}
```

this 代表所在类的当前对象的引用（地址值），即对象自己的引用。 

**方法被哪个对象调用，方法中的 this 就代表那个对象**。即谁在调用，this就代表谁。

## 3. 内部类

将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。

```java
class 外部类 {
	class 内部类{
        
	}
}
```

在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。

- **内部类可以直接访问外部类的成员，包括私有成员。** 

- **外部类要访问内部类的成员，必须要建立内部类的对象。**

  ```java
  外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；
  ```

示例代码如下：

```java
public class Person {
    private boolean live = true;
    class Heart {
        public void jump() {
            // 直接访问外部类成员
            if (live) {
            	System.out.println("心脏在跳动");
        	} else {
        		System.out.println("心脏不跳了");
       		 }
        }
    }
    
    public boolean isLive() {
        return live;
    }
    
    public void setLive(boolean live) {
    	this.live = live;
    }
}

```

```java
public class InnerDemo {
    public static void main(String[] args) {
        // 创建外部类对象
        Person p = new Person();
        // 创建内部类对象
        Heart heart = p.new Heart();
        // 调用内部类方法
        heart.jump();
        // 调用外部类方法
        p.setLive(false);
        // 调用内部类方法
        heart.jump();
    }
}
```

## 4. 匿名内部类

匿名内部类 ：是内部类的简化写法。它的本质是一个 **带具体实现的 父类或者父接口的 匿名的 子类对象**。 开发中，最常用到的内部类就是匿名内部类了

<br>



# 六、继承 extend

## 1. 访问权限修饰符

Java 中有三个访问权限修饰符：private、protected 以及 public，**如果不加访问修饰符，表示包级可见**。

## 2. super 关键字

子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字

```java
class Fu {
	int num = 5;
}
class Zi extends Fu {
	int num = 6;
	public void show() {
		// 访问父类中的num
		System.out.println("Fu num=" + super.num);
		// 访问子类中的num
		System.out.println("Zi num=" + num);
	}
}

```

> 🚨 子类的每个构造方法中均有默认的 `super() `构造函数，调用父类的空参构造。手动调用父类构造会覆盖默认的 super()。 
>
> **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现**。

## 3. 单继承

和 C++ 不同的是，**Java只支持单继承，一个类只能有一个父类，不可以有多个父类**。

## 4. 重写和重载

### ① 重写 Override

指子类实现了一个与父类在方法声明上**完全相同**的一个方法。

为了满足里式替换原则，重写有以下三个限制：

- 子类方法的访问权限必须大于等于父类方法；
- 子类方法的返回类型必须是父类方法返回类型或为其子类型。
- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

使用 `@Override` 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。
- 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。
- 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。
- 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。

```java
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

### ② 重载 Overload

存在于同一个类中，指一个方法与已经存在的方法**名称上相同，但是参数类型或者参数个数不同**。

**编译器不以形参名和返回值来区分重载。** 若只有返回值类型不同，则不叫重载，叫重复定义

## 5. 抽象类 abstract

父类中的方法都被它的子类们重写，子类各自的实现都不尽相同。那么父类只需要声明方法名就可以。我们把没有方法主体的方法称为抽象方法。

**抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。**

抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。

```java
public abstract class AbstractClassExample {
    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println("func2");
    }
}

public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
AbstractClassExample ac2 = new AbstractExtendClassExample(); // 实例化
ac2.func1();
```



<br>



# 七、接口 interface

## 1. 接口的使用

接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

**从 Java 8 开始，接口也可以拥有默认的方法 (default) 实现**，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。

**接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为protected。JDK 9 之后支持 private**

**接口的字段默认都是 static 和 final 的**。

接口的定义，它与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成.class文件，**但一定要明确它并不是类，而是另外一种引用数据类型。**

> 引用数据类型：数组，类，接口。

```java
public interface InterfaceExample {
	
    private void method(){ //私有方法：供接口中的默认方法或者静态方法调用
        ...
    } 
    public void func1(); 

    public default void func2(){ // 默认方法
        System.out.println("func2");
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
}
```

接口的继承用 `implements` 关键字

```java
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

实例化

```java
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

## 2. 接口的多实现

在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。**并且，一个类能继承一个父类，同时实现多个接口**。

```java
class 类名 extends 父类名 implements 接口名1,接口名2,接口名3... {
	// 重写接口中抽象方法【必须】
	// 重写接口中默认方法【不重名时可选】
}

```



## 3. 接口和抽象类比较

**比较**

- 从设计层面上看，抽象类提供了一种 `IS-A` 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 `LIKE-A` 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，**一个类可以实现多个接口，但是不能继承多个抽象类**。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

**使用选择**

使用接口：

- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
- 需要使用多重继承。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

<br>



# 八、多态

## 1. 概述

多态的定义：指同一行为，具有多个不同表现形式

多态体现的格式：

```java
父类类型 变量名 = new 子类对象；
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法。

## 2. 引用类型转换

多态的转型分为向上转型与向下转型两种

### ① 向上转型

多态本身是**子类类型向父类类型向上转换**的过程，这个过程是**默认**的。

当父类引用指向一个子类对象时，便是向上转型。

格式：父类类型 变量名 = new 子类对象

```java
Animal a = new Cat();
```

### ② 向下转型

**父类类型向子类类型向下转换**的过程，这个过程是**强制**的

一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

格式：子类类型 变量名 = (子类类型) 父类变量名;

```java
Animal a = new Cat();
Cat c = (Cat) a;
```

### ③ 为什么要转型

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用子类拥有，而父类没有的方法**。这也是多态给我们带来的一点"小麻烦"。所以，**想要调用子类特有的方法，必须做向下转型。**

```java
abstract class Animal {
	abstract void eat();
}
class Cat extends Animal {
	public void eat() {
		System.out.println("吃鱼");
	}
	public void catchMouse() {
		System.out.println("抓老鼠");
	}
}

public class Test {
	public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat

        // 向下转型
        Cat c = (Cat)a;
        c.catchMouse(); // 调用的是 Cat 的 catchMouse
	}
}

```



<br>



# 九、关键字

## 1. final 常

等同于 C++ 中的 const

### ① 常量

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

###② 常函数

**final 声明方法则不能被子类重写**。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

### ③ 常类

final 声明类则该类不允许被继承

## 2. static 静态

### ① 静态变量

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
```

### ② 静态方法

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以**静态方法必须有实现，也就是说它不能是抽象方法。**

```java
public abstract class A {
    public static void func1(){
    }
}
```

### ③ 静态代码块

静态语句块在类初始化时运行一次。

```java
public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
```

### ④ 静态内部类

非静态内部类依赖于外部类的实例，而静态内部类不需要

```java
public class OuterClass {
	// 内部类
    class InnerClass {
    }
	// 静态内部类
    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

### ⑤ 初始化顺序

- 静态变量和静态语句块优先于实例变量和普通语句块

- 静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）



