# 一、反射

## 1. 什么是反射？

> 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力

在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法

Java反射机制主要提供了以下功能：

- 在运行时（动态编译）判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法和属性。

这种**动态获取信息以及动态调用对象的方法**的功能称为 Java 语言的反射机制

## 2. 获取 Class 对象的三种方式

如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了三种方式获取 Class 对象（即获取反射）:

- 通过建立对象：

  ```java
  Student stu = new Student();
  Class obj1 = stu.getClass();
  ```

- 知道具体类的情况下可以使用，通过类名：

  ```java
  Class alunbarClass = TargetObject.class;
  ```

  但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象

- 通过 `Class.forName()`传入类的路径获取：

  ```java
  Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
  ```

## 3. 反射代码实例

Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：

- **Field** ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 创建新的对象。

示例代码：

创建一个我们要使用反射操作的类 `TargetObject`：

```java
package cn.javaguide;

public class TargetObject {
    private String value;

    public TargetObject() {
        value = "JavaGuide";
    }

    public void publicMethod(String s) {
        System.out.println("I love " + s);
    }

    private void privateMethod() {
        System.out.println("value is " + value);
    }
}
```

使用反射操作这个类的方法以及参数

```java
package cn.javaguide;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {
        /**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */
        Class<?> tagetClass = Class.forName("cn.javaguide.TargetObject");
        TargetObject targetObject = (TargetObject) tagetClass.newInstance();
        /**
         * 获取所有类中所有定义的方法
         */
        Method[] methods = tagetClass.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }
        /**
         * 获取指定方法并调用
         */
        Method publicMethod = tagetClass.getDeclaredMethod("publicMethod",
                String.class);
		// 注入参数并执行
        publicMethod.invoke(targetObject, "JavaGuide");
        /**
         * 获取指定参数并对参数进行修改
         */
        Field field = tagetClass.getDeclaredField("value");
        //为了对类中的参数进行修改我们取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");
        /**
         * 调用 private 方法
         */
        Method privateMethod = tagetClass.getDeclaredMethod("privateMethod");
        //为了调用private方法我们取消安全检查
        privateMethod.setAccessible(true);
        privateMethod.invoke(targetObject);
    }
}
```

输出结果：

```
publicMethod
privateMethod
I love JavaGuide
value is JavaGuide
```

> 静态编译和动态编译
> **静态编译**：在编译时确定类型，绑定对象
> **动态编译**：运行时确定类型，绑定对象

## 4. 反射机制优缺点

- 优点： 动态编译。运行期类型的判断，动态加载类，提高代码灵活度。
- 缺点：
  - 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
  - 安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。

## 5. 反射的应用场景

**反射是框架设计的灵魂。**

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

举例：

- 我们在使用 JDBC 连接数据库时使用 `Class.forName()`通过反射加载数据库的驱动程序；
- Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；
- 动态配置实例的属性；

<br>



# 二、序列化

## 1. 什么是序列化

**序列化：将对象写入到IO流中
反序列化：从IO流中恢复对象**

Java 提供了一种对象序列化的机制，该机制中，**一个对象可以被表示为一个字节序列**，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。

将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行**反序列化**，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。

整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。

## 2. 序列化的意义

序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。**序列化机制使得对象可以脱离程序的运行而独立存在。**

## 3. 序列化的使用场景

- **所有可在网络上传输的对象都必须是可序列化的**，比如 `RMI`（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；
- **所有需要保存到磁盘的java对象都必须是可序列化的**。*通常建议：程序创建的每个JavaBean类都实现Serializeable接口。*

## 4. 序列化实现的方式

👉 参照此篇博客 ：[java序列化，看这篇就够了](https://www.cnblogs.com/9dragon/p/10901448.html)

如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现`Serializable接口`或者`Externalizable接口`之一。

Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。

- **序列化：**

  步骤一：创建一个`ObjectOutputStream`输出流；

  步骤二：调用ObjectOutputStream对象的`writeObject`输出可序列化对象。

```java
public class Person implements Serializable {
		/**
		** 类具体实现
		**/
 	}
 	
public class WriteObject {
  	public static void main(String[] args) {
      	//创建一个ObjectOutputStream输出流
      	ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt"));
      	//将对象序列化到文件
      	Person person = new Person("Jack", 23);
      	oos.writeObject(person);
  	}
}
```

- **反序列化：**

  步骤一：创建一个`ObjectInputStream`输入流；

  步骤二：调用ObjectInputStream对象的`readObject()`得到序列化的对象。

```java
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.txt"))
Person brady = (Person) ois.readObject();
```



<br>



# 三、动态代理

## 1. 动态代理是什么？有哪些应用？

**动态代理：**
当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。
可以给这个类创建一个代理，**故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类**。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。可以在运行期动态创建某个interface的实例。

**动态代理的应用：**

- Spring的AOP
- 加事务
- 加权限
- 加日志

## 2. 怎么实现动态代理？

👉 参照此篇博客 ：[你真的完全了解Java动态代理吗？看这篇就够了](https://www.jianshu.com/p/95970b089360)

Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；

动态代理是通过 Proxy 创建代理对象，然后将接口方法“代理”给 `InvocationHandler` 完成的。

实例代码如下：

```java
/**
 * 定义一个接口
 */
interface Hello{
    void morning(String name);
}

/**
 * 动态代理创建接口实例
 */
public class dynamic_proxy{
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler(){
        
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if(method.getName().equals("morning")){
                    System.out.println("Good Morning," + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler);
        hello.morning("Jack");
        

    }
}
```

在运行期动态创建一个interface实例的方法如下：

1. 首先必须定义一个接口 Hello（被代理）
2. 定义一个 `InvocationHandler` 实例，它负责实现接口方法 morning 的调用；
3. 通过 `Proxy.newProxyInstance()` 创建接口 Hello 实例的代理对象，它需要3个参数：
   - 使用的 `ClassLoader` 类加载器。通常就是接口类的ClassLoader；(因为代理的是 Hello，所以用加载 Hello 的类加载器。)
   - 需要实现的接口数组，至少需要传入一个接口进去；
   - 用来处理接口方法调用的 InvocationHandler 实例。
4. 将返回的 Object 强制转型为接口。