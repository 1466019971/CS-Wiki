# 🚮 垃圾收集器

---

## 1. 概述

**垃圾收集（Garbage Collection ，GC）**的历史比 Java 久远，GC 需要思考的 3 件事情：

- 哪些内存需要回收
- 什么时候回收
- 如何回收

垃圾收集器关注的是 Java 堆中的内存，后续讨论的内存分配与回收也指这部分内存

## 2. 判断一个对象是否可被回收

垃圾收集器在对堆进行回收之前，第一件事情就是要确定这些对象之中哪些还存活，哪些已经死亡（即不可能被任何途径使用的对象）

### ① 引用计数算法

💘 先放出结论，**Java 虚拟机并不使用引用计数算法**

✍ **引用计数算法（Reference Counting）**：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

**在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收**。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。\

🗨 举个例子：

```java
public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        
        // 假设在这行发生 GC，a b 能否被回收？
        System.gc();
    }
}
```

在上述代码中，`a` 与 `b` 引用的对象实例互相持有了对象的引用，因此当我们把对 `a` 对象与 `b` 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 `Test` 对象无法被回收。

### ② 可达性分析算法

在主流的商用程序语言（Java、C# ...）的主流实现中，都是通过**可达性分析（Reachability Analysis）**来判断对象是否存活的。

✍ **可达性分析算法**：以 `GC Roots` 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，<u>可作为 ``GC Roots`  的对象包括以下几种</u>：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

<img src="https://gitee.com/veal98/images/raw/master/img/20200906162127.png" style="zoom: 60%;" />

### ③ 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

#### Ⅰ 强引用

**被强引用关联的对象不会被回收。**

使用 `new `一个新对象的方式来创建强引用：

```java
Object obj = new Object();
```

#### Ⅱ 软引用

**被软引用关联的对象只有在内存不够的情况下才会被回收。**

使用 `SoftReference `类来创建软引用：

#### Ⅲ 弱引用

**被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。**

使用 `WeakReference` 类来创建弱引用：

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### Ⅳ 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

**为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。**

使用 `PhantomReference` 来创建虚引用：

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

### ④ finalize()

<img src="https://gitee.com/veal98/images/raw/master/img/20200906164109.png" style="zoom: 45%;" />

需要注意的是：`finalize `并不是 C++ 中的析构函数， 该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此**最好不要使用**。`try-finally` 等方式可以做得更好。

### ⑤ 回收方法区

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

**主要是对常量池的回收和对类的卸载。**

为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

## 3. 垃圾收集算法



## 📚 References

- 《深入理解 Java 虚拟机 — 周志明 第 2 版》
- [CS-Notes](https://cyc2018.github.io/CS-Notes)