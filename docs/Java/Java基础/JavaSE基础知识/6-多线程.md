# 一、进程与线程相关概念
## 1. 进程
**进程是资源分配的基本单位。**

`进程控制块 (Process Control Block, PCB) ` 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jcy1ub3Rlcy0xMjU2MTA5Nzk2LmNvcy5hcC1ndWFuZ3pob3UubXlxY2xvdWQuY29tL2E2YWMyYjA4LTM4NjEtNGU4NS1iYWE4LTM4MjI4N2JmZWU5Zi5wbmc?x-oss-process=image/format,png" alt="img" style="zoom:80%;" />

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。**系统运行一个程序即是一个进程从创建，运行到消亡的过程。**

**在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。**

<img src = "https://img-blog.csdnimg.cn/20200313203640721.png?x-oss-process=image" width = "600px"/>

## 2. 线程
**线程是独立调度的基本单位。**

**一个进程中可以有多个线程，它们共享进程资源。**

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<u>**Java 程序天生就是多线程程序**，一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</u>

## 3. 进程和线程区别
- 拥有资源

	进程是资源分配的基本单位，但是 **线程不拥有资源** ，线程可以访问隶属进程的资源。

- 调度

	**线程是独立调度的基本单位** ，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- 系统开销

	由于**创建或撤销进程时**，系统都要为之分配或回收资源，如内存空间、I/O 设备等，**所付出的开销远大于创建或撤销线程时的开销** 。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

- 通信方面

	线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 4.  进程状态的切换
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jcy1ub3Rlcy0xMjU2MTA5Nzk2LmNvcy5hcC1ndWFuZ3pob3UubXlxY2xvdWQuY29tL1Byb2Nlc3NTdGF0ZS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述" style="zoom:80%;" />

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- **只有就绪态和运行态可以相互转换，其它的都是单向转换。**
- 就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 5. 并发和并行
- 并发： **同一时间段**，多个任务同时执行，微观上来看这些任务实际上是交替执行的；
- 并行： **同一时刻**，多个任务同时执行，真正意义上的同时执行
## 6. 为什么要使用多线程呢?
- **先从总体上来说：**

	从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
	
	从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

- **再深入到计算机底层来探讨：**

	单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
	
	多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。
	
##  7. 使用多线程可能带来什么问题?
并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的。

而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁、还有受限于硬件和软件的资源闲置问题。

## 8. 什么是上下文切换?
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。

**当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。**

概括来说就是：**当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。**

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

---
# 二、创建线程的三种方法
实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。
## 1. 实现 Runnable 接口
需要实现 Runnable 接口中的 `run()` 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
```

使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 `start()` 方法来启动线程。

```java
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

> **匿名内部类创建线程**：
>
> ```java
> public static void main(String[] args) {
>     	MyRunnable instance = new MyRunnable{
>         	public void run(){
>             	// ...
>         	}
>    	}
>     	new Thread(r).start();
> }
> ```

例如：模拟银行账户的取钱过程

```java
public class AccountRunnable{
    public static void main(String[] args){
        Bank bank = new Bank();
        Thread t1 = new Thread(bank,"Terminal-1");
        Thread t2 = new Thread(bank,"Terminal-2");
        bank.money = 500;
        t1.start();
        t2.start();
    }
}

class Bank implements Runnable {
    int money = 0; //全局变量

    public void run() {
        while(true){
            money -= 100;
            if(Thread.currentThread().getName().equals("Terminal-1")){
                System.out.println("Get from Terminal-1 $100, remain $" + money );
                if(money<100){
                    System.out.println("Remain < $100, Terminal-1 Quit!");
                    return;
                }
            }
            else if (Thread.currentThread().getName().equals("Terminal-2")) {
                System.out.println("Get from Terminal-2 $100, remain $" + money);
                if (money < 200) {
                    System.out.println("Remain < $200, Terminal-2 Quit!");
                    return;
                }
            }
        }
    }
}
```
> Get from Terminal-2 $100, remain $400
> Get from Terminal-2 $100, remain $300
> Get from Terminal-2 $100, remain $200
> Remain < $200, Terminal-2 Quit!
> Get from Terminal-1 $100, remain $100
> Remain < $100, Terminal-1 Quit!

**两个线程共享目标对象中的实例变量**

如果把money变量移入run的内部（成为局部变量），则线程之间不共享变量，互不影响

### ⭐ 为什么我们不能直接调用 run() 方法？

每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，**方法run()称为线程体**。通过调用Thread类的start()方法来启动一个线程。

new 一个 Thread，线程进入了新建状态；调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，**这是真正的多线程工作**。 (参照下文 <u>线程的生命周期</u> )

**而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。**


## 2. 实现 Callable 接口
与 Runnable 相比，Callable 可以有返回值，返回值通过 `FutureTask` 进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft); // It's a Runnable
    thread.start();
    System.out.println(ft.get()); // It'a Future
```

### Runnable 和 Callable 有什么区别？

- **Runnable 接口中的 run() 方法无返回值**，它做的事情只是纯粹地去执行 run() 方法中的代码而已；

- **Callable 接口中的 call() 方法是有返回值的**，是一个泛型，和 `Future、FutureTask` 配合可以用来获取异步执行的结果。

## 3. 继承 Thread 类
同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

## 4. Thread和Runnable的区别
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 

总结 实现 Runnable 接口比继承 Thread 类所具有的优势： 

- 适合多个相同的程序代码的线程去共享同一个资源。 

- 可以避免java中的单继承的局限性。 

- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 

- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

> 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。

## 5. 多线程原理

以继承 Thread 类为例

```java
public class MyThread extends Thread{
    public MyThread(String name){
        // 传递线程名称
        super(name);
    }
    public void run(){
        for(int i = 0; i < 20; i++)
            // getName()方法 来自父亲
            System.out.println(getName()+i);
    }
}
```

测试类：

```java
public class Demo {
	public static void main(String[] args) {
		System.out.println("这里是main线程");
		MyThread mt = new MyThread("小强");
        mt.start();//开启了一个新的线程
        for (int i = 0; i < 20; i++) {
       	 	System.out.println("旺财:"+i);
        }
	}
}

```

流程图：

<img src="https://gitee.com/veal98/images/raw/master/img/20200524110826.png" style="zoom: 67%;" />

程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 

通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。

<img src="https://gitee.com/veal98/images/raw/master/img/20200524112820.png" style="zoom:80%;" />

当执行线程的任务结束了，线程自动在栈内存中释放了。当所有的执行线程都结束了，那么进程就结束了。

---



# 三、线程安全

## 1. 线程安全

如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 

我们通过一个案例，演示线程的安全问题： 电影院要卖票，我们模拟电影院的卖票过程。本次电影的座位共100个 (本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖这场电影票(多个窗口一起卖这100张票) 

需要窗口，采用线程对象来模拟；需要票，Runnable 接口子类来模拟 

模拟票：

```java
public class Ticket implements Runnable{
    private int ticket = 100;    
    /**
     * 执行卖票操作
     */
    @Override
    public void run(){
        // 每个窗口卖票的操作
        // 窗口永远开启
        while(true){
            if(ticket > 0){
                // 出票操作，使用sleep模拟出票时间
                try {
                    Thread.sleep(100);
                } catch (Exception e) {

                }

                String name = Thread.currentThread().getName();
                System.out.println(name + "正在卖第" + ticket + "张票");
                ticket --;
            }
        }
    }
}
```

测试类：

```java
public class Ticket_Test {
    public static void main(String[] args) {
        // 创建线程对象
        Ticket ticket = new Ticket();
        // 创建三个窗口
        Thread t1 = new Thread(ticket,"window 1");
        Thread t2 = new Thread(ticket, "window 2");
        Thread t3 = new Thread(ticket, "window 3");
        // 同时卖票
        t1.start();
        t2.start();
        t3.start();

    }
}
```

结果中有一部分这样现象

<img src="https://gitee.com/veal98/images/raw/master/img/20200524123856.png" style="zoom:80%;" />

发现程序出现了两个问题： 

- 相同的票数,比如5这张票被卖了两回。 

- 不存在的票，比如0票与-1票，是不存在的。 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。

>  线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；
>
> 若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。

## 2. 线程同步

当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 

要解决上述多线程并发访问一个资源的安全性问题 : 也就是解决重复票与不存在票问题，Java 中提供了同步机制 (`synchronized`)来保证保证每个线程都能正常执行原子操作。

有三种方式完成同步操作：

- 同步代码块
- 同步方法
- 锁机制

### ① 同步代码块 synchronized

同步代码块： synchronized 关键字可以用于方法中的某个区块中，**表示只对这个区块的资源实行互斥访问**。

```java
synchronized(同步锁){
	需要同步操作的代码
}
```

**同步锁**: 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁. 

- 锁对象 可以是任意类型。 

- 多个线程对象 要使用同一把锁。 

  >  注意: 在任何时候,最多允许一个线程拥有同步锁, **谁拿到锁就进入代码块**, 其他的线程只能在外等着 (BLOCKED)

 使用同步代码块解决上述卖票代码的问题：

```java
public class Ticket implements Runnable{
    private int ticket = 100;
    Object lock = new Object();    

    @Override
    public void run(){
        while(true){
            synchronized(lock){
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {

                    }
                    String name = Thread.currentThread().getName();
                    System.out.println(name + "is selling" + ticket);
                    ticket--;
                }
            }   
        }
    }
}

```



### ② 同步方法 synchronized

同步方法: 使用 synchronized 修饰的方法,就叫做同步方法, **保证A线程执行该方法的时候, 其他线程只能在方法外等着。**

```java
public synchronized void method(){
	可能会产生线程安全问题的代码
}
```

谁调用这个同步方法，锁对象就是谁。默认的锁对象就是 this

```java
public class Ticket implements Runnable{
    private int ticket = 100;

    @Override
    public void run(){
        while(true){
            sellTicket();
        }
    }
    public synchronized void sellTicket(){
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (Exception e) {

            }
            String name = Thread.currentThread().getName();
            System.out.println(name + "is selling" + ticket);
            ticket--;
        }
    }
}
```



### ③ 锁机制 Lock

`java.util.concurrent.locks.Lock` 机制提供了比 synchronized 代码块和 synchronized 方法更广泛的锁定操作, 同步代码块/同步方法具有的功能 Lock 都有,除此之外更强大,更体现面向对象。 

Lock锁也称同步锁，加锁与释放锁方法化了，如下： 

- `public void lock()` : 加同步锁
- `public void unlock() ` : 释放同步锁

```java
import java.util.concurrent.locks.*;

public class Ticket implements Runnable{
    private int ticket = 100;
    Lock lock = new ReentrantLock();
    @Override
    public void run(){
        while(true){
            lock.lock();
            if (ticket > 0) {
                try {
                    Thread.sleep(100);
                } catch (Exception e) {

                }
                String name = Thread.currentThread().getName();
                System.out.println(name + "is selling" + ticket);
                ticket--;
            }
            lock.unlock();
        }
    }
 
}
```

---



# 四、线程状态

## 1. 概述

在 API `java.lang.Thread.State` 这个枚举中给出了六种线程状态：

<img src="https://gitee.com/veal98/images/raw/master/img/20200524153544.png" style="zoom:80%;" />

## 2. Timed Waiting 计时等待

Timed Waiting在API中的描述为：**一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态**

在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就 强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 <u>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)</u>，那么我们通过一个案例加深对该状态的一个理解。

案例：实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串

```java
public class Demo extends Thread {
    public void run() {
        for (int i = 0; i < 100; i++) {
            if ((i) % 10 == 0) {
                System.out.println("‐‐‐‐‐‐‐" + i);
            }
            System.out.print(i);
            try {
                Thread.sleep(1000);
                System.out.print(" 线程睡眠1秒！\n");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args) {
        new Demo().start();
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20200524154528.png" style="zoom:67%;" />

- 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 
- 为了让其他线程有机会执行，可以将 Thread.sleep() 的调用放线程 run() 之内。这样才能保证该线程执行过程 中会睡眠 
- sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态。 
- 🚩 小提示：sleep() 中指定的时间是**线程不会运行的最短时间**。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行。

**Timed Waiting 线程状态图：**

<img src="https://gitee.com/veal98/images/raw/master/img/20200524155323.png" style="zoom:80%;" />

## 3. BLOCKED（锁阻塞）

Blocked状态在API中的介绍为：**一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态**。 

比如，线程A与线程B代码中使用同一锁，如果线程 A获取到锁，线程 A 进入到 Runnable 状态，那么线程 B 就进入到 Blocked 锁阻塞状态。

这是由 Runnable 状态进入 Blocked 状态。除此 Waiting 以及 Timed Waiting 状态也会在某种情况下进入阻塞状态

**Blocked 线程状态图**

<img src="https://gitee.com/veal98/images/raw/master/img/20200524155633.png" style="zoom:80%;" />

## 4. Waiting（无限等待）

Wating状态在API中介绍为：**一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。**



示例：

```java
public class Demo extends Thread {
    public static Object obj = new Object();

    public static void main(String[] args) {
        new Thread(new Runnable(){
            @Override
            public void run(){
                while(true){
                    synchronized(obj){
                        try {
                            System.out.println(Thread.currentThread().getName() + " 获取到锁对象，调用 wait 方法，进入 waiting 状态，释放锁对象");
                            obj.wait(); // 无限等待
                            /*
                            * obj.wait(5000) 计时等待 5s, 时间到则自然醒来
                            */
                        } catch (Exception e) {
                            //TODO: handle exception
                        }
                        System.out.println(Thread.currentThread().getName() + " 从 waiting 状态醒来，获取到锁对象，继续执行");

                    }
                }
            }
        },"等待线程").start();

        new Thread(new Runnable(){
            @Override
            public void run(){
                // 每隔 3s 唤醒一次
                try {
                    System.out.println(Thread.currentThread().getName() + " 等待 3 秒种");
                    Thread.sleep(3000);
                } catch (Exception e) {
                    //TODO: handle exception
                }
                synchronized(obj){
                    System.out.println(Thread.currentThread().getName() + " 获取到锁对象，调用 notify 方法，释放锁对象");
                    obj.notify();
                }
            }
        },"唤醒线程").start();
    }
}
```



<img src="https://gitee.com/veal98/images/raw/master/img/20200524161514.png" style="zoom:80%;" />



通过上述案例我们会发现，一个调用了某个对象的 Object.`wait` 方法的线程会等待另一个线程调用此对象的 Object. `notify()` 方法 或 Object.`notifyAll()`方法。 

其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系。

 当多个线程协作时，比如A，B线程，如果 A 线程在 Runnable（可运行）状态中调用了 wait() 方法那么 A 线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候 B 线程获取到了同步锁，在运行状态中调用了 notify() 方法，那么就会将无限等待的 A 线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到 Blocked（锁阻塞状态）。 

**Waiting 线程状态图**

<img src="https://gitee.com/veal98/images/raw/master/img/20200524162423.png" style="zoom:80%;" />

---



# 五、线程间通信

## 1. 概述

**概念**：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 

比如：线程 A 用来生成包子的，线程 B 用来吃包子的，包子可以理解为同一资源，线程 A 与线程 B 处理的动作，一个 是生产，一个是消费，那么线程 A 与线程 B 之间就存在线程通信问题。

**为什么要处理线程间通信**： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们 希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 

**如何保证线程间通信有效利用资源**： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即 —— **等待唤醒机制**。

## 2. 等待唤醒机制 wait/notify

### ① 概念

**什么是等待唤醒机制：** 

这是多个线程间的一种协作机制。就是在一个线程进行了规定操作后，就进入等待状态（`wait()`）， 等待其他线程执行完他们的指定代码过后 再将 其唤醒（`notify()`）; 在有多个线程进行等待时， 如果需要，可以使用 `notifyAll()` 来唤醒所有的等待线程。 **wait/notify/notifyAll 就是线程间的一种协作机制**。 

**等待唤醒中的方法：**

 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： 

- `wait`：调用 wait() 使得线程挂起，线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时 的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象 上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 
- `notify`：唤醒挂起的线程，选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先 入座。 
- `notifyAll`：唤醒所有挂起的线程，释放所通知对象的 wait set 上的全部线程。

> 🚨 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她**需要再次尝试去获取锁**（很可能面临其它线程的竞争），**成功后才能在当初调用 wait 方法之后的地方恢复执行**。 
>
> 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态

**调用wait和notify方法需要注意的细节** 

- wait 方法与 notify 方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过 notify 唤醒使用同一个锁对象调用的 wait 方法后的线程。 
- wait 方法与 notify 方法是属于 `Object` 类的方法的。因为：**锁对象可以是任意对象，而任意对象的所属类都是继承了Object 类的。** 
- wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这两个方法。

### ② sleep() 和 wait() 有什么区别？

两者都可以暂停线程的执行。

Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。

- `sleep()`：sleep() 是线程类（**Thread**）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争 cpu 的执行时间。因为 sleep() 是 static 静态的方法，他不能改变对象的机锁，**当一个 synchronized 块中调用了 sleep() 方法，线程虽然进入休眠，但是如果对象的锁没有被释放，其他线程依然无法访问这个对象。**

- `wait()`：wait() 是 **Object** 类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，**同时释放对象的锁，使得其他线程能够访问**，可以通过notify，notifyAll方法来唤醒等待的线程

### ③ 生产者和消费者问题

**等待唤醒机制其实就是经典的“生产者与消费者”的问题。** 

就拿 生产包子消费包子 来说等待唤醒机制如何有效利用资源：

包子铺线程生产包子，吃货线程消费包子。

当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子 （即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。 

接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包 子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。

包子铺线程能否进一步执行则取决于锁的获取情况。

代码示例：

包子资源类：

```java
public class BaoZi {
    String pier ;
    String xianer ;
    boolean flag = false ;//包子资源 是否存在 包子资源状态
}
```

吃货线程类：

```java
public class ChiHuo extends Thread{
    private BaoZi bz;
    public ChiHuo(String name,BaoZi bz){
        super(name);
        this.bz = bz;
    }
    @Override
    public void run() {
        while(true){
            synchronized (bz){
                if(bz.flag == false){//没包子
                	try {
                		bz.wait();
                	} catch (InterruptedException e) {
                		e.printStackTrace();
                }
            }
            System.out.println("吃货正在吃"+bz.pier+bz.xianer+"包子");
            bz.flag = false;
            bz.notify();
            }
        }
    }
}
```

包子铺线程类：

```java
public class BaoZiPu extends Thread {
    private BaoZi bz;
    public BaoZiPu(String name,BaoZi bz){
        super(name);
        this.bz = bz;
    }
    @Override
    public void run() {
        int count = 0;
        //造包子
        while(true){
            //同步
            synchronized (bz){
                if(bz.flag == true){//包子资源 存在
                try {
                	bz.wait();
                } catch (InterruptedException e) {
                	e.printStackTrace();
                }
            }
            // 没有包子 造包子
            System.out.println("包子铺开始做包子");
            if(count%2 == 0){
                // 冰皮 五仁
                bz.pier = "冰皮";
                bz.xianer = "五仁";
            }else{
                // 薄皮 牛肉大葱
                bz.pier = "薄皮";
                bz.xianer = "牛肉大葱";
            }
            count++;
            bz.flag=true;
            System.out.println("包子造好了："+bz.pier+bz.xianer);
            System.out.println("吃货来吃吧");
            //唤醒等待线程 （吃货）
            bz.notify();
            }
        }
    }
}
```

测试类：

```java
public class Demo {
    public static void main(String[] args) {
        BaoZi bz = new BaoZi();
        ChiHuo ch = new ChiHuo("吃货",bz);
        BaoZiPu bzp = new BaoZiPu("包子铺",bz);
        ch.start();
        bzp.start();
    }
}

```

执行效果：

> 包子铺开始做包子 
>
> 包子造好了：冰皮五仁 
>
> 吃货来吃吧 
>
> 吃货正在吃冰皮五仁包子 
>
> 包子铺开始做包子 
>
> 包子造好了：薄皮牛肉大葱 
>
> 吃货来吃吧 
>
> 吃货正在吃薄皮牛肉大葱包子 
>
> 包子铺开始做包子 
>
> 包子造好了：冰皮五仁 
>
> 吃货来吃吧 
>
> 吃货正在吃冰皮五仁包子

## 3. join

**在线程中调用另一个线程的 join() 方法，会将当前线程挂起**，而不是忙等待，**直到目标线程结束**。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```java
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join(); //当前b线程被挂起，知道a线程结束
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```

> A
> B

---



# 六、线程池

## 1. 线程池思想概述

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 

那么有没有一种办法**使得线程可以复用**，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。

## 2. 线程池概念

**线程池**：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。

线程池的工作原理：

<img src="https://gitee.com/veal98/images/raw/master/img/20200524171439.png" style="zoom:80%;" />

合理利用线程池能够带来三个好处： 

- 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 
- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 
- 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

## 3. 线程池的使用 ExecutorService

Java里面线程池的顶级接口是 `java.util.concurrent.Executor` ，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 `java.util.concurrent.ExecutorService` 。 

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTA2MTA3NC8yMDE5MDkvMTA2MTA3NC0yMDE5MDkxODE2MDQzMDE0MS0xMzk5MjcxNjQ0LnBuZw?x-oss-process=image/format,png)



要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优 的，因此在 `java.util.concurrent.Executors` 线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官 方建议使用 **Executors** 工程类来创建线程池对象。

**Executors** 类中**创建线程池**的方法如下： 

- `public static ExecutorService newCachedThreadPool()`：一个任务创建一个线程；

  创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，**线程池的规模不存在任何限制**。

- `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。(创建的是**有界线程池**,也就是池中的线程个数可以指定最大数量) 

- `public static ExecutorService newSingleThreadExecutor()`：相当于大小为 1 的 FixedThreadPool。

  这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；**它的特点是能确保依照任务在队列中的顺序来串行执行**。

- `public static ExecutorService newScheduledThreadPool(int corePoolSize)`

  创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer

  

获取到了一个线程池 ExecutorService 对象，那么怎么使用呢，在这里定义了一个**使用线程池对象**的方法如下： 

`public Future submit(Runnable task)` : 获取线程池中的某一个线程对象，并执行 

> Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 



**使用线程池中线程对象的步骤**：

- 创建线程池对象
- 创建Runnable接口子类对象。(task)
- 提交Runnable接口子类对象。(take task) 
- 关闭线程池(一般不做)



**代码示例**：

Runnable实现类代码：

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("我要一个教练");
        try {
        	Thread.sleep(2000);
        } catch (InterruptedException e) {
        	e.printStackTrace();
        }
        System.out.println("教练来了： " + Thread.currentThread().getName());
        System.out.println("教我游泳,交完后，教练回到了游泳池");
    }
}

```



线程池测试类：

```java
public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
        // 创建Runnable实例对象
        MyRunnable r = new MyRunnable();
        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
        // 再获取2个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        // service.shutdown();
    }
}
```



## 4. 线程池的五种状态

线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。

- `RUNNING`：

  状态说明：**线程池处于Running状态的时候，能够接收新的任务，并且对已添加的任务进行处理**,任务不能大于规定的最大任务数；

  状态切换：线程池的初始状态是RUNNING,也就是说线程池一旦被创建就处于RUNNING状态，并且线程池中的任务数量为0；

- `SHUTDOWN`：

  状态说明：**线程池处于SHUTDOWN状态的时候，不接收新的任务，但是可以处理已经添加的任务；**

  状态切换：调用线程池的shutDown()方法的时候，线程状态由RUNNING ---->>>>SHUTDOWN

- `STOP` ：

  状态说明：**线程池处于该状态的时候，不接收新的任务，不处理已接收的任务，并且还会中断正在处理的任务**(中断并不代表线程被杀死了) , **并且清空阻塞队列**。

  状态切换：线程池调用shutDownNow()接口的时候，线程池由RUNNING(SHUTDOWN)-------->>>STOP

- `TIDYING` ：

  状态说明：**当所有的任务已经终止，阻塞队列中的任务为0，线程池会变成 TIDYING 状态**。

  状态切换：当线程池处于SHUTDOWN状态，并且阻塞队列中的任务为0，就会SHUTDOWN----->>>TIDYING,当线程池处于STOP状态下，线程池中执行任务数量为0，那么线程池状态STOP----->>>TIDYING.

- `TERMINATED`：

  状态说明：**线程池已经彻底终止，就会变成TERMINATED状态**

  状态切换：线程池处于TIDYING状态，执行完terminated()方法以后，就会实现TIDYING----->>>TERMINATED

  ![](https://gitee.com/veal98/images/raw/master/img/20200524173925.png)

---



# 七、 Lambda表达式

## 1. 函数式编程思想概述

在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过 分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以 什么形式做。 

面向对象的思想: 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 

**函数式编程思想**: 只要能获取到结果,谁去做的,怎么做的都不重要, **重视的是结果,不重视过程**

## 2. 冗余的Runnable代码

### ① 传统写法 

当需要启动一个线程去完成任务时，通常会通过 java.lang.Runnable 接口来定义任务内容，并使用 java.lang.Thread 类来启动该线程。代码如下：

```java
public class Demo01Runnable {
    public static void main(String[] args) {
        // 匿名内部类
        Runnable task = new Runnable() {
            @Override
            public void run() { // 覆盖重写抽象方法
                System.out.println("多线程任务执行！");
            }
        };
        new Thread(task).start(); // 启动线程
    }
}
```

### ② 代码分析

对于 Runnable 的匿名内部类用法，可以分析出几点内容： 

- Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的核心；
- 为了指定 run 的方法体，不得不需要 Runnable 接口的实现类； 
- 为了省去定义一个 RunnableImpl 实现类的麻烦，不得不使用匿名内部类； 
- 必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 
- 而实际上，似乎只有方法体才是关键所在。

### ③ Lambda 表达式写法

2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了 Lambda 表达式的重量级新特性

```java
public class Demo02LambdaRunnable {
    public static void main(String[] args) {
    	new Thread(() ‐> System.out.println("多线程任务执行！")).start(); // 启动线程
    }
}

```

Runnable 接口只有一个 run 方法的定义： public abstract void run(); 

即制定了一种做事情的方案（其实就是一个函数）： 

- 无参数：不需要任何条件即可执行该方案。 

- 无返回值：该方案不产生任何结果。 

- 代码块（方法体）：该方案的具体执行步骤。

同样的语义体现在 Lambda 语法中，要更加简单： 

- 前面的一对小括号即 run 方法的参数（无），代表不需要任何条件； 

- 中间的一个箭头代表将前面的参数传递给后面的代码； 
- 后面的输出语句即业务逻辑代码。

## 3. Lambda 标准格式

Lambda表达式的标准格式为： 

```java
(参数类型 参数名称) ‐> { 代码语句 }
```

格式说明： 

- 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔
- `->` 是新引入的语法格式，代表指向动作
- 大括号内的语法与传统方法体要求基本一致

## 4. Lambda 实例

### ① 无参无返回值

给定一个厨子 Cook 接口，内含唯一的抽象方法 makeFood ，且无参数、无返回值。如下：

```java
public interface Cook {
	void makeFood();
}
```

在下面的代码中，使用 Lambda 的标准格式调用 invokeCook 方法，打印输出 “吃饭啦” 字样：

```java
public class Demo05InvokeCook {
    public static void main(String[] args) {
    	invokeCook(() -> {
            System.out.println("吃饭啦");
        })
    }
    private static void invokeCook(Cook cook) {
    	cook.makeFood();
    }
}
```



### ② 有参有返回值

需求: 

使用数组存储多个 Person 对象，对数组中的 Person 对象使用 Arrays 的 sort 方法对年龄进行升序排序

**传统写法：**

```java
import java.util.Arrays;
import java.util.Comparator;
public class Demo06Comparator {
    public static void main(String[] args) {
        // 本来年龄乱序的对象数组
        Person[] array = {
        new Person("古力娜扎", 19),
        new Person("迪丽热巴", 18),
        new Person("马尔扎哈", 20) };
        // 匿名内部类
        Comparator<Person> comp = new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge() ‐ o2.getAge();
            }
        };
        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例
        for (Person person : array) {
        	System.out.println(person);
        }
    }
}
```



**Lambda 表达式写法：**

```java
import java.util.Arrays;
public class Demo07ComparatorLambda {
    public static void main(String[] args) {
        Person[] array = {
        new Person("古力娜扎", 19),
        new Person("迪丽热巴", 18),
        new Person("马尔扎哈", 20) };
        Arrays.sort(array, (Person a, Person b) ‐> {
        	return a.getAge() ‐ b.getAge();
        });
        for (Person person : array) {
        	System.out.println(person);
        }
    }
}
```



## 5. Lambda 使用前提

Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 

- 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一 时，才可以使用Lambda。 
- 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 
- 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。

---



# 八、线程的常用控制方法

## 1. join() 
**在线程中调用另一个线程的 join() 方法，会将当前线程挂起**，而不是忙等待，**直到目标线程结束**。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```java
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join(); //当前b线程被挂起，知道a线程结束
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```
> A
> B
>
## 2. Daemon 守护线程
**守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。**

当所有前后线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

在线程启动之前使用 `setDaemon(true)` 方法可以将一个线程设置为守护线程。

```java
public class daemon extends Thread{
    public void run(){
        for(int i = 0;i<10;i++)
            System.out.println(getName() + ":" + i);
    }

    public static void main(String[] args) {
        daemon ds = new daemon();
        ds.setDaemon(true);
        ds.start();
        System.out.println("main Thread End");
    }
}

```
> main Thread End
> Thread-0:0
> Thread-0:1
> Thread-0:2

当主线程结束时，守护线程也结束了，守护线程中的for循环一共可以循环10次，但只运行了3次就结束了。
main是前台进程，而ds因为设置了守护线程由前台进程变成了后台进程。

## 3. sleep()
`Thread.sleep(millisec)`  方法会**休眠当前正在执行的线程**，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

## 4. yield()
对静态方法 `Thread.yield()` 的调用声明了**当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行**。该方法只是对线程调度器的一个建议，而且也只是建议**具有相同优先级的其它线程**可以运行。

```java
public void run() {
    Thread.yield();
}
```











---
# 九、什么是线程死锁?如何避免死锁?
## 1. 什么是线程死锁
死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁线程。


如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，A想要等待B释放资源1，B想要等待A释放资源2，所以这两个线程就会互相等待而进入死锁状态。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200318211114223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTMzOTg2,size_16,color_FFFFFF,t_70)
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 ：

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) { //占有资源1，其他人无法获取
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) { //意图获取资源2
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) { //占有资源2，其他人无法获取
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) { //意图获取资源1
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

> Output
>
> Thread[线程 1,5,main]get resource1 
> Thread[线程 2,5,main]get resource2
> Thread[线程 1,5,main]waiting get resource2 
> Thread[线程 2,5,main]waiting get resource1

线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。

**产生死锁必须具备以下四个条件：**

- **互斥条件**：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。即该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，于是请求阻塞，但又对自己获得的资源保持不放。即一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**:是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。

## 2. 如何避免死锁
我们只要破坏产生死锁的四个条件中的其中一个就可以了。

- **破坏互斥条件**

	这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

- **破坏请求与保持条件**

	一次性申请所有的资源。

- **破坏不剥夺条件**

	占用部分资源的线程进一步申请其他资源时，**如果申请不到，可以主动释放它占有的资源**。

- **破坏循环等待条件**

	靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

我们对线程 2 的代码修改成下面这样就不会产生死锁了。
```java
    new Thread(() -> {
        synchronized (resource1) { 
            System.out.println(Thread.currentThread() + "get resource1");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread() + "waiting get resource2");
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
            }
        }
    }, "线程 2").start();
```

> Output
>
> Thread[线程 1,5,main]get resource1 
> Thread[线程 1,5,main]waiting get resource2 
> Thread[线程 1,5,main]get resource2 
> Thread[线程 2,5,main]get resource1 
> Thread[线程 2,5,main]waiting get resource2 
> Thread[线程 2,5,main]get resource2


我们分析一下上面的代码为什么避免了死锁的发生?

线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。

---



# 📚 References

- 🎈 [CS-Notes](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
- 🎆 [JavaGuide](https://gitee.com/SnailClimb/JavaGuide)
- 🎉 [Java 208 道面试题](https://mp.weixin.qq.com/s/ywOwdXuMG5rhEXMH_OXKEQ)
- 🎃 [Executor线程池原理详解](https://www.cnblogs.com/yatou-blog/p/11595599.html)
- 📕 李伟 《Java程序设计案例教程》