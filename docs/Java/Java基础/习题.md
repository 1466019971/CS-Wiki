# ✍ Java 编程思想 - 第四版 - 课后习题

---

> 😀 本文练习题的题号均对应《Java 编程思想》书中的题号，有些相似或者重复题目就没有列出来~

## Everything is an Object 一切皆是对象

**练习 1：创建一个类，它包含一个 int 域和一个 char 域，它们都没有被初始化，将它们的值打印出来，以验证 java 执行了默认初始化。**

```java
public class ex1 {
    static int i;
    static char c;
    public static void main(String[] args) {
        System.out.println("i = " + i); // 0
        System.out.println("c = " + c); // “”
    }
}
```

**练习 2：创建一个“Hello World”程序，该程序只要输出这句话即可**

```java
public class ex2 {
    public static void main(String[] args){
        System.out.println("Hello world!");
    }
}
```

**练习 3：将下列类改写成完整的程序**

```java
class ATypeName {
   int i;
   double d;
   boolean b;
   void show() {
      System.out.println(i);
      System.out.println(d);
      System.out.println(b);  
   }
}  
```

```java
public class ex3 {
    public static void main(String[] args){
        class ATypeName{
            int i;
            double d;
            boolean b;
            void show(){
                System.out.println(i);
                System.out.println(d);
                System.out.println(b);
            }
        }
        ATypeName a = new ATypeName();
        a.i = 3;
        a.d = 2.71828;
        a.b = false;
        a.show();
    }
}
```

**练习 6：编写一个程序，让它含有下列定义的 `storage()` 方法的代码段，并调用之**

```java
int storage(String s) {
  return s.length() * 2;
}  
```

```java
public class ex6 {
    public static void main(String[] args) {
        class StoreStuff{
            int storage(String s){
                return s.length()*2;
            }
        }
        StoreStuff s = new StoreStuff();
        System.out.println(s.storage("hello")); // 10
    }
}
```

**练习 8：编写一个程序，展示无论你创建了某个特定类的多少个对象，这个类中的某个特定的 static 域只有一个实例**

```java
class StaticTest{
    static int i = 47;
}
class Incrementable{
    static void increment(){
        StaticTest.i ++;
    }
}

public class ex8 {
    public static void main(String[] args){
        System.out.println("StaticTest.i = " + StaticTest.i);
        
        StaticTest st1 = new StaticTest();
        StaticTest st2 = new StaticTest();
        System.out.println("st1.i = " + st1.i); // 47
        System.out.println("st2.i = " + st2.i); // 47
        
        Incrementable sf = new Incrementable();
        sf.increment();
        System.out.println("After sf.increment() called: "); 
        System.out.println("st1.i = " + st1.i); // 48
        System.out.println("st2.i = " + st2.i); // 48
        
        Incrementable.increment();
        System.out.println("After Incrementable.increment() called: ");
        System.out.println("st1.i = " + st1.i); // 49
        System.out.println("st2.i = " + st2.i); // 49
        
        st1.i = 3;
        System.out.println("After st1.i = 3 callend: ");
        System.out.println("st1.i = " + st1.i); // 3
        System.out.println("st2.i = " + st2.i); // 3
        
        System.out.println("Create another StaticTest st3.");
        StaticTest st3 = new StaticTest();
        System.out.println("st3.i = " + st3.i); // 3
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200712104807.png)

**练习 9：编写一个程序，展示自动包装功能对所有的基本类型和包装器类型都起作用**

```java
public class ex9 {
    public static void main(String [] args){
        boolean b = false;
        char c = 'X';
        byte t = 8;
        short s = 16;
        int i = 32;
        long l = 64;
        float f = 0.32f;
        double d = 0.64;

        Boolean B = b;
        System.out.println("boolean b = " + b);
        System.out.println("boolean B = " + B);

        Character C = c;
        System.out.println("char c = " + c);
        System.out.println("Character C = " + C);

        Byte T = t;
        System.out.println("byte t = " + t);
        System.out.println("Byte T = " + T);

        Short S = s;
        System.out.println("short s = " + s);
        System.out.println("Short S = " + S);

        Integer I = i;
        System.out.println("int i = " + i);
        System.out.println("Integer I = " + I);

        Long L = l;
        System.out.println("long l = " + l);
        System.out.println("Long L = " + L);

        Float F = f;
        System.out.println("float f = " + f);
        System.out.println("Float F = " + F);
        
        Double D = d;
        System.out.println("double d = " + d);
        System.out.println("Double D = " + D);
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200712105344.png)

**练习 11：将 `AllTheColorsOfTheRainbxow` 这个示例改写成一个程序**

```java
public class ex11 {
    public static void main(String[] args){
        AllTheColorsOfTheRainbow atc = new AllTheColorsOfTheRainbow();
        System.out.println("atc.anIntegerRepresentingColors = " + atc.anIntegerRepresentingColors); // 0
        atc.changeColor(7);
        atc.changeTheHueOfTheColor(77);
        System.out.println("After color change, atc.anIntegerRepresentingColors = " + atc.anIntegerRepresentingColors); // 7
        System.out.println("atc.hue = " + atc.hue); // 7
    }
}

class AllTheColorsOfTheRainbow {
    int anIntegerRepresentingColors = 0;
    int hue = 0;

    void changeTheHueOfTheColor(int newHue) {
        hue = newHue;
    }

    int changeColor(int newColor) {
        return anIntegerRepresentingColors = newColor;
    }
}
```

## Operators 操作符

**练习 2：创建一个包含一个 float 域的类。并用这个类来展示别名机制。**

```java
public class ex2 {

    public static void main(String[] args) {
        Integral integral1 = new Integral();
        Integral integral2 = new Integral();
        integral1.f = 9f;
        integral2.f = 47f;
        System.out.println("1:integral1.f=" + integral1.f + ",integral2.f=" + integral2.f); // 9.0  47.0
        integral1 = integral2;
        System.out.println("2:integral1.f=" + integral1.f + ",integral2.f=" + integral2.f); // 47.0 47.0
        integral1.f = 27f;
        System.out.println("3:integral1.f=" + integral1.f + ",integral2.f=" + integral2.f); // 27.0 27.0

    }

}

class Integral {
    float f;
}
```

**练习 3：创建一个包含一个 float 域的类。并用这个类来展示方法调用时的别名机制**

```java
public class ex3 {
    static void func(Integral y){
        y.f = 1.0f;
    } 
    public static void main(String[] args){
        Integral x = new Integral();
        x.f = 2.0f;
        System.out.println("1:x.f=" + x.f); // 2.0
        func(x);
        System.out.println("2:x.f=" + x.f); // 1.0

    }
}

class Integral {
    float f;
}
```

**练习 4：编写一个计算速度的程序，它所使用的距离和时间都是常量**

```java
public class ex4 {
    public static void main(String[] args){
        float distance = 100;
        float time = 20;
        float velocity = distance/time;
        System.out.println(velocity);
    }
}
```

**练习 5：创建一个名为 Dog 的类，它包含两个 String 域：name 和 says。在 main() 方法中，创建两个Dog 对象，一个名为 spot（它的叫声为 “ Ruff!”），另一个名为 scruffy（它的叫声为 ”Wuff!”）。然后显示它们的名字和叫声。**

```java
class Dog {
    String name;
    String says;
}

public class ex5 {
    public static void main(String[] args){
        Dog dog1 = new Dog();
        dog1.name = "spot";
        dog1.says = "Ruff!";
        System.out.println(dog1.name + " says " + dog1.says);

        Dog dog2 = new Dog();
        dog2.name = "scruffy";
        dog2.says = "Wurf!";
        System.out.println(dog2.name + " says " + dog2.says);
    }
}
```

**练习 6：在练习（5）的基础上，创建一个新的 Dog 索引，并对其赋值为 spot 对象。测试用==和equals（）方法来比较所有引用的结果**

```java
class Dog {
    String name;
    String says;
}

public class ex6 {
    public static void main(String[] args){
        Dog dog1 = new Dog();
        dog1.name = "spot";
        dog1.says = "Ruff!";
        System.out.println(dog1.name + " says " + dog1.says);

        Dog dog2 = new Dog();
        dog2.name = "scruffy";
        dog2.says = "Wurf!";
        System.out.println(dog2.name + " says " + dog2.says);

        Dog dog3 = dog1;
        System.out.println("Compareing dog1 and dog2 objects");
        compare(dog1, dog2); 
        System.out.println("\nCompareing dog1 and dog3 objects");
        compare(dog1, dog3);
        System.out.println("\nCompareing dog2 and dog3 objects");
        compare(dog2, dog3);

    }

    static void compare(Dog dog1, Dog dog2){
        System.out.println("== on top references: "+(dog1==dog2));
        System.out.println(".equals() on top references: "+dog1.equals(dog2));
        System.out.println("== on name: "+(dog1.name==dog2.name));
        System.out.println(".equals() on name: "+dog1.name.equals(dog2.name));
        System.out.println("== on Says: "+(dog1.says==dog2.says));
        System.out.println(".equals() on Says: "+dog1.says.equals(dog2.says));
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200712121550.png)

> 💡 `==` 用来检测两个对象是否在同一位置上，`equals` 用来检测两个对象是否相等

**练习 7：编写一个程序，模拟扔硬币的结果。**

```java
public class ex7 {
    public static void main(String[] args){
        Random random = new Random(47); 
        boolean flip = random.nextBoolean(); 
        System.out.println(flip == true?"Head":"Tail");
    }
}
```

> - `Random(long seed)` : 使用 long 数据类型的种子构造一个随机数生成器
>
> - `boolean nextBoolean()`:  返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean值。

**练习 9：分别显示用 float 和 double 指数记数法所能表示的最大和最小的数字。**

```java
public class ex9 {
    public static void main(String[] args) {
        System.out.println("Float.MAX_VALUE = "+Float.MAX_VALUE);
        System.out.println("Float.MIN_VALUE = "+Float.MIN_VALUE);
        System.out.println("Double.MAX_VALUE = "+Double.MAX_VALUE);
        System.out.println("Double.MIN_VALUE = "+Double.MIN_VALUE);
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200712143340.png)

## Controlling Execution 控制执行流程 

**练习 9：一个斐波那契数列由数字1、1、2、3、5、8、13、21、34等等组成的，其中每个数字（第三个数字起）都是前两个数字的之和。创建一个方法，接受一个整数参数，并显示从第一个元素开始总共由该参数指定的个数所构成的所有斐波那契数字**

```java
import java.util.Scanner;

public class ex9 {
    static int fib(int n){
        if(n <= 2)
            return 1;
        else
            return fib(n-1) + fib(n-2);
    }

    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        for(int i = 0; i < n; i++)
            System.out.print(fib(i) + " ");
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713195101.png)

**练习 10： 吸血鬼数字是指位数为偶数的数字，可以由一对数字相乘而得到，而这对数字包含乘积一半位数的数字，其中从最初的数字中选取的数字可以任意排序。以两个0结尾的数字是不允许的，例如，下列数字就是“吸血鬼”数字：**

1260 = 21 x 60

1827 = 21 x 87

2187 = 27 x 81

写一个程序，找出4位数的所有吸血鬼数字。

```java
public class ex10 {
    static int a(int i){
        return i / 1000; // 表示这个四位数的千位数
    }
    static int b(int i){
        return (i%1000)/100; // 表示这个四位数的百位数
    }
    static int c(int i) {
        return ((i % 1000) % 100) / 10; // 表示这个四位数的十位数
    }
    static int d(int i) {
        return ((i % 1000) % 100) % 10; // 表示这个四位数的个位数
    }

    static int com(int num1, int num2){
        return (num1 * 10) + num2; // 表示两个一位数组合成一个两位数
    }

    /**
     * 判断是否是吸血鬼数
     * 
     * @param i 待判断的4位数
     * @param m 从这4位数的4个数字中挑选出来随机组合的一个两位数
     * @param n 从这4位数的4个数字中挑选出来随机组合的另一个两位数
     */
    static void productTest(int i, int m, int n){
        if(m * n == i)
            System.out.println(i + "=" + m + "*" + n);
    }
    public static void main(String[] args){
        // 找出所有 4 位数的吸血鬼数
        for(int i = 1001; i < 9999; i++){
            productTest(i, com(a(i), b(i)), com(c(i), d(i)));
            productTest(i, com(a(i), c(i)), com(b(i), d(i)));
            productTest(i, com(a(i), c(i)), com(d(i), b(i)));
            productTest(i, com(a(i), d(i)), com(b(i), c(i)));
            productTest(i, com(a(i), d(i)), com(c(i), b(i)));
            productTest(i, com(b(i), a(i)), com(c(i), d(i)));
            productTest(i, com(b(i), a(i)), com(d(i), c(i)));
            productTest(i, com(b(i), c(i)), com(d(i), a(i)));
            productTest(i, com(b(i), d(i)), com(c(i), a(i)));
            productTest(i, com(c(i), a(i)), com(d(i), b(i)));
            productTest(i, com(c(i), b(i)), com(d(i), a(i)));
        }
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713201043.png)

## Initialization & Cleanup 初始化与清理

**练习 1：创建一个类，它包含一个未初始化的 String 引用。验证该引用被 Java 初始化成了 null。**

```java
public class ex1 {
    public static void main(String[] args){
        String s = new String();
        System.out.println("s = " + s);
    }
}
```

**练习 5：创建一个名为Dog的类，它具有重载的bark（）方法。此方法应根据不同的基本数据类型进行重载，并根据被调用的版本，打印出不同类型的狗吠（barking）、咆哮（howling）等信息，编写main（）来调用所有不同版本的方法。**

```java
public class ex5 {
     public static void main(String[] args) {
        Dog dog = new Dog();
        dog.bark();
        dog.bark(1);
    }
}
class Dog{
     public void bark() {
         System.out.println("barking");
     }
     public void bark(int i) {
         System.out.println("howling");
     }
}
```

**练习 8：编写具有两个方法的类，在第一个方法内调用第二个方法两次：第一次调用时不使用this关键字，第二次调用时使用this关键字**

> 这里只是为了验证它是起作用的，你不应该在实践中使用这种方法。

```java
class Doc {
    void intubate() {
        System.out.println("prepare patient");
        laryngoscopy();
        this.laryngoscopy();
    }

    void laryngoscopy() {
        System.out.println("use laryngoscope");
    }
}

public class ex8 {
    public static void main(String[] args) {
        new Doc().intubate();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713202418.png)

**练习 9：编写两个（重载）构造器的类，并在第一个构造器中, 通过this调用第二个构造器。**

```java
class Doc1 {
    Doc1(int i) {
        this("MD");
        int yearsTraining = i;
        System.out.println("New doc with " + i + " years of training");
    }

    Doc1(String s) {
        String degree = s;
        System.out.println("New doc with " + s + " degree");
    }

    void intubate() {
        System.out.println("prepare patient");
        laryngoscopy();
    }

    void laryngoscopy() {
        System.out.println("use laryngoscope");
    }
}

public class ex9 {
    public static void main(String[] args) {
        new Doc1(8).intubate();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713202606.png)

**练习 10：编写具有 finalize 方法的类，并在方法中打印消息，在main 中为该类创建一个对象，试解释这个程序的行为。**

```java
class WebBank {
    String name;
    boolean loggedIn = false;

    public WebBank() {
        loggedIn = true;
        name = null;
    }

    public WebBank(String s){
        loggedIn = true;
        name = s;
    }

    public String getName(){
        return this.name;
    }

    void logOut() {
        loggedIn = false;
    }

    protected void finalize() {
        if (loggedIn)
            System.out.println(this.getName() + " Error: still logged in");
        else
            System.out.println(this.getName() + " OK: logged out successful!");
        // Normally, you'll also call the base-class version:
        // super.finalize();
    }
}

public class ex10 {
    public static void main(String[] args) {
        WebBank bank1 = new WebBank("web1");
        WebBank bank2 = new WebBank("web2");
        // Proper cleanup: log out of bank1 before going home
        bank1.logOut();
        // Drop the reference, forget to cleanup:
        new WebBank("web3");
        // Force garbage collection and finalization:
        System.gc();
        
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713205046.png)

显然，web1 和 web2 的 finalize 方法并没有被调用，因为 Java 并不保证 finalize 何时或者一定会被调用。

**练习 11：修改前一个练习的程序,让你的 finalize 总会被调用。**

```java
class WebBank {
    String name;
    boolean loggedIn = false;

    public WebBank() {
        loggedIn = true;
        name = null;
    }

    public WebBank(String s){
        loggedIn = true;
        name = s;
    }

    public String getName(){
        return this.name;
    }

    void logOut() {
        loggedIn = false;
    }

    protected void finalize() {
        if (loggedIn)
            System.out.println(this.getName() + " Error: still logged in");
        else
            System.out.println(this.getName() + " OK: logged out successful!");
        // Normally, you'll also call the base-class version:
        // super.finalize();
    }
}

public class ex10 {
    public static void main(String[] args) {
        WebBank bank1 = new WebBank("web1");
        WebBank bank2 = new WebBank("web2");
        new WebBank("web3");
        // Proper cleanup: log out of bank1 before going home:
        bank1.logOut();
        // Forget to logout of bank2 and unnamed new bank
        // Attempts to finalize any missed banks:
        System.out.println("Try 1: ");
        System.runFinalization();
        System.out.println("Try 2: ");
        Runtime.getRuntime().runFinalization(); // 等价于 System.runFinalization();
        System.out.println("Try 3: ");
        System.gc();
        System.out.println("Try 4: ");
        // using deprecated since 1.1 method:
        System.runFinalizersOnExit(true);
        
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713204536.png)

这样，web1，web2，web3 的 finalize  方法就都一定会被执行了。

**练习 12：编写名为Tank的类，此类的状态可以是“满的”或“空的”。其终结条件是：对象被清理时必须处于空状态。 请编写finalize（）以检验终结条件是否成立，在 main（）中测试 Tank 可能发生的几种使用方式**

```java
class Tank {
    static int counter = 0;
    int id = ++ counter; 

    int howFull = 0;

    Tank() {
        this(0);
    }

    Tank(int fullness) {
        howFull = fullness;
    }

    void sayHowFull() {
        if (howFull == 0)
            System.out.println("Tank " + this.id + " is empty");
        else
            System.out.println("Tank " + this.id + " filling status = " + howFull);
    }

    void empty() {
        howFull = 0;
    }

    protected void finalize() {
        if (howFull != 0)
            System.out.println("Tank " + this.id + " not empty");
        else {
            System.out.println("Tank " + this.id + " cleaned up Ok");
        }
        // Normally, you'll also do this:
        // super.finalize(); // Call the base-class version
    }
}

public class ex12 {
    public static void main(String[] args) {
        Tank tank1 = new Tank(); // new Tank(0) id = 1
        Tank tank2 = new Tank(3); // id = 2
        Tank tank3 = new Tank(5); // id =3
        // Proper cleanup: empty tank before going home
        tank2.empty();
        // Drop the reference, forget to cleanup:
        new Tank(6); // id = 4
        System.out.println("Check tanks:");
        System.out.println("tank1: ");
        tank1.sayHowFull();
        System.out.println("tank2: ");
        tank2.sayHowFull();
        System.out.println("tank3: ");
        tank3.sayHowFull();
        System.out.println("first forced gc():");
        System.gc();
        // Force finalization on exit but using method
        // deprecated since JDK 1.1:
        System.out.println("try deprecated runFinalizersOnExit(true):");
        System.runFinalization();
        System.out.println("last forced gc():");
        System.gc();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713210806.png)

只执行了 Tank 4 的 finalize 方法。

**练习 14：编写一个类，拥有两个静态字符串域，其中一个在定义处初始化，另一个在静态块中初始化。现在，加入一个静态方法用以打印出两个字段值。请证明它们都会在被使用之前完成初始化动作。**

```java
class Go {
    static String s1 = "run";
    static String s2, s3;
    // 只会被执行一次
    static {
        s2 = "drive car";
        s3 = "fly plane";
        System.out.println("s2 & s3 initialized");
    }

    static void how() {
        System.out.println(s1 + " or " + s2 + " or " + s3);
    }

    public Go() {
        System.out.println("Go()");
    }
}

public class ex14 { 
    static Go g1 = new Go();
    static Go g2 = new Go();

    public static void main(String[] args) {
        System.out.println("Inside main()");
        Go.how();
        System.out.println("Go.s1: " + Go.s1);
    }

}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713212356.png)

**练习 19：写一个类，他接受一个可变参数的String数组，验证你可以向该方法传递一个用逗号分隔的String列表，或是一个 String[]。**

```java
public class ex19 {
    static void showString(String ...args){
        for(String s : args){
            System.out.print(s + " ");
        }
        System.out.println();
    }

    public static void main(String[] args){
        showString("one","two","three");
        showString(new String[]{"a","b","c","d"});
    }
}
```

**练习 21：创建一个 enum，它包含纸币中最小面值的 6 种类型。通过 values() 循环并打印每一个值及其ordinal() 下标**

```java

public class ex21 {
    public enum Bills {
        ONE, FIVE, TEN, TWENTY, FIFTY, HUNDRED
    }

    public static void main(String[] args) {
        for (Bills b : Bills.values())
            System.out.println(b + ", ordinal " + b.ordinal());
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713215701.png)

**练习 22：在前面的例子中，为enum写一个switch语句，对于每一个case，输出该特定货币的描述。**

```java
package Thinking_in_Java.InitAndClean;


public class ex21 {
    public enum Bills {
        ONE, FIVE, TEN, TWENTY, FIFTY, HUNDRED
    }

    public static void main(String[] args) {
        for (Bills b : Bills.values()){
            switch(b){
                case ONE:
                System.out.println("George Washington");
                break;
            case FIVE:
                System.out.println("Abraham Lincoln");
                break;
            case TEN:
                System.out.println("Alexander Hamilton");
                break;
            case TWENTY:
                System.out.println("Andrew Jackson");
                break;
            case FIFTY:
                System.out.println("U.S. Grant");
                break;
            }
        }
    }
}
```

## Access Control 访问权限控制

**练习 4：展示 protected 方法具有包访问权限，但是它仍旧不是 public 的。**

首先，protected 的包访问权限（注意以下这两个类是同一个包）

```java
/*
* package access.cookie2;
*
* public class Cookie {
*	public Cookie() {
*		System.out.println("Cookie contstructor");
*	}
*	protected void bite() { System.out.println("bite"); }
* }
*/

package access.cookie2;

public class CookieMonster {
	public static void main(String[] args) {
		Cookie x = new Cookie();
		x.bite(); // package access to protected method
	}	
}
```

然后，我们来看看 protected 是无法跨包访问的（以下这两个类不属于同一个包）

```java
/*
* package access.cookie2;
*
* public class Cookie {
*	public Cookie() {
*		System.out.println("Cookie contstructor");
*	}
*	protected void bite() { System.out.println("bite"); }
* }
*/

import access.cookie2.*;

public class CookieThief {
	public static void main(String[] args) {
		Cookie x = new Cookie();
		// x.bite(); // access protected
	}	
}
```

**练习 5：创建一个带有public，private，protected和包访问权限域以及方法成员的类。创建一个该类的一个对象，看看在你试图调用所有类成员时，会得到什么类型的编译信息。请注意，处于同一个目录中的所有类都是默认包的一部分**

在同一包下创建以下两个类：

```java
/* in same directory:
* package access; 
*
* public class FourWays {
*	int a = 0;
*	public int b = 1;
*	protected int c = 2;
*	private int d = 3;
*	FourWays() { System.out.println("FourWays() constructor"); }
*	void showa() { System.out.println(a); }
*	public void showb() { System.out.println(b); }
*	protected void showc() { System.out.println(c); }
*	private void showd() { System.out.println(d); }	
* }
*/

package access; 

public class AccessTest {
	public static void main(String[] args) {
		FourWays fw = new FourWays();
		fw.showa();
		fw.showb();
		fw.showc();
		fw.a = 10;
		fw.b = 20;
		fw.c = 30;
		fw.showa();
		fw.showb();
		fw.showc();
		//! fw.showd(); // private access, compiler can't touch
	}	
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713221908.png)

**练习 8：创建一个名为ConnectionManager的类，该类管理一个元素为Connection对象的固定数组。客户端程序员不能直接创建Connection对象，而只能通过ConnectionManager中的某个static方法来获取他们。当ConnectionManager之中不再有对象时，它会返回null引用。在main（）之中检测这些类。**

```java
class Connection {
    private static int count = 0;
    private int i = 0;

    // 私有构造，使得程序员不能直接创建Connection对象
    private Connection() {
        System.out.println("Connection()");
    }

    // Allow creation via static method:
    static Connection makeConnection() {
        count++;
        return new Connection();
    }

    public static int howMany() {
        return count;
    }

    public String toString() {
        return ("Connection " + count);
    }
}

public class ConnectionManager {
    static int howManyLeft = 3;
    static Connection[] ca = new Connection[3];
    {
        for (Connection x : ca)
            x = Connection.makeConnection();
    }

    public static Connection getConnection() {
        if (howManyLeft > 0)
            return ca[--howManyLeft];
        else {
            System.out.println("No more connections");
            return null;
        }
    }

    public static void main(String[] args) {
        ConnectionManager cm = new ConnectionManager();
        System.out.println(cm.howManyLeft);
        cm.getConnection();
        System.out.println(howManyLeft);
        cm.getConnection();
        System.out.println(howManyLeft);
        cm.getConnection();
        System.out.println(cm.getConnection());
        System.out.println(howManyLeft);
    }

```

![](https://gitee.com/veal98/images/raw/master/img/20200713222623.png)



## 📚 References

- 《Java 编程思想 - 第四版 - 中文翻译版》

- [Thinking in Java 4th Edition (Bruce Eckel) 课后习题答案](http://greggordon.org/java/tij4/solutions.htm)
- [Java 编程思想第四版练习](https://blog.csdn.net/lelouch_j_zs/category_7270086.html)