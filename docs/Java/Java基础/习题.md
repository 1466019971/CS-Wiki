# ✍ Java 编程思想 - 第四版 - 课后习题

---

> 😀 本文练习题的题号均对应《Java 编程思想》书中的题号，有些相似或者重复题目就没有列出来~

## Everything is an Object 一切皆是对象



**练习 9：编写一个程序，展示自动包装功能对所有的基本类型和包装器类型都起作用**

```java
public class ex9 {
    public static void main(String [] args){
        boolean b = false;
        char c = 'X';
        byte t = 8;
        short s = 16;
        int i = 32;
        long l = 64;
        float f = 0.32f;
        double d = 0.64;

        Boolean B = b;
        System.out.println("boolean b = " + b);
        System.out.println("boolean B = " + B);

        Character C = c;
        System.out.println("char c = " + c);
        System.out.println("Character C = " + C);

        Byte T = t;
        System.out.println("byte t = " + t);
        System.out.println("Byte T = " + T);

        Short S = s;
        System.out.println("short s = " + s);
        System.out.println("Short S = " + S);

        Integer I = i;
        System.out.println("int i = " + i);
        System.out.println("Integer I = " + I);

        Long L = l;
        System.out.println("long l = " + l);
        System.out.println("Long L = " + L);

        Float F = f;
        System.out.println("float f = " + f);
        System.out.println("Float F = " + F);
        
        Double D = d;
        System.out.println("double d = " + d);
        System.out.println("Double D = " + D);
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200712105344.png)





**练习 7：编写一个程序，模拟扔硬币的结果。**

```java
public class ex7 {
    public static void main(String[] args){
        Random random = new Random(47); 
        boolean flip = random.nextBoolean(); 
        System.out.println(flip == true?"Head":"Tail");
    }
}
```

> - `Random(long seed)` : 使用 long 数据类型的种子构造一个随机数生成器
>
> - `boolean nextBoolean()`:  返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean值。



## Initialization & Cleanup 初始化与清理





**练习 10：编写具有 finalize 方法的类，并在方法中打印消息，在main 中为该类创建一个对象，试解释这个程序的行为。**

```java
class WebBank {
    String name;
    boolean loggedIn = false;

    public WebBank() {
        loggedIn = true;
        name = null;
    }

    public WebBank(String s){
        loggedIn = true;
        name = s;
    }

    public String getName(){
        return this.name;
    }

    void logOut() {
        loggedIn = false;
    }

    protected void finalize() {
        if (loggedIn)
            System.out.println(this.getName() + " Error: still logged in");
        else
            System.out.println(this.getName() + " OK: logged out successful!");
        // Normally, you'll also call the base-class version:
        // super.finalize();
    }
}

public class ex10 {
    public static void main(String[] args) {
        WebBank bank1 = new WebBank("web1");
        WebBank bank2 = new WebBank("web2");
        // Proper cleanup: log out of bank1 before going home
        bank1.logOut();
        // Drop the reference, forget to cleanup:
        new WebBank("web3");
        // Force garbage collection and finalization:
        System.gc();
        
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713205046.png)

显然，web1 和 web2 的 finalize 方法并没有被调用，因为 Java 并不保证 finalize 何时或者一定会被调用。

**练习 11：修改前一个练习的程序,让你的 finalize 总会被调用。**

```java
class WebBank {
    String name;
    boolean loggedIn = false;

    public WebBank() {
        loggedIn = true;
        name = null;
    }

    public WebBank(String s){
        loggedIn = true;
        name = s;
    }

    public String getName(){
        return this.name;
    }

    void logOut() {
        loggedIn = false;
    }

    protected void finalize() {
        if (loggedIn)
            System.out.println(this.getName() + " Error: still logged in");
        else
            System.out.println(this.getName() + " OK: logged out successful!");
        // Normally, you'll also call the base-class version:
        // super.finalize();
    }
}

public class ex10 {
    public static void main(String[] args) {
        WebBank bank1 = new WebBank("web1");
        WebBank bank2 = new WebBank("web2");
        new WebBank("web3");
        // Proper cleanup: log out of bank1 before going home:
        bank1.logOut();
        // Forget to logout of bank2 and unnamed new bank
        // Attempts to finalize any missed banks:
        System.out.println("Try 1: ");
        System.runFinalization();
        System.out.println("Try 2: ");
        Runtime.getRuntime().runFinalization(); // 等价于 System.runFinalization();
        System.out.println("Try 3: ");
        System.gc();
        System.out.println("Try 4: ");
        // using deprecated since 1.1 method:
        System.runFinalizersOnExit(true);
        
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713204536.png)

这样，web1，web2，web3 的 finalize  方法就都一定会被执行了。

**练习 12：编写名为Tank的类，此类的状态可以是“满的”或“空的”。其终结条件是：对象被清理时必须处于空状态。 请编写finalize（）以检验终结条件是否成立，在 main（）中测试 Tank 可能发生的几种使用方式**

```java
class Tank {
    static int counter = 0;
    int id = ++ counter; 

    int howFull = 0;

    Tank() {
        this(0);
    }

    Tank(int fullness) {
        howFull = fullness;
    }

    void sayHowFull() {
        if (howFull == 0)
            System.out.println("Tank " + this.id + " is empty");
        else
            System.out.println("Tank " + this.id + " filling status = " + howFull);
    }

    void empty() {
        howFull = 0;
    }

    protected void finalize() {
        if (howFull != 0)
            System.out.println("Tank " + this.id + " not empty");
        else {
            System.out.println("Tank " + this.id + " cleaned up Ok");
        }
        // Normally, you'll also do this:
        // super.finalize(); // Call the base-class version
    }
}

public class ex12 {
    public static void main(String[] args) {
        Tank tank1 = new Tank(); // new Tank(0) id = 1
        Tank tank2 = new Tank(3); // id = 2
        Tank tank3 = new Tank(5); // id =3
        // Proper cleanup: empty tank before going home
        tank2.empty();
        // Drop the reference, forget to cleanup:
        new Tank(6); // id = 4
        System.out.println("Check tanks:");
        System.out.println("tank1: ");
        tank1.sayHowFull();
        System.out.println("tank2: ");
        tank2.sayHowFull();
        System.out.println("tank3: ");
        tank3.sayHowFull();
        System.out.println("first forced gc():");
        System.gc();
        // Force finalization on exit but using method
        // deprecated since JDK 1.1:
        System.out.println("try deprecated runFinalizersOnExit(true):");
        System.runFinalization();
        System.out.println("last forced gc():");
        System.gc();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200713210806.png)

只执行了 Tank 4 的 finalize 方法。



## Access Control 访问权限控制



## Reusing Classes 复用类

**练习 4：证明基类构造器总是会在子类构造器之前被调用。**

```java
class A {
    A() {
        System.out.println("A()");
    }
}

class B extends A {
    B() {
        System.out.println("B()");
    }
}

class C extends B {
    C() {
        System.out.println("C()");
    }
}

class D extends C {
    D() {
        System.out.println("D()");
    }

    public static D makeD() {
        return new D();
    }

    public static void main(String[] args) {
        D d = new D();  // 先调用基类构造 A B C ，再调用自身构造函数 D
        D d2 = makeD(); 
    }
}

public class ex4 extends D {
    ex4() {
        System.out.println("ex4()");
    }

    public static void main(String[] args) {
        ex4 e = new ex4(); // 先调用基类构造 A B C D，再调用自身构造函数 ex4
        // test D:
        D.main(args);
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715171001.png)

**练习 5：创建两个带有默认构造器（空参数列表）的类 A 和类 B。从 A 中继承产生一个名为 C 的子类，并在 C 内创建一个 B 类的成员。不要给 C 编写构造器。创建一个 C 类的对象并观察其结果。**

```java
class A {
    A() {
        System.out.println("A()");
    }
}

class B extends A {
    B() {
        System.out.println("B()");
    }
}

class C extends A{
    B b = new B();
}
public class ex5 {
    public static void main(String[] args) {
        C c = new C(); 
        // 由于 C 继承 A，所以先调用 A 的构造函数；
        // 又由于 C 中函数体构造了 B 的对象，B 是 A 的子类，所以先调用 A构造，再调用 B 构造
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715171921.png)

**练习 7：修改练习5，使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有初始化。**

```java
class A {
    A(char c, int i) {
        System.out.println("A(" + c + "," + i + ")");
    }
}

class B extends A {
    B(String s, float f) {
        super('c',6);
        System.out.println("B(" + s + "," + f + ")");
    }
}

class C extends A{
    private char c;
    private int i;
    C(char a, int j){
        super(a,j);
        c = a;
        i = j;
    }
    B b = new B("hello",1f);  // will then construct another A and then a B
}
public class ex7 {
    public static void main(String[] args) {
        C c = new C('b',1); 
        
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715173010.png)

**练习 9：创建一个Root类，令其含有名为Component1、Component 2、Component3的类的各一个实例。从Root中派生一个类Stem，也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器**

```java
class Component1 {
    Component1() {
        System.out.println("Component1()");
    }
}

class Component2 {
    Component2() {
        System.out.println("Component2()");
    }
}

class Component3 {
    Component3() {
        System.out.println("Component3()");
    }
}

class Root {
    Component1 c1root;
    Component2 c2root;
    Component3 c3root;

    Root() {
        System.out.println("Root()");
    }
}

class Stem extends Root {
    Component1 c1stem;
    Component2 c2stem;
    Component3 c3stem;

    Stem() {
        System.out.println("Stem()");
    }
    
}
public class ex10 {
    public static void main(String[] args) {
        Stem s = new Stem();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715173716.png)

**练习 13: 创建一个类，它应带有一个被重载了三次的方法。继承产生一个新类，并添加一个该方法的新的重载定义，展示这四个方法在导出类中都是可以使用的。**

```java
class ThreeWay {
	void number(byte b) { 
        System.out.println(b); 
    }
	void number(short s) { 
        System.out.println(s); 
    }
	void number(int i) { 
        System.out.println(i); 
    }
}

class Overload extends ThreeWay {
	void number(float f) { 
        System.out.println(f); 
    }
}

public class ex13{
    public static void main(String[] args) {
		Overload ov = new Overload();
		ov.number((byte)0);
		ov.number((short)1);
		ov.number(2);
		ov.number(3.0f);
	}
}
```

**练习 16：创建一个名为Amphibian的类，由此继承产生一个成为Frog的类，在基类中设置适当的方法，在main（）中，创建一个 Frog <u>向上转型</u>至 Amphibian， 然后说明所有方法都可工作。**

```java
class Amphibian{
     public void moveInWater() {
         System.out.println("moveInWater");
     }
     public void moveInLand() {
         System.out.println("moveInLand");
     }
}
class Frog extends Amphibian{

}

public class ex16 {
    public static void main(String[] args) {
        Amphibian amphibian = new Frog();
        amphibian.moveInWater();
        amphibian.moveInLand();
    }
}
```

**练习 17：修改练习 16，使Frog覆盖基类中方法的定义。请留心main中都发生了什么**

```java
package Thinking_in_Java.ReusingClass;

class Amphibian {
    public void moveInWater() {
        System.out.println("moveInWater");
    }

    public void moveInLand() {
        System.out.println("moveInLand");
    }
}

class Frog extends Amphibian {
    public void moveInWater() {
        System.out.println("Frog.moveInWater");
    }

    public void moveInLand() {
         System.out.println("Frog.moveInLand");
    }
}

public class ex17 {
    public static void main(String[] args) {
        Amphibian amphibian = new Frog();
        amphibian.moveInWater();
        amphibian.moveInLand();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715174801.png)

**练习 18：创建一个含有 static final 域和 final 域的类，说明二者间的区别。**

```java
import java.util.Random;

class Test {
    Test() {
        System.out.println("Test()");
    }
}

class Difference {
    private String name;

    public Difference(String s) {
        name = s;
    }

    static final Test sft = new Test(); // constant reference address 只会被执行一次
    private final Test ft = new Test(); // 每次初始化都执行，但是不能被改变
    static final String SFS = "static final"; // class constant
    private final String fs = "final";
    private static Random rand = new Random();
    static final int SFI = rand.nextInt(); // class constant
    private final int fi = rand.nextInt();

    public String toString() {
        return (name + ": " + sft + ", " + ft + ", " + SFS + ", " + fs + ", " + SFI + ", " + fi);
    }

}
public class ex18 {
    public static void main(String[] args) {
        System.out.println("new Difference(\"d1\")");
        Difference d1 = new Difference("d1");
        System.out.println("new Difference(\"d2\")");
        Difference d2 = new Difference("d2");
        System.out.println("new Difference(\"d3\")");
        Difference d3 = new Difference("d3");

        System.out.println(d1);
        System.out.println(d2);
        System.out.println(d3);
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715175553.png)

**练习 19 ： 创建一个含有指向某对象的空白final引用类。在所有构造器内部都执行空白final的初始化操作。说明Java确保final在使用前必须初始化，且一旦被初始化即无法改变**

```java
package Thinking_in_Java.ReusingClass;

class Poppet {
    private int i;

    Poppet(int k) {
        i = k;
    }

    public String toString() {
        return ("Poppet " + i);
    }
}

class BlankFinalEx {
    private final Poppet p; // Blank final reference
    // Blank finals MUST be initialized in the constructor:

    public BlankFinalEx() {
        p = new Poppet(1); // Initialize blank final reference
    }

    public BlankFinalEx(int x) {
        p = new Poppet(x); // Initialize blank final reference
    }

    
}
public class ex19 {
    public static void main(String[] args) {
        BlankFinalEx b1 = new BlankFinalEx();
        BlankFinalEx b2 = new BlankFinalEx(47);
        // b1.p = new Poppet(2); // Errors: cannot assign values to final variables p
        // b2.p = new Poppet(3);
        System.out.println("b1.p: " + b1.p);
        System.out.println("b2.p: " + b2.p);
    }
}
```

**练习 21：创建一个包含 final 方法的类。由此继承产生一个类并尝试覆盖该方法（无法覆盖）**

```java
class WithFinal {
    final void f() {
        System.out.println("WithFinal.f()");
    }

    void g() {
        System.out.println("WithFinal.g()");
    }

    final void h() {
        System.out.println("WitFinal.h()");
    }
}

class OverrideFinal extends WithFinal {
    // attempt to override:
    // public final void f() { System.out.println("OverrideFinal.f()"); } // no can do

    @Override
    public void g() {
        System.out.println("OverrideFinal.g()");
    } // OK, not final

    // final void h(); { print("OVerrideFinal.h()"); } // cannot override final
}

public class ex21 {
    public static void main(String[] args) {
        OverrideFinal of = new OverrideFinal();
        of.f();
        of.g();
        of.h();
        // Upcast 向上转型:
        WithFinal wf = of;
        wf.f();
        wf.g();
        wf.h();
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200715180819.png)

![](https://gitee.com/veal98/images/raw/master/img/20200715180952.png)

**练习 22： 创建一个final类并试着继承它（无法继承）**

![](https://gitee.com/veal98/images/raw/master/img/20200715181222.png)

## Polymorphism 多态

**练习 1：创建一个 Cycle 类，它具有子类 Unicycle，Bicycle 和 TriCycle。演示每一个类型的实例都可以经由ride（）向上转型为 Cycle。**

```java
class Cycle{
    private String name = "Cycle";

    public static void travel(Cycle c) {
        System.out.println("Cycle.ride() " + c);
    }

    public String toString() {
        return this.name;
    }
}

class Unicycle extends Cycle {
    private String name = "Unicycle";

    public String toString() {
        return this.name;
    }
}

class Bicycle extends Cycle {
    private String name = "Bicycle";

    public String toString() {
        return this.name;
    }

}

class Tricycle extends Cycle {
    private String name = "Tricycle";

    public String toString() {
        return this.name;
    }
}

public class ex1 {
    public static void ride(Cycle c){
        c.travel(c);
    }
    public static void main(String[] args){
        Cycle u = new Unicycle();
        Cycle b = new Bicycle();
        Cycle t = new Tricycle();
        ride(u);
        ride(b);
        ride(t);
    }
}
```

**练习 2： 按照下图创建继承关系并为子类的方法添加@Override注解。**

<img src="https://gitee.com/veal98/images/raw/master/img/20200717142442.png" style="zoom:80%;" />

```java
class Shape{
    public void draw() {}
	public void erase() {}
}

class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Circle.draw()");
    }
    @Override
    public void erase() {
        System.out.println("Circle.erase()");
    }
}

class Square extends Shape {
    @Override 
    public void draw() { 
        System.out.println("Square.draw()"); 
    }
    @Override 
    public void erase() { 
        System.out.println("Square.erase()"); 
    }
 }

class Triangle extends Shape {
    @Override 
    public void draw() { 
        System.out.println("Triangle.draw()"); 
    }
    @Override 
    public void erase() { 
        System.out.println("Triangle.erase()"); 
    }
}


public class ex2 {

    public static void main(String[] args) {
        Shape[] s = {new Circle(), new Square(), new Triangle()};
        // Make polymorphic method calls:
        for(Shape shp : s)
            shp.draw();
    }
}
```

> 💡 加不加 `@Override` 注解的效果都是一样的

**练习 10: 创建一个包含两个方法的基类。在第一个方法中可以调用第二个方法。然后产生一个继承自该基类的导出类，且覆盖基类中的第二个方法。为该导出类创建一个对象，将他向上转型到基类并调用第一个方法，解释发生的情况。**

```java
class  A{
    public void m1(){
        System.out.println("Inside m1, calling m2");
        m2();
    }
    public void m2(){
        System.out.println("Inside A.m2");
    }
}

class B extends A{
    public void m2(){
        System.out.println("Inside B.m2");
    }
}

public class ex10 {
    public static void main(String[] args){
        A b = new B();
        b.m1();

        A a = new A();
        a.m1(); 
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200717144449.png)



## 📚 References

- 《Java 编程思想 - 第四版 - 中文翻译版》

- [Thinking in Java 4th Edition (Bruce Eckel) 课后习题答案](http://greggordon.org/java/tij4/solutions.htm)
- [Java 编程思想第四版练习](https://blog.csdn.net/lelouch_j_zs/category_7270086.html)