# 🔍 Java 基础知识部分面试指南

---

## 前言

本文参考众多资料，并非仅仅是面试题的答案拼凑，也并非从 0 开始，**旨在以面试题带动整个知识体系的复习巩固**，查缺补漏，摆脱目前会而不精的困境 ⛽

## 👉  Java 的基本程序设计结构

### 1. Java 跨平台原理

<img src="https://gitee.com/veal98/images/raw/master/img/20200913160633.png" style="zoom: 45%;" />

🔹 **C/C++ 语言都直接编译成针对特定平台机器码**。如果要跨平台，需要使用相应的编译器重新编译。

🔸 **Java 源程序（`.java`）要先编译成与平台无关的字节码文件(`.class`)，然后字节码文件再经过 JVM 解释成机器码运行。**<u>字节码文件不面向任何具体平台，只面向虚拟机。</u>

Java 虚拟机是可运行 Java 字节码文件的虚拟计算机。<u>不同平台的虚拟机是不同的，但它们都提供了相同的接口。</u>

Java 语言具有**一次编译，到处运行**的特点。就是说编译后的 `.class` 可以跨平台运行，前提是该平台具有相应的Java 虚拟机。

![](https://gitee.com/veal98/images/raw/master/img/20200913161319.png)

🚩 **Java 的跨平台原理决定了其性能没有 C/C++ 高**

### 2. Java 的安全性

🔸 **语言层次的安全性**主要体现在：

- <u>Java 取消了强大但又危险的指针，而代之以引用</u>：由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。

- <u>垃圾回收机制</u>：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。

- <u>异常处理机制</u>：Java异常机制主要依赖于 `try`、`catch`、`finally`、`throw`、`throws` 五个关键字。

- <u>强制类型转换</u>：只有在满足强制转换规则的情况下才能强转成功。

🔸 **底层的安全性**可以从以下方面来说明：

- Java 在<u>字节码的传输过程中使用了公开密钥加密机制 (PKC)</u>。

- <u>在运行环境提供了四级安全性保障机制</u>：

  字节码校验器 - 类装载器 - 运行时内存布局 - 文件访问限制

### 3. Java 三大版本

Java 平台包括三个版本：

- Standard Edition **(标准版) J2SE** 包含那些构成 Java 语言核心的类。

  比如：数据库连接、接口定义、输入/输出、网络编程

- Enterprise Edition **(企业版) J2EE** 包含 J2SE 中的类，并且还包含用于开发企业级应用的类。

  比如 servlet、JSP、XML、事务控制

- Micro Edition **(微缩版) J2ME** 包含J2SE中一部分类，用于消费类电子产品的软件开发。

  比如：呼机、智能卡、手机、PDA、机顶盒

他们的范围是：J2SE 包含于J2EE中，J2ME 包含了 J2SE 的核心类，但新添加了一些专有类

### 4. 什么是  JVM、JDK、JRE

🔸 **JVM **：JVM 是 `Java Virtual Machine`（Java虚拟机）的缩写，它是整个 Java 实现跨平台的最核心的部分，所有的Java 程序会首先被编译为 `.class` 的类文件，这种类文件可以在虚拟机上执行，也就是说 <u>`.class `并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行</u>。

JVM是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 <u>JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法</u>，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM 的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（`.class`文件）。

🔸 **JRE**：JRE 是 `Java runtime environment`（Java 运行环境）的缩写。光有 JVM 还不能让 `.class `文件执行，因为**在解释 `.class `的时候 JVM 需要调用解释所需要的类库 `lib`**。在 JDK 的安装目录里你可以找到 `jre` 目录，里面有两个文件夹 `bin` 和 `lib` ：

<img src="https://gitee.com/veal98/images/raw/master/img/20200913163721.png" style="zoom:80%;" />

在这里**可以认为 `bin` 里的就是 JVM**，`lib` 中则是 JVM 工作所需要的类库，而 JVM 和 `lib` 和起来就称为 jre。所以，在你写完 Java 程序编译成` .class`之后，你可以把这个`.class`文件和 jre 一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre 里有运行 `.class` 的 `java.exe`）。

JRE 是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE 就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成`.exe`可执行文件……），<u>JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</u> 

🔸 **JDK**：JDK是 `Java development kit`（java开发工具包）的缩写。每个学 Java 的人都会先在机器上装一个 JDK，让我们看一下 JDK 的安装目录：

<img src="https://gitee.com/veal98/images/raw/master/img/20200913163601.png" style="zoom:80%;" />

在目录下面有六个文件夹、一个 src 类库源码压缩包、和其他几个声明文件。其中，真正在运行Java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，**JDK 包含JRE，而 JRE 包含 JVM**。

- `bin`: 最主要的是编译器 (javac.exe)

- `include`: java和JVM交互用的头文件

- `lib`：类库   

- `jre`: java 运行环境 

🚨 注意：**这里的 bin、lib 文件夹和 jre 里的 bin、lib 是不同的**。

总的来说 JDK 是用于 Java 程序的开发, 而 jre 则是只能运行 `.class `而没有编译的功能。eclipse、idea 等其他IDE有自己的编译器而不是用 JDK bin 目录中自带的，所以在安装时你会发现他们只要求你选 jre 路径就 ok 了。

⭐ **JDK,JRE,JVM三者关系概括如下：**

**JDK 是 JAVA 程序开发时用的开发工具包，其内部也有运行环境  JRE** 。JRE 是 JAVA 程序运行时需要的运行环境，就是说**如果你光是运行 JAVA 程序而不是去搞开发的话，只安装 JRE 就可以了**。**JDK、JRE 内部都包含 JAVA 虚拟机 JVM**，JAVA 虚拟机内部包含许多应用程序的类的解释器和类加载器等等。

### 5. Java 三种注释类型

- **单行注释**，采用“`//`”方式.只能注释一行代码。

- **多行注释**，采用“`/*...*/`”方式，可注释多行代码，其中不允许出现嵌套。如：

  ```java
  /*System.out.println("a");
  System.out.println("b");
  System.out.println("c");*/
  ```

- **文档注释**，采用“`/**...*/`”方式。如：

  ```java
  /**
   * 子类 Dog
   * @author Administrator
   */
  public class Dog extends Animal{}
  ```

### 6. 8 种基本数据类型

<img src="https://gitee.com/veal98/images/raw/master/img/20200913165019.png" style="zoom: 50%;" />

### 7. i++ 和 ++i 的异同之处

**共同点：**

- `i++` 和 `++i` 都是变量自增 1，都等价于` i=i+1`

- 如果 `i++`,`++i` 是一条单独的语句，两者没有任何区别

- `i++` 和`++i`的使用仅仅针对变量。 `5++`和`++5`会报错，因为 5 不是变量。

**不同点：**

如果 `i++`,`++i` 不是一条单独的语句，他们就有区别 

- **`i++` ：先运算后增1**。如：

  ```java
  int x = 5;
  int y = x++;
  System.out.println("x="+x+", y="+y); // x=6, y=5
  ```

- **`++i` ： 先增1后运算**。如：

  ```java
  int x = 5;
  int y = ++x;
  System.out.println("x="+x+", y="+y); // x=6, y=6
  ```

### 8. & (| ) 和 && (||) 的区别和联系

🔹 **`&` 和 `&&` 的联系(共同点)：**

`&` 和 `&&` 都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。

- 操作数1 `&` 操作数2，操作数1 `&&` 操作数2，

- 表达式1 `&` 表达式2，表达式1 `&&` 表达式2，

当上述的 操作数/表达式结果 是 `boolean `类型变量时，`&` 和 `&&` 都可以用作逻辑与运算符。

表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为 `true `时，整个运算结果才为 `true`，否则，只要有一方为 `false`，结果都为 `false`。

🔹 **`&` 和 `&&` 的区别(不同点)：**

对于 `&`：无论任何情况，`&` 两边的操作数或表达式都会参与计算。`&` 还可以用作位运算符。当 `&` 两边 操作数/表达式的结果 不是 `boolean` 类型时，`&` 用于按位与运算符的操作。

对于 `&&`：当 `&&` 左边的 操作数/表达式结果 为 `false  `时，`&&` 右边的操作数或表达式将不参与计算，此时最终结果都为 `false`（短路特性）。

### 9. 用最有效率的方法计算 2 乘以 8

**使用位运算来实现效率最高**。

<u>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</u>。对于位运算符“`<<`”, 是将一个数左移 n 位，就相当于乘以了2的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可，位运算 cpu 直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是 `2 << 3`

### 10. 基本数据类型的类型转换规则

基本类型转换分为自动转换和强制转换。

- 🔘 **自动转换**规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说<u>低级自动向高级转换</u>。<u>这儿的容量指的不是字节数，而是指类型表述的范围。</u>

  ![](https://gitee.com/veal98/images/raw/master/img/20200616211518.png)

  **在图 3-1 中有 6 个实心箭头，表示无信息丢失的转换；有 3 个虚箭头， 表示可能有精度损失的转换**。 

  例如，123 456 789 是一个大整数 int， 它所包含的位数比 float 类型所能够表达的 位数多。 当将这个整型数值转换为 float 类型时， 将会得到同样大小的结果，但却失去了一定的精度。

  ```java
  public static void main(String[] args) {
          int n = 123456789;
          float f = n;
          System.out.println(f); // 1.23456792E8
      }
  ```

- 🔘 **强制类型转换**规则：<u>高级变为低级需要强制转换。</u>

  - 赋值运算符 “=” 右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。

  - 赋值运算符 “=” 两侧的转换，若左边级别 > 右边级别，会自动转换；若左边级别 == 右边级别，不用转换；**若左边级别 < 右边级别，需强制转换**。

  - 可以将整型常量直接赋值给 `byte`, `short`, `char` 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。

  强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例如：

  ```java
  double x = 9.997
  int nx = (int) x; // nx = 9
  ```

  这样， 变量 nx 的值为 9。<u>强制类型转换通过截断小数部分将浮点值转换为整型</u>。

### 11. if 多分支语句和 switch 多分支语句的异同之处

- 相同之处：都是分支语句，多超过一种的情况进行判断处理。

- 不同之处：

  **`switch` 更适合用于多分支情况**，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 语句），不加判断地执行下去 ; 

  而 **`if—else if---else` 主要适用于分支较少的分支结构**，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。**`switch` 为等值判断（不允许比如 `>=`, `<=`）**，而 if 没有限制。

### 12. while 和 do-while 循环的区别

`while `先判断后执行，如果第一次判断为 `false`, 循环体一次都不执行

`do while` 先执行后判断，最少执行1次。

<u>如果 while 循环第一次判断为 `true `, 则两种循环没有区别。</u>

### 13. break 和 continue 的作用

💡 `break `和 `continue `本身**都只能中断最内层的循环**

🔸 `break`:  立即结束当前循环并退出当前循环体。(`break` 还可以退出 `switch` 语句)

🔸 `continue`: 循环体中后续的语句不执行，结束当前循环，<u>将控制转移到最内层循环的首部，进行下一次循环</u>。

```java
Scanner in = new Scanner(System.in);
while (sum < goal ){
    System.out.print("Enter a number: ")；
	n = in.nextlntO；
	if (n < 0) 
        continue;
	sum += n; // not executed if n < 0
}
```

如果 n < 0, 则 `continue`语句越过了当前循环体的剩余部分， 立刻跳到循环首部。

<u>如果将 `continue` 语句用于 `for `循环中， 就可以跳到 `for `循环的“ 更新” 部分</u>。例如， 下面这个循环：

```java
for (count = 1; count <= 100; count++){
	System.out.print("Enter a number, -1 to quit: ");
	n = in.nextlntO；
	if (n < 0) 
		continue;
	sum += n; // not executed if n < 0
}
```

**如果 n < 0, 则 `continue `语句跳到 `count++` 语句**。

## 👉  Java 关键字

### 1. this

<img src="https://gitee.com/veal98/images/raw/master/img/20200914215346.png" style="zoom: 67%;" />

🔸 **① 在对象内部指代自身的引用**

 `this ` 是对象内部指代自身的引用, 同时也用于解决成员变量和局部变量同名问题。

```java
class Test{
    ......
    public void setSex(String sex) {
    	this.sex = sex;
	}
    ......
}

———————————————————————————————————

test.setSex("female");
```

`setSex `方法有两个参数：

- <u>隐式 implict 参数</u>：出现在方法名前的 `test `类对象。

  👉 在每一个方法中， 关键字 `this` 表示隐式参数。

- <u>显式 explicit 参数</u>：位于方法名后面括号中的参数 `sex`

🔸 **② 在构造函数中调用另一个构造函数**

<u>如果构造函数的第一个语句形如 `this(...)`， 这个构造函数将调用同一个类的另一个构造函数</u>。下面是一个典型的例子：

```java
class Test{
    ......
    public Test(String){
        ......
    }
    public Test(int a){
        // 调用 Test(String) 构造函数
        this("test1");
    }
    ......
}

```

尽管可以用 `this `调用一个构造器，但是不能调用两个。此外，**必须将构造函数调用至于最起始处即第一行**，否则编译器会报错。

🚨 总结下 `this `的使用注意事项：

- `this `可以调用成员变量，不能调用局部变量；
- `this `也可以调用成员方法，在普通方法中可以省略 `this`，在构造方法中不允许省略，必须是构造方法的第一条语句。
- 在静态方法当中不允许出现 `this `关键字。

### 2. super

🔸 `super` 代表对当前对象的直接父类对象的引用

- `super` 可以调用直接父类的成员变量、成员方法（注意权限修饰符的影响，比如不能访问 `private `成员）

- `super` 可以调用直接父类的构造函数，且必须是子类构造函数的第一条语句：

  ```java
  public class Manager extends Employee{
      ......
      public Manager(String name, double salary, int year, int month, int day){
          super(name, salary, year, month, day);
          bonus = 0;
      }
      ......
  }
  ```

### 3. final

<img src="https://gitee.com/veal98/images/raw/master/img/20200914215506.png" style="zoom:67%;" />

🔸 **① 常量**：

关键字 `final` 表示这个变量只能被赋值一次。<u>一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写</u>。

- 对于基本类型，`final `使数值不变；

  ```java
  final int x = 1;
  // x = 2;  // cannot assign value to final variable 'x'
  ```

- 对于引用类型，`final `使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

  ```java
  final A y = new A();
  y.a = 1;
  ```

🔸 **② 常方法**：

<u>声明方法不能被子类重写。</u>

`private `方法隐式地被指定为 `final`，如果在子类中定义的方法和基类中的一个 `private `方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

🔸 **③ 常类**：

<u>声明类不允许被继承。</u>

### 4. static

<img src="https://gitee.com/veal98/images/raw/master/img/20200914221154.png" style="zoom:67%;" />

🔸 **① 静态域 / 静态字段**：

<u>如果将域定义为 `static`, 每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。</u>

例如，这里给 `Test `类添加一个实例域 `id` 和一个静态域 `nextld`:

```java
class Test{
	private static int nextId = 1;
	private int id;
	...
}
```

每一个 `Test `对象都有一个自己的 `id `域， 但<u>这个类的所有实例将共享一个 `nextId `域</u>。换句话说， 如果有 1000 个 `Test `类的对象， 则有 `1000 `个实例域 `id`。但是， 只有一 个静态域 `nextId`。即使没有一个 `Test `对象， 静态域 `nextId `也存在，<u>它属于类，而不属于任何独立的对象</u>。

<u>`static `初始化只有在第一次创建 `Test `对象或者调用  `Test.nextId` 的时候才会调用，在那之后，静态域不会重新初始化。初始化的顺序是首先 `static`，再是其他非 `static `对象。</u>

<u>静态域可直接用类名进行调用</u>：

```java
Test.nextId ++;
```

🔸 **② 静态常量 `static final`**

静态变量使用得比较少，但静态常量却使用得比较多。例如， 在 `Math `类中定义了一个 静态常量：

```java
public class Math{
	public static final double PI = 3.14159265358979323846;
	...
}
```

在程序中，可以采用 `Math.PI` 的形式获得这个常量。无法更改且只初始化一次。

🔸 **③ 静态方法**

静态方法是一种不能向对象实施操作的方法。<u>可以认为静态方法是没有 this 参数（隐式参数）的方法</u>。

<u>静态方法不能访问非静态实例域，也不能调用非静态方法，因为它不能操作对象（非静态方法有可能对实例域进行修改）。但是，静态方法可以（只能）访问自身类中的静态域和静态方法</u>：

```java
class Test{
	private static int nextId = 1;
	private int id;
	......
        
    public static int getNextId{
        return nextId; // return static field
    }
    
    ......
}

```

<u>可以在没有创建任何对象的前提下，仅仅通过类本身来调用这个方法</u>：

```java
int n = Test.getNextId();
```

> 📜 **可以使用对象调用静态方法**。例如， 如果 `test `是一个 `Test` 对象， 可以用 `test.getNextId( )` 代替 `Test.getNextId( ) `。**不过，这种方式很容易造成混淆**，其原因是 `getNextId` 方法计算的结果与 `test `毫无关系。**我们建议使用类名， 而不是对象来调用静态方法**。

在下面两种情况下使用静态方法： 

- 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：`Math.pow`) 
- 一个方法只需要访问类的静态域（例如：`Test.getNextId`）

`main `方法也是一个静态方法。`main `方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 `main `方法将执行并创建程序所需要的对象。

<u>每一个类可以有一个 `main `方法。这是一个常用于对类进行单元测试的技巧</u>。例如， 可以在 `Test `类中添加一个 `main `方法：

```java
class Test {
    private int birthday;
    private  String sex;

    // 构造函数 + Getter And Setter

    public boolean equals(Test test){
        return sex.equals(test.sex);
    }

    public static void main(String[] args) {
        Test test1 = new Test(18, "male");
        Test test2 = new Test(20, "male");
        System.out.println(test1.equals(test2)); // true
    }
}

public class Demo {
    public static void main(String[] args) {      
    
    }
}
```

如果想要独立地测试 `Test `类， 只需要运行 `java Test` 命令。或者如下操作（VS Code 中）：

<img src="https://gitee.com/veal98/images/raw/master/img/20200618151921.png" style="zoom:80%;" />

🔸 **④ 静态初始化块**

初始化块包括静态初始化块和非静态初始化块

- 静态初始化块: 使用 `static `定义,  <u>只有当类装载到系统时执行一次，之后不再执行。在静态初始化块中仅能初始化 `static `修饰的数据成员</u>。

- 非静态初始化块: <u>在每个对象生成时都会被执行一次, 可以初始化类的实例变量</u>。

<u>代码块执行顺序</u>：

- 主调类的静态代码块

- 对象父类的静态代码块

- 对象的静态代码块

- 对象父类的非静态代码块

- 对象父类的构造函数
- 对象的非静态代码块

- 对象的构造函数

```java
class Root {

    static{
        System.out.println("Root的静态初始化块");
    }

    {
        System.out.println("Root的普通初始化块");
    }

    public Root(){
        System.out.println("Root的无参构造器");
    }
}

class Mid extends Root{
	
    // 静态初始化块
    static{
        System.out.println("Mid的静态初始化块");
    }
	
    // 非静态初始化块
    {
        System.out.println("Mid的普通初始化块");
    }

    public Mid(){
        System.out.println("Mid的无参构造器");
    }

    public Mid (String msg){
        //通过this来调用同一类中重载的构造器
        this();
        System.out.println("Mid的带参构造器，其参数值："+msg);
    }
}

class Leaf extends Mid{

    static{
        System.out.println("Leaf的静态初始化块");
    }

    {
        System.out.println("Leaf的普通初始化块");
    }

    public Leaf(){
        //通过super调用父类中有一个字符串参数的构造器
        super("Java程序设计");
        System.out.println("执行Leaf的构造器");
    }
}
public class Test {

    public static void main(String[] args) {

        new Leaf();
        System.out.println("---------------");
        new Leaf();

    }

}
```

执行结果：

> Root的静态初始化块
>
> Mid的静态初始化块
>
> Leaf的静态初始化块
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> **执行 Leaf 的构造器**
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> 执行Leaf的构造器

🔸 **⑤ 静态内部类**

<u>有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象</u>。为此，可以将内部类声明为 `static`, 以便取消产生的引用。

<u>非静态内部类依赖于外部类的实例，而静态内部类不需要。</u>

```java
public class OuterClass {

    class InnerClass {
    }
    
	// 静态内部类
    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

<u>静态内部类不能访问外部类的非静态的变量和方法。</u>

🔸 **⑥ 静态导入**

`import `语句不仅可以导入类，还增加了导入静态方法和静态域的功能。 例如，如果在源文件的顶部， 添加一条指令：

```java
import static java.lang.System.*; 
```

就可以使用 `System `类的静态方法和静态域，而不必加类名前缀： 

```java
out.println("Goodbye, World!"); // System.out 
exit(0); // System.exit
```

 另外，还可以导入特定的方法或域： 

```java
import static java.lang.System.out;
```

## 👉  对象与类

### 1. 对象和类的关系

**类是对象的抽象，而对象是类的具体实例**。类是抽象的，不占用内存，而对象是具体的，占用存储空间。

比如人类就是一个类，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。

小明就是人的一个具体实例，也就是对象，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。

### 2. 面向过程和面向对象的区别

两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。

- <u>**面向对象 OOP** 就是将问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</u>

  ![](https://gitee.com/veal98/images/raw/master/img/20200914203743.png)

  - 👍 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出<u>低耦合</u>的系统，使系统更加灵活、更加易于维护 

  - 😓 缺点：性能比面向过程低

- **面向过程** 不同于面向对象，<u>面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</u>

  ![](https://gitee.com/veal98/images/raw/master/img/20200914203822.png)

  - 👍 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源

    比如单片机、嵌入式开发、 Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。

  - 😓 缺点：可维护性，复用性，扩展性较低

## 👉  组合与继承

### 1. 方法重载和方法重写（覆盖）的区别

|              | **注解**    | **作用位置** | **具体作用**                                         |
| ------------ | ----------- | ------------ | ---------------------------------------------------- |
| 重载         | `@Overload` | 同一个类中   | 在一个类里面为一种行为提供多种实现方式并提高可读性   |
| 重写（覆盖） | `@Override` | 子类和父类间 | 父类方法无法满足子类的要求，子类通过方法重写满足要求 |

- **重载**：如果多个方法有相同的名字、 不同的参数，便产生了重载。<u>不同的返回值或者不同的形参名称无法构成重载。</u>

- **重写（覆盖）**：当父类方法无法满足子类要求的时候，子类可以覆盖（重写）超类中的方法

  🚨 <u>在覆盖（重写）一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 `public`, 子类方法一定要声明为 `public`。</u>经常会发生这类错误：在声明子类方法的时候， 遗漏了 `public `修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

  ![](https://gitee.com/veal98/images/raw/master/img/20200718211413.png)

## 接口

## 内部类

## 函数式编程

## 异常+断言+日志

## 字符串 String

## 反射

## 动态代理

## 泛型

## 👉  数组

### 1. 数组的特征

在 Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。

数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素

数组中可以存储基本数据类型，可以存储引用数据类型；但是<u>对于一个数组而言，数组的类型是固定的，只能是一个</u>

⭐ 总结来说：**数组是相同类型数据的有序集合**，其实就是一个简单的线性序列，这使得元素访问非常快速。但是代价就是**一旦创建了数组， 就不能再改变它的大小**（尽管可以改变每一个数组元素）。

### 2. 可变参数

在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且**多个参数类型一致**，我们可以对其简化成如下格式：

```java
修饰符 返回值类型 方法名(参数类型... 形参名){  }
```

🚩 **`...` 用在参数上，称之为可变参数，它表明这个方法可以接收任意数量的对象。**

其实这个书写完全等价与

```java
修饰符 返回值类型 方法名(参数类型[] 形参名){  }
```

只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。

**同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递**。其实编译成的 `.class`文件，会将这些元素先封装到一个数组中，再进行传递。这些动作都在编译`.class`文件时，自动完成了。

代码演示：    

```java
public class ChangeArgs {
    public static void main(String[] args) {
        int[] arr = { 1, 4, 62, 431, 2 };
        int sum = getSum(arr);
        System.out.println(sum);
        //  6  7  2  12  2121
        // 求这几个元素和 6  7  2  12  2121
        int sum2 = getSum(6, 7, 2, 12, 2121);
        System.out.println(sum2);
    }

    /*
     * 所有元素的求和的原始写法
     
      public static int getSum(int[] arr){
        int sum = 0;
        for(int a : arr){
            sum += a;
        }
        
        return sum;
      }
    */
    //可变参数写法
    public static int getSum(int... arr) {
        int sum = 0;
        for (int a : arr) {
            sum += a;
        }
        return sum;
    }
}
```

> 🚨 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，**可变参数一定要写在参数列表的末尾位置。**

## 集合（容器）

## 枚举类型 Enum

## 并发（多线程）

## I/O 流

## 📚 References

- [尚学堂 — Java 程序员面试题集](https://www.bjsxt.com/javamianshiti.html#1F)
- [www.javanav.com/](http://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html)
- [关于面向对象和面向过程本质的区别（个人感悟）](https://www.cnblogs.com/pylearner/p/10903266.html)
- [CS-Notes — Github](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%9F%BA%E7%A1%80?id=final)