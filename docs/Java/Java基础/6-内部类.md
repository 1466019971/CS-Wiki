# 🍮 内部类 inner class

---

内部类（inner class) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因有以下三点： 

- 内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。 
- 内部类可以对同一个包中的其他类隐藏起来。 
- **当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷**。

## 1. 使用内部类访问对象状态

```java
public class TalkingClock{
    private int interval:
    private boolean beep;
    
    public TalkingClock(int interval, boolean beep) {}
    public void start(){}
    
    // inner class
    public class TimePrinter implements ActionListener{ 
        public void actionPerformed(ActionEvent event){
			System.out.println("At the tone, the time is " + new Date);
			if (beep) 
                Toolkit.getDefaultToolkit().beep();
		}
    }
}
```

`TimePrinter `类没有实例域或者名为 `beep `的变量，取而代之的是 `beep `引用了创建 `TimePrinter `的 `TalkingClock `对象的域。 这是一种创新的想法。从传统意义上讲，一个方法可以引用调用这个方法的对象数据域。⭐ **内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。**

**内部类的对象总有一个隐式引用， 它指向了创建它的外部类对象**。

![](https://gitee.com/veal98/images/raw/master/img/20200620201802.png)

> 📜 如果 `TimePrinter`  类声明为 `private`。这样一来， 只有 `TalkingClock `的方法才能够构造 `TimePrinter `对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。

## 2. 内部类的特殊语法规则

可以使用 `OuterClass.this` 更清晰的表示外围类的引用，例如：

```java
public class TalkingClock{
    ...
    private boolean beep;
    ...
    public class TimePrinter implements ActionListener{ 
        public void actionPerformed(ActionEvent event){
            System.out.println("At the tone, the time is " + new Date);
            if (TalkingClock.this.beep) 
                Toolkit.getDefaultToolkit().beep();
        }
    }
}
```

使用 `OuterObject.new InnerClass(construction parameters)` 更清晰的编写内部对象的构造函数，例如：

```java
TalkingClock jabberer = new TalkingClock(1000,true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();

// 等同于 ActionListener listener = new TimePrinter();
```

在外围类的作用域之外，可以这样引用内部类： `OuterClass.InnerClass`

> 📜 **内部类中声明的所有静态域都必须是 `final`**。原因很简单。我们希望一个静态域只有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。如果这个域不是 `final `, 它可能就不是唯一的。 
>
> **内部类不能有 `static `方法**。Java 语言规范对这个限制没有做任何解释。也可以允许有静态方法，但只能访问外围类的静态域和方法。显然，Java 设计者认为相对于这种复杂性来说， 它带来的好处有些得不偿失。

## 3. 局部内部类

示例代码如下：`TimePrinter` 这个类只能在 `start `方法中使用

```java
public class TalkingClock{
    private int interval:
    private boolean beep;
    
    public TalkingClock(int interval, boolean beep) {}
    
    public void start(){
        class TimePrinter implements ActionListener{
            public void actionPerformed(ActionEvent event){
                System.out.println("At the tone, the time is " + new Date);
                if (beep) 
                    Toolkit.getDefaultToolkit().beep();
            }
        }

        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }
}
```

**局部类不能用 `public `或 `private `访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。** 

🔺 局部类有一个优势， 即对外部世界可以完全地隐藏起来。 即使 `TalkingClock `类中的其他 代码也不能访问它。除 `start `方法之外， 没有任何方法知道 `TimePrinter `类的存在。

## 4. 由外部方法访问变量

与其他内部类相比较，局部类还有一个优点。**它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过，那些局部变量必须事实上为 `final`**。这说明， 它们一旦赋值就绝不会改变。

下面是一个典型的示例。这里， 将 `TalkingClock `构造器的参数 `interval `和 `beep `移至 `start `方法中：

```java
public class TalkingClock{
    private int interval:
    private final boolean beep;
    
    public TalkingClock(int interval, boolean beep) {}
    
    public void start(int interval, boolean beep){
        class TimePrinter implements ActionListener{
            public void actionPerformed(ActionEvent event){
                System.out.println("At the tone, the time is " + new Date);
                if (beep) 
                    Toolkit.getDefaultToolkit().beep();
            }
        }

        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }
}
```

`TalkingClock `类不再需要存储实例变量 `beep `了，它只是引用 `start `方法中的 `beep `参数变量。

> 📜 **在 JavaSE 8 之前**， 必须把从局部类访问的局部变量声明为 `final`。 例如， `start `方法原本就应当这样声明 ，从而使内部类能够访问 beep 参数：
>
> ```java
> public void start(int interval, final boolean beep)
> ```

💡 有时，`final `限制显得并不太方便。例如，假设想更新在一个封闭作用域内的计数器。这里想要统计一下在排序过程中调用 `compareTo `方法的次数。

```java
int counter = 0;
Date[] dates = new Date[100];
for(int i = 0; i < dates.length; i++){
    datesp[i] = new Date(){
        public int compareTo(Date other){
            counter ++; // Error
            return super.compareTo(other);
        }
    };
}
Arrays.sort(dates);
System.out.println(counter + " comparisons.")
```

由于 `counter `需要更新， 所以不能将 `counter `声明为 `final`。  `Integer `对象是不可变的， 所以也不能用 `Integer `代替它。**补救的方法是使用一个长度为 1 的数组**：

```java
int[] counter = new int[1];
Date[] dates = new Date[100];
for(int i = 0; i < dates.length; i++){
    datesp[i] = new Date(){
        public int compareTo(Date other){
            counter[0] ++; 
            return super.compareTo(other);
        }
    };
}
Arrays.sort(dates);
System.out.println(counter + " comparisons.")
```

## 5. 匿名内部类 anonymous inner class

将局部内部类的使用再深入一步。 **假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class)**。

```java
public void start(int interval, boolean beep){
    ActionListener listener = new ActionListener{
        public void actionPerformed(ActionEvent event){
            System.out.println("At the tone, the time is " + new Date);
            if (beep) 
                Toolkit.getDefaultToolkit().beep();
        }
    };
    Timer t = new Timer(interval, listener);
    t.start();
}
```

它的含义是：创建一个实现 `ActionListener `接口的类的新对象，需要实现的方法 `actionPerformed `定义在括号内。

由于构造器的名字必须与类名相同， 而匿名类没有类名，所以，**匿名类不能有构造器**。 取而代之的是，**将构造器参数传递给超类（superclass) 构造器**。尤其是在内**部类实现接口的时候， 不能有任何构造参数。不仅如此，还要像下面这样提供一组括号**：

![](https://gitee.com/veal98/images/raw/master/img/20200620205642.png)

> 📜 多年来，Java 程序员习惯的做法是用匿名内部类实现事件监听器和其他回调。👍 如今**最好还是使用 lambda 表达式**。例如， 上面给出的 `start `方法用 lambda 表达式来写会简洁得多， 如下所示：
>
> ```java
> public void start(int interval, boolean beep){
>      Timer t = new Timer(interval, event ->{
>          System.out.println("At the tone, the time is " + new Date);
>          if (beep) 
>              Toolkit.getDefaultToolkit().beep();
>      });
>      t.start();
> }
> ```

## 6. 静态内部类

**有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象**。为此，可以将内部类声明为 `static`, 以便取消产生的引用。

💬 下面是一个使用静态内部类的典型例子。考虑一下计算数组中最小值和最大值的问题。 当然， 可以编写两个方法， 一个方法用于计算最小值，另一个方法用于计算最大值。**在调用这两个方法的时候，数组被遍历两次。如果只遍历数组一次， 并能够同时计算出最小值和最大值，那么就可以大大地提高效率了。**

```java
double min = Double.POSITIVE_INFINITY;
double max = Double.NEGATIVE_INFINITY;
for(double v : values){
	if(min > v) min = v;
	if(max < v) max = v;
}
```

然而， 这个方法必须返冋两个数值， 为此， **可以定义一个包含两个值的类 Pair**:

```java
class Pair{
    private double first;
    private double second;
	public Pair(double f, double s){
        first = f;
       	second = s;
    }
    public double getFirtst(){
        return first;
    }
    public double getSecond(){
        return second;
    }
}
```

`minmax `方法可以返回一个 `Pair `类型的对象。

```java
class ArrayAlg{
    public static Pair minmax(double[] values){
        ...
    	return new Pair(min, max);
    }
}
```

这个方法的调用者可以使用 `getFirst `和 `getSecond `方法获得答案： 

```java
Pair p = ArrayAlg.minmax(d); 
System.out.println("min = " + p.getFirst()); 
System.out.println("max = " + p.getSecond());
```

当然， `Pair` 是一个十分大众化的名字。在大型项目中， 除了定义包含一对字符串的 `Pair `类之外， 其他程序员也很可能使用这个名字。这样就会产生名字冲突。解决这个问题的办法 是将 `Pair `定义为 `ArrayAlg `的内部公有类。此后， 通过 `ArrayAlg.Pair` 访问它：

```java
ArrayAlg.Pair p = ArrayAlg.minmax(d);
```

不过，与前面例子中所使用的内部类不同， 在 `Pair `对象中不需要引用任何其他的对象， 为此，可以将这个内部类声明为 `static`:

```java
class ArrayAlg{
	class static Pair{
        private double first;
        private double second;
        public Pair(double f, double s){
            first = f;
            second = s;
        }
        public double getFirtst(){
            return first;
        }
        public double getSecond(){
            return second;
        }
	}
    public static Pair minmax(double[] values){
        ...
    	return new Pair(min, max); 
    }
}
```

当然， 只有内部类可以声明为 `static`。静态内部类的对象除了没有对生成它的外围类对象的引用特权外， 与其他所有内部类完全一样。**在我们列举的示例中， 必须使用静态内部类， 这是由于内部类对象是在静态方法中构造的**： 

```java
public static Pair minmax(double[] values){
    ...
    return new Pair(min, max); 
}
```

 如果没有将 `Pair `类声明为 `static`, 那么编译器将会给出错误报告： <u>没有可用的隐式 `ArrayAlg ` 类型对象初始化内部类对象。</u>

## 7. 内部类标识符 $

每个类都会产生一个 `.class` 文件，里面包含了如何创建该类型的对象的全部信息。内部类也同样如此，内部类的类文件命名：**外围类的名字 + `$` + 内部类的名字**，比如：

```
ArrayAlg$Pair.class
```

如果内部类是匿名的，编译器会简单地产生一个数字作为 其标识符，比如：

```
ArrayAlg$1.class
```

## 📚 References

- 《Java 核心技术 - 卷 1 基础知识 - 第 10 版》
- 《Thinking In Java（Java 编程思想）- 第 4 版》