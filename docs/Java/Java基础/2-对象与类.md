# 🍔 对象与类

---

## 1. 面向对象程序设计 OOP 概述

### ① 类 class

**类（class)** 是构造对象的模板或蓝图。由类构造（construct) 对象的过程称为创建类的**实例 （instance )**.

**封装（encapsulation , 有时称为数据隐藏）** 是与对象有关的一个重要概念。从形式上看， 封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。**对象中的数据称为实例域（ instance field )，也就是我们常说的属性、字段**。操纵数据的过程称为方法（ method ) 。对于每个特定的 类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（ state )。 无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

**封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性的关键**。 

OOP 的另一个原则会让用户自定义 Java 类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上， **在 Java 中， 所有的类都源自于一个“ 神通广大的超类”， 它就是 `Object`**。在下一章中， 读者将可以看到有关 Object 类的详细介绍。 

在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个 类的过程称为**继承（inheritance)**， 有关继承的详细内容请参看下一章。

### ② 对象

要想使用 OOP, —定要清楚对象的三个主要特性： 

- 对象的行为（behavior) — 可以对对象施加哪些操作，或可以对对象施加哪些方法？ 

- 对象的状态（state ) — 当施加那些方法时，对象如何响应？ 

- 对象标识（identity ) — 如何辨别具有相同行为与状态的不同对象？ 

同一个类的所有对象实例， 由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。 此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。**对象状态的改变必须通过调用方法实现 (如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏)。**

### ③ 类之间的关系

在类之间， 最常见的关系有 

- **依赖（`uses-a`）** 

  依赖（ dependence ),  即 “ uses-a” 关系， 是一种最明显的、 最常见的关系。例如，`Order `类使用 `Account `类是因为 `Order `对象需要访问 `Account `对象查看信用状态。但是 `Item `类不依赖于 `Account `类， 这是因为 `Item `对象与客户账户无关。因此， **如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类**。 应该尽可能地将相互依赖的类减至最少。如果类 A 不知道 B 的存在， 它就不会关心 B 的任何改变（这意味着 B 的改变不会导致 A 产生任何 bug )。用软件工程的术语来说，就是 让类之间的耦合度最小。 

- **聚合（`has-a`）** 

  聚合（aggregation ), 即“ has-a ” 关系， 是一种具体且易于理解的关系。例如， 一个 `Order `对象包含一些 `Item `对象。聚合关系意味着类 A 的对象包含类 B 的对象。

- **继承（` is-a`）** 

  继承（ inheritance ), 即“ is-a” 关系， 是一种用于表示特殊与一般关系的。例如，`RushOrder `类由 `Order `类继承而来。在具有特殊性的 `RushOrder `类中包含了一些用于优先处理的特殊方法， 以及一个计算运费的不同方法；而其他的方法， 如添加商品、 生成账单等都是从 `Order `类继承来的。一般而言， 如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会添加一些额外的功能。

## 2. 使用预定义类

在 Java 中， 没有类就无法做任何事情， 我们前面曾经接触过几个类。然而，**并不是所有的类都具有面向对象特征。例如，`Math `类**。在程序中，可以使用 `Math `类的方法， 如 `Math.random`, 并只需要知道方法名和参数（如果有的话，) 而不必了解它的具体实现过程。这正是封装的关键所在，当然所有类都是这样。但遗憾的是，`Math `类只封装了功能，它不需要也不必隐藏数据。由于没有数据，因此也不必担心生成对象以及初始化实例域。

下一节将会给出一个更典型的类 — `Date `类（该类不提倡使用），从中可以看到如何构造对象， 以及如何调用类的方法。

### ① 对象与对象变量

要想使用对象，就必须首先构造对象， 并指定其初始状态。然后，对对象应用方法。

在 Java 程序设计语言中， 使用**构造函数（constructor )** 构造新实例。构造函数是一种特殊的方法， 用来构造并初始化对象。下面看一个例子。 在标准 Java 库中包含一个 `Date `类。它的对象将描述一个时间点。

`Date `类中有一个 `toString` 方法。这个方法将返回日期的字符串描述。

```java
String date = new Date().toString();
```

通常， 希望构造的对象可以多次使用， 因此，需要将对象存放在一个变量中：

```java
Date birthday = new Date();
```

图 4-3 显示了引用新构造的 **对象变量 birthday**：

![](https://gitee.com/veal98/images/raw/master/img/20200618105635.png)

在对象与对象变量之间存在着一个重要的区别。例如， 语句

```java
Date dateline; // deadline doesn't refer to any object
```

定义了一个对象变量 `deadline`, 它可以引用 `Date `类型的对象。但是，一定要认识到： **变量 deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个对象变量上。**下面的语句将产生编译错误。

```java
String s = deadline.toString();
```

**必须首先初始化变量 `deadline`**, 这里有两个选择。

- 可以用新构造的对象初始化这个变量： 

  ```java
  deadline = new Date(); 
  ```

- 也可以让这个变量引用一个已存在的对象： 

  ```java
  deadline = birthday;
  ```
  
  现在，这两个变量引用同一个对象：
  
  ![](https://gitee.com/veal98/images/raw/master/img/20200618110302.png)

一定要认识到： **一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。**

⭐ **在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。`new `操作符的返回值也是一个引用。**下列语句：

```java
Date deadline = new Date();
```

有两个部分。表达式 `new Date()` 构造了一个 `Date `类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 `deadline` 中。

<u>可以显式地将对象变量设置为  `null`，表明这个对象变量目前没有引用任何对象。</u>

```java
deadline = null;
```

<u>如果将一个方法应用于一个值为 `null` 的对象上，那么就会产生运行时错误。</u>

### ② LocalDate 类

在前面的例子中， 已经使用了 Java 标准类库中的 `Date `类。但是，`Date `类所提供的日期处理并没有太大的用途。Java 类库的设计者认为： 像 `December 31, 1999, 23:59:59` 这样的日期表示法只是阳历的固有习惯。这种特定的描述法遵循了世界上大多数地区使用的 Gregorian 阳历表示法。但是， 同一时间点采用中国的农历表示和采用希伯来的阴历表示就很不一样，对于火星历来说就更不可想象了。

类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类： 一个是用来表示时间点的 **`Date` 类**；另一个是用来表示大家熟悉的日历表示法的 **`LocalDate` 类**。(Java SE 8 引入了另外一些类来处理日期和时间的不同方法)

```java
import java.time.LocalDate;
import java.util.Date;

public class Demo {
    public static void main(String[] args){
        System.out.println(new Date()); // Thu Jun 18 11:21:37 GMT+08:00 2020
        System.out.println(LocalDate.now()); // 2020-06-18
    }
}
```

🚨 **不要使用构造函数来构造 `LocalDate `类的对象**。实际上，应当使用静态工厂方法 (factory method) 代表你调用构造函数。下面的表达式会构造一个新对象，表示构造这个对象时的日期。

```java
LocalDate.now()
```

可以提供年、 月和日来构造对应一个特定日期的对象：

```java
LocalDate.of(1999,12,31);
```

当然， 通常都希望将构造的对象保存在一个对象变量中：

```java
LocalDate newYearsEve = LocalDate.of(1999, 12, 31);
```

一旦有了一个 `LocalDate `对象， 可以用方法 `getYear`、 `getMonthValue` 和 `getDayOfMonth` 得到年、月和日：

```java
int year = newYearsEve.getYear(); // 1999
int month = newYearsEve.getMonthValue(); // 12
int day = newYearsEve.getDayOfMonth(); // 31
```

> 📜 实际上，`Date` 类还有 `getDay`、`getMonth `以及 `getYear `等方法， 然而并不推荐使用这些方法。 当类库设计者意识到某个方法不应该存在时， 就把它标记为不鼓励使用。 
>
> 类库设计者意识到应当单独提供类来处理日历，不过在此之前这些方法已经是 `Date `类的一部分了。Java 1.1 中引入较早的一组日历类时，`Date `方法被标为废弃不用。 虽然仍然可以在程序中使用这些方法，不过如果这样做， 编译时会出现警告。 **最好还是不要使用这些废弃不用的方法， 因为将来的某个类库版本很有可能将它们完全删除。**

### ③ set 与 get 方法

```java
LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);
```

这个调用之后 `newYeareEve `会有什么变化？ 它会改为 1000 天之后的日期吗？ 事实上，并没有。**`plusDays` 方法会生成一个新的 `LocalDate `对象，然后把这个新对象赋给 `aThousandDaysLater `变量。原来的对象不做任何改动。** 我们说 `plusDays `方法没有更改调用这个方法的对象。（<u>这类似于 String 类的 `toUpperCase` 方法。在一个字符串上调用 `toUpperCase `时，这个字符串仍保持不变，会返回一个将字符大写的新字符串</u>）

Java 库的一个较早版本曾经有另一个类来处理日历，名为 `GregorianCalendar`。 可以如下 为这个类表示的一个日期增加 1000 天： 

```java
CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31); someDay.add(Calendar.DAY_0F_M0NTH, 1000); 
```

与 `LocalDate.plusDays` 方法不同，`GregorianCalendar.add` 方法是一个**更改器方法 ( mutator method ) 调用这个方法后，`someDay `对象的状态会改变**。

相 反， **只访问对象而不修改对象的方法称为访问器方法**。例如， `LocalDate.getYear` 和 `GregorianCalendar.get` 就是访问器方法。

- 更改器方法 ( mutator method ) ：`set `方法，**原地修改**对象属性
- 访问器方法 ( accessor method )：`get `方法

> 📜 在 C++ 中， 带有 `const `后缀的方法是访问器方法；默认为更改器方法。但是， 在 Java 语言中， 访问器方法与更改器方法在语法上没有明显的区别，

## 3. 用户自定义类

### ① 示例

```java
class Test{
    private int birthday;
    private String sex;

    public Test(){

    }

    public Test(int birthday, String sex){
        this.birthday = birthday;
        this.sex = sex;
    }

    public int getBirthday() {
        return birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setBirthday(int birthday) {
        this.birthday = birthday;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
public class Demo {

    public static void main(String[] args){
        Test test = new Test(18,"male");
        System.out.println(test.getBirthday()); // 18
        System.out.println(test.getSex()); // male
        test.setSex("female");
        System.out.println(test.getSex()); // female
    }
}
```

注意，在这个示例程序中包含两个类：`Test `类和带有 `public `访问修饰符的 `Demo`类。`Demo `类包含了 `main `方法。源文件名是 Demo.java，🚩 因为**文件名必须与 public 类的名字相匹配。在一个源文件中， 只能有一个公有类，但可以有任意数目的非公有类。**

接下来，<u>当编译这段源代码的时候， 编译器将在目录下创建两个类文件：Demo. class 和 Test.class</u>

### ② 构造函数

```java
public Test(int birthday, String sex){
    this.birthday = birthday;
    this.sex = sex;
}
```

可以看到， **构造函数与类同名且没有返回值**。在构造 `Test `类的对象时， 构造函数会运行，以便将实例域初始化为所希望的状态。

构造函数与其他的方法有一个重要的不同。**构造函数总是伴随着 new 操作符的执行被调用， 而不能对一个已经存在的对象调用构造函数来达到重新设置实例域的目的。**

🚩 需要记住：

- 构造函数与类同名 
- 每个类可以有一个以上的构造函数
- 构造函数可以有 0 个、1 个或多个参数 
- 构造函数没有返回值 
- 构造函数总是伴随着 new 操作一起调用

> 📜 Java 构造函数的工作方式与 C++ —样。但是， 要记住所有的 Java 对象都是在堆中构造的， 构造函数总是伴随着 `new `操作符一起使用。**C++ 程序员最易犯的错误就是忘记 `new `操作符**。

### ③ 隐式参数 this 与显式参数

```java
public void setSex(String sex) {
    this.sex = sex;
}
---
test.setSex("female");
```

`setSex `方法有两个参数：

- **隐式 implict 参数**：出现在方法名前的 `test `类对象。

  👉 在每一个方法中， 关键字 `this` 表示隐式参数。

- **显式 explicit 参数**：位于方法名后面括号中的参数 `sex`

> 📜 在 C++ 中， 通常在类的外面定义方法： 
>
> ```cpp
> void Employee::raiseSalary(double byPercent) // C++, not Java { 
> 
> }
> ```
>
>  如果在类的内部定义方法且方法体足够简单， 这个方法将自动地成为内联（inline) 方法 
>
> ```cpp
> class Employee { 
> 	String getName{ 
> 		return name; 
> 	} // inline in C++
> }
> ```
>
> **在 Java 中， 所有的方法都必须在类的内部定义， 但并不表示它们是内联方法。是否将某个方法设置为内联方法是 Java 虚拟机的任务**。即时编译器会监视调用那些简洁、经常被调用、 没有被重载以及可优化的方法。

### ④ 基于类的访问权限

⭐ **一个方法可以访问所属类的所有对象的私有数据**。例如：

```java
 public static void main(String[] args) {
     Test test1 = new Test(18, "male");
     Test test2 = new Test(20, "male");
     System.out.println(test1.equals(test2)); // true
}
```

<u>这个方法访问 `test1 `的私有域， 这点并不会让人奇怪，然而， 它还访问了 `test2 `的私有域。这是合法的， 其原因是 `test2 `是 `Test `类对象， 而 `Test `类的方法可以访问 `Test `类的任何一个对象的私有域。</u>

### ⑤ 私有方法 private

在 Java 中，为了实现一个私有的方法， 只需将关键字 `public `改为 `private` 即可。这样外部的其他类就无法调用。

### ⑥ final 实例域

⭐ 可以将实例域定义为 `final`。 **构建对象时必须初始化这样的域**。也就是说， 必须确保在每一个构造函数执行之后，这个域的值被设置， **并且在后面的操作中， 不能够再对它进行修改**。 

例如，可以将 `Test` 类中的 `age` 域声明为` final`, 因为在对象构建之后，这个值不会再被修改， 即没有 `setAge` 方法。

```java
private final String sex;
```

`final` 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类 中的每个方法都不会改变其对象， 这种类就是不可变的类。例如，`String `类就是一个不可变的类。 **对于可变的类， 使用  `final` 修饰符可能会对读者造成混乱**。例如：

```java
private final StringBuilder sex;
```

在 Test 构造函数中会初始化为：

```java
sex = new StringBuilder();
```

🚩 **`final` 关键字只是表示存储在 `sex` 变量中的对象引用不会再指示其他 `StringBuilder `对象。不过这个对象可以更改**：

```java
public void finalTest{
	sex.append(":a good man")
}
```

## 4. 静态域与静态方法 static

在前面给出的示例程序中，`main `方法都被标记为 `static `修饰符。下面讨论一下这个修饰符的含义。

### ① 静态域

**如果将域定义为 `static`, 每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。**

例如， 假定需要给每一个雇员赋予唯一的标识码。这里给 `Test `类添加一个实例域 `id` 和一个静态域 `nextld`:

```java
class Test{
	private static int nextId = 1;
	private int id;
	...
}
```

⭐ 现在， 每一个 `Test `对象都有一个自己的 `id `域， 但**这个类的所有实例将共享一个 `nextId `域**。换句话说， 如果有 1000 个 `Test `类的对象， 则有 `1000 `个实例域 `id`。但是， 只有一 个静态域 `nextId`。即使没有一个 `Test `对象， 静态域 `nextId `也存在，**它属于类，而不属于任何独立的对象**。

<u>`static `初始化只有在第一次创建 `Test `对象或者调用  `Test.nextId` 的时候才会调用，在那之后，静态域不会重新初始化。初始化的顺序是首先 static，再是其他非 static 对象。</u>

**静态域可直接用类名进行调用**：

```java
Test.nextId ++;
```

### ② 静态常量 static final

静态变量使用得比较少，但静态常量却使用得比较多。例如， 在 `Math `类中定义了一个 静态常量：

```java
public class Math{
	public static final double PI = 3.14159265358979323846;
	...
}
```

在程序中，可以采用 `Math.PI` 的形式获得这个常量。

### ③ 静态方法

静态方法是一种不能向对象实施操作的方法。例如， `Math` 类的 `pow `方法就是一个静态方法。表达式 

```java
Math.pow(3, 2)
```

<u>在运算时，不使用任何 `Math `对象</u>。换句话说，没有隐式的参数。

**可以认为静态方法是没有 this 参数的方法**。

**`Test `类的静态方法不能访问非静态实例域，也不能调用非静态方法**，因为它不能操作对象（非静态方法有可能对实例域进行修改）。但是，静态方法可以访问自身类中的静态域和静态方法：

```java
public statci int getNextId{
	return nextId; // return statci field
}
```

可以通过类名调用这个方法：

```java
int n = Test.getNextId();
```

> 📜 **可以使用对象调用静态方法**。例如， 如果 `test `是一个 `Test` 对象， 可以用 `test.getNextId( )` 代替 `Test.getNextId( ) `。**不过，这种方式很容易造成混淆**，其原因是 `getNextId` 方法计算的结果与 `test `毫无关系。**我们建议使用类名， 而不是对象来调用静态方法**。

在下面两种情况下使用静态方法： 

- 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：`Math.pow`) 
- 一个方法只需要访问类的静态域（例如：`Test.getNextId`）

> 📜 Java 中的静态域与静态方法在功能上与 C++ 相同。但是， 语法书写上却稍有所不同。在 C++ 中， 使用 `::` 操作符访问自身作用域之外的静态域和静态方法， 如 `Math::PI` 

### ④ 工厂方法

静态方法还有另外一种常见的用途。类似 `LocalDate` 和 `NumberFormat` 的类使用**静态工厂方法 (factory method)** 来构造对象。你已经见过工厂方法 `LocalDate.now` 和 `LocalDate.of`。 

`NumberFormat` 类如下使用工厂方法生成不同风格的格式化对象： 

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); 
NumberFormat percentFormatter = NumberFormat.getPercentInstance(); 
double x = 0.1; 
System.out.println(currencyFormatter.format(x)); // prints $O.10 System.out.println(percentFormatter.format(x)); // prints 10% 
```

为什么 `NumberFormat` 类不利用构造函数完成这些操作呢？ 这主要有两个原因： 

- 无法命名构造函数。构造函数的名字必须与类名相同。但是，这里希望将得到的货币实例和百分比实例采用不用的名字。 
- 当使用构造函数时，无法改变所构造的对象类型。而 `Factory` 方法将返回一个 `DecimalFormat` 类对象，这是 `NumberFormat` 的子类

### ⑤ main 方法

`main `方法也是一个静态方法。`main `方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 `main `方法将执行并创建程序所需要的对象。

💡 **每一个类可以有一个 `main `方法。这是一个常用于对类进行单元测试的技巧**。例如， 可以在 `Test `类中添加一个 `main `方法：

```java
class Test {
    private int birthday;
    private  String sex;

    public Test() {

    }

    public Test(int birthday, String sex) {
        this.birthday = birthday;
        this.sex = sex;
    }

    public int getBirthday() {
        return birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setBirthday(int birthday) {
        this.birthday = birthday;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public boolean equals(Test test){
        return sex.equals(test.sex);
    }

    public static void main(String[] args) {
        Test test1 = new Test(18, "male");
        Test test2 = new Test(20, "male");
        System.out.println(test1.equals(test2)); // true
    }
}

public class Demo {
    public static void main(String[] args) {      
    
    }
}
```

如果想要独立地测试 `Test `类， 只需要运行 `java Test` 命令。或者如下操作：

<img src="https://gitee.com/veal98/images/raw/master/img/20200618151921.png" style="zoom:80%;" />

## 5. 方法参数（按值调用）

首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。

- **按值调用 （call by value )** 表示方法接收的是调用者提供的值。
- **按引用调用 （ call by reference )** 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

⭐ **Java 程序设计语言总是采用<u>按值调用</u>。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。**

假定一个方法试图将一个参数值增加至 3 倍：

```java
public static void tripleValue(double x){
	 x *= 3;
}
--------------------------
double percent = 10;
tripleValue(percent);
```

<u>调用这个方法之后，`percent` 的值还是 10</u>。下面看一下具体的执行过程：

- x 被初始化为 `percent ` 值的一个拷贝（也就 是 10 ) 
- x 被乘以 3 后等于 30。 但是 `percent `仍然是 10 
- 这个方法结束之后，参数变量 x 不再使用。

![](https://gitee.com/veal98/images/raw/master/img/20200618152649.png)

👇 方法参数共有两种类型： 

- 基本数据类型（int、bool 等）
- 对象引用

**已经看到，一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了**，可以很容易地利用下面这个方法实现提高雇员薪金的操作：

```java
public static void tripleSalary (Employee x) {
	x.raiseSalary(200);
}
--------------------------
harry = new Emplyee(...);
tipleSalary(harry);
```

具体的执行过程为： 

- x 被初始化为 `harry `值的拷贝，这里是一个对象的引用。 
- `raiseSalary `方法应用于这个对象引用。x 和 `harry `同时引用的那个 `Employee `对象的薪金提高了 200。 
- 方法结束后，参数变量 x 不再使用。当然，对象变量 `harry `继续引用那个薪金增加 200 的对象。

![](https://gitee.com/veal98/images/raw/master/img/20200618153148.png)

📩 下面总结一下 Java 中方法参数的使用情况： 

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 
- 一个方法可以改变一个对象参数的状态。 
- 一个方法不能让对象参数引用一个新的对象。

> 📜 C++ 有值调用和引用调用。 引用参数标有 `&` 符号。 例如， 可以轻松地实现 `void tripleValue(double& x)` 方法或` void swap(Employee& x, Employee& y)` 方法实现修改它们的引用参数的目的。
>
> ```java
> int swap(int &a, int &b){
>         int temp = a;
>         a = b;
>         b = temp;
> }
> ```
>
> 这种在 C++ 中的常见写法在 Java 中是错误的

## 6. 对象构造(初始化)与清除

前面已经学习了编写简单的构造函数，可以定义对象的初始状态。但是，由于对象构造非常重要，所以 Java 提供了多种编写构造函数的机制。下面将详细地介绍这些机制。

### ① 重载

有些类有多个构造函数。例如， 可以如下构造一个空的 `StringBuilder `对象： 

```java
StringBuilder messages = new StringBuilder(); 
```

或者， 可以指定一个初始字符串：

```java
StringBuilder todoList = new StringBuilder("To do:\n"); 
```

这种特征叫做**重载（overloading)** 。**如果多个方法（比如， StringBuilder 构造函数）有相同的名字、 不同的参数，便产生了重载。**编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。<u>如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。这个过程被称为重载解析（overloading resolution)。</u>

📜 Java 允许重载任何方法， 而不只是构造函数方法。因此，要完整地描述一个方法， 需要指出方法名以及参数类型。这叫做**方法的签名（signature)**。例如， String 类有 4 个 称为 `indexOf` 的公有方法。它们的签名是 

- `indexOf(int) `
- `indexOf(int, int) `
- `indexOf(String) `
- `indexOf(String, int)` 

**返回类型和参数名不是方法签名的一部分**。也就是说， 不能有两个函数名相同、 参数类型也相同却返回不同类型值的方法。

❓ **为什么不能以返回值类型来区分重载方法呢**？

比如说有以下两个函数：

```java
void f(){
    ...
}
int  f(){
    ...
}
```

假如我们这样调用方法：

```java
f();
```

显然 Java 无法判断 `f()` 的具体调用方式，所以不能以返回值类型来区分重载方法

### ② 默认域初始化

**如果在构造函数中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、 布尔值为 false、 对象引用为 null。**然而，只有缺少程序设计经验的人才会这样做。确实， 如果不明确地对域进行初始化，就会影响程序代码的可读性。

### ③ 无参构造函数(默认构造函数)

很多类都包含一个无参数的构造函数，**对象由无参数构造函数创建时， 其状态会设置为适当的默认值**。 例如， 以下是 Test 类的无参数构造函数： 

```java
public Test { 
    // sex = "";
    // age = 0; 
} 
```

**如果在编写一个类时没有编写构造函数， 那么系统就会提供一个无参数构造函数**。这个构造函数将所有的实例域设置为默认值。

**如果类中提供了至少一个构造函数， 但是没有提供无参数的构造函数， 则在构造对象时如果没有提供参数就会被视为不合法**。

### ④ 显式域初始化

通过重载类的构造函数方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造函数，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。 可以在类定义中， 直接将一个值赋给任何域。例如：

```java
class Test{
 	private String name = "Jack";
}
```

 在执行构造函数之前，先执行赋值操作。当一个类的所有构造函数都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。

> 📜 <u>在 C++ 中， 不能直接初始化类的实例域</u>。所有的域必须在构造函数中设置。<u>但是，有一个特殊的初始化器列表语法</u>，如下所示： 
>
> ```cpp
> Test::Test(String m，int a): male(m), age(a){} // C++
> ```
>
>  C++ 使用这种特殊的语法来调用域构造函数。在 Java 中没有这种必要， 因为对象没有子对象， 只有指向其他对象的指针。

### ⑤ 调用另一个构造函数

关键字 `this` 引用方法的隐式参数。然而，这个关键字还有另外一个含义。 **如果构造函数的第一个语句形如 `this(...)`， 这个构造函数将调用同一个类的另一个构造函数**。下面是一个典型的例子：

```java
public Test(int a){
	// 调用 Test(String, int) 构造函数
	this("test1:" + s);
}
```

> 📜 在 Java 中， this 引用等价于 C++ 的 this 指针。但是， <u>在 C++ 中， 一个构造函数不能调用另一个构造函数</u> , 必须将抽取出的公共初始化代码编写成一个独立的方法。

### ⑥ 非静态初始化块 initializationblock

前面已经讲过两种初始化数据域的方法： 

- 在构造函数中设置值 
- 在声明中赋值 

实际上，Java 还有第三种机制， 称为**初始化块（initializationblock)**。在一个类的声明中， 可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：

```java
class Employee{
    private static int nextld;
    private int id;
    private String name;
    private double salary;
    // object initialization block
    {
        id = nextld;
        nextld++;
    }
    public Employee(String n, double s)
    salary = s;
    public Employee(){
        name =
        salary = 0
    }
...
}
```

**在这个示例中，无论使用哪个构造函数构造对象，id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造函数的主体部分。**

这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造函数中。

### ⑦ 静态初始化块

**静态初始化块**: 使用 `static `定义,  <u>只有当类装载到系统时执行一次，之后不再执行。在静态初始化块中仅能初始化 `static `修饰的数据成员</u>。

**非静态初始化块**: 在每个对象生成时都会被执行一次, 可以初始化类的实例变量。

⭐ 代码块执行顺序：

- 主调类的静态代码块

- 对象父类的静态代码块

- 对象的静态代码块

- 对象父类的非静态代码块

- 对象父类的构造函数
- 对象的非静态代码块

- 对象的构造函数

```java
package codes;

class Root {

    static{
        System.out.println("Root的静态初始化块");
    }

    {
        System.out.println("Root的普通初始化块");
    }

    public Root(){
        System.out.println("Root的无参构造器");
    }
}

class Mid extends Root{

    static{
        System.out.println("Mid的静态初始化块");
    }

    {
        System.out.println("Mid的普通初始化块");
    }

    public Mid(){
        System.out.println("Mid的无参构造器");
    }

    public Mid (String msg){
        //通过this来调用同一类中重载的构造器
        this();
        System.out.println("Mid的带参构造器，其参数值："+msg);
    }
}

class Leaf extends Mid{

    static{
        System.out.println("Leaf的静态初始化块");
    }

    {
        System.out.println("Leaf的普通初始化块");
    }

    public Leaf(){
        //通过super调用父类中有一个字符串参数的构造器
        super("Java程序设计");
        System.out.println("执行Leaf的构造器");
    }
}
public class Test {

    public static void main(String[] args) {

        new Leaf();
        System.out.println("---------------");
        new Leaf();

    }

}
```

执行结果：

> Root的静态初始化块
>
> Mid的静态初始化块
>
> Leaf的静态初始化块
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> **执行Leaf的构造器**
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> 执行Leaf的构造器

### ⑧ 对象析构与 finalize 方法

有些面向对象的程序设计语言，特别是 C++, 有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中， 最常见的操作是回收分配给对象的存储空 间。**由于 Java 有自动的垃圾回收器，不需要人工回收内存， 所以 Java 不支持析构器。** 

当然，某些对象使用了内存之外的其他资源， 例如，文件或使用了系统资源的另一个对 象的句柄。在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。 **可以为任何一个类添加 `finalize` 方法。当垃圾收集器认为没有指向对象实例的引用时，会在销毁该对象之前调用 finalize() 方法。**该方法最常见的作用是确保释放实例占用的全部资源。 <u>在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为 Java 并不保证定时为对象实例调用该方法，甚至不保证方法会被调用，所以该方法不应该用于正常内存处理。</u>

- `System.gc();`  ：告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的 

- `System.runFinalization();`  ：强制调用已经失去引用的对象的 finalize 方法 

## 7. 包 package

### ① 类的导入

一个类可以使用所属包中的所有类， 以及其他包中的公有类（ public class。) 我们可以 采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。 例如： 

```java
java.time.LocalDate today = java.time.LocalDate.now();
```

这显然很繁琐。更简单且更常用的方式是使用 import 语句。

```java
import java.util.*
```

> 📜 在 C++ 中， 与包机制类似的是命名空间（namespace)。 在 Java 中， package 与 import 语句类似于 C++ 中的 namespace 和 using 指令。

### ② 静态导入

import 语句不仅可以导入类，还增加了导人静态方法和静态域的功能。 例如，如果在源文件的顶部， 添加一条指令：

```java
import static java.lang.System.*; 
```

就可以使用 System 类的静态方法和静态域，而不必加类名前缀： 

```java
out.println("Goodbye, World!"); // System.out 
exit(0); // System.exit
```

 另外，还可以导入特定的方法或域： 

```java
import static java.lang.System.out;
```

### ③ 将类放入包中

要想将一个类放入包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之前。例如，Test.java 开头是这样的： 

```java
package com.smallbeef.program_java;

public class Test { } 
```

**如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包 ( `default package` ) 中。默认包是一个没有名字的包。**

### ④ 包作用域

前面已经接触过访问修饰符 `public `和 `private`。

- 标记为 `public `的部分可以被任意的类使用；

- 标记为 `private `的部分只能被定义它们的类使用。

- **如果没有指定访问修饰符, 这部分（类、方法或变量）可以被同一个包中的所有方法访问。** 

  在 java.awt 包中的 Window 类就是一个典型的示例。`java.awt` 包 是 JDK 提供的部分源代码： 

  ```java
  public class Window extends Container { 
      String warningString; 
  } 
  ```

  请注意，这里的 `wamingString` 变量不是 `private` ! 这 意 味 着 `java.awt` 包中的所有类的方法都可以访问该变量， 并将它设置为任意值。实际上，只有 Window 类的方法访问它，因此应该将它设置为私有变量。

⭐ **下面总结一下访问修饰符**，Java 的类成员访问权限修饰词有四类：`private`，`无`（默认情况下），`protected `和 `public`。其权限控制如下表所示：

![](https://gitee.com/veal98/images/raw/master/img/20200712120116.png)

其中，默认情况下没有任何修饰词，这样的类成员具有“包访问权”，即位于同一个包中的类对其有访问权。🚩 参见下图：`name `被定义为 `private`，只有 `Dog ` 类能访问它，而 `says `字段可以被同一个包的所有类访问。

![](https://gitee.com/veal98/images/raw/master/img/20200712120501.png)

`protected` 为“继承访问权”，即该类的子类对其具有访问权（同时，位于同一个包中的类也对其具有访问权）。

## 8. 文档注释

JDK 包含一个很有用的工具，叫做 `javadoc`, 它可以由源文件生成一个 HTML 文档。

### ① 注释的插入

javadoc 实用程序（utility) 从下面几个特性中抽取信息：

- 包
- 公有类与接口
- 公有的和受保护的构造函数及方法
- 公有的和受保护的域

应该为上面几部分编写注释、 注释应该放置在所描述特性的前面。注释以 `/**`开始，并以 `*/` 结束。每个` /** . . . */ `文档注释在标记之后紧跟着自由格式文本（ free-form text )。标记由 `@` 开始， 如`@author` 或`@param`。自由格式文本的第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。

### ② 类注释

类注释必须放在 import 语句之后，类定义之前。

下面是一个类注释的例子：

![](https://gitee.com/veal98/images/raw/master/img/20200618162542.png)

### ③ 方法注释

每一个方法注释必须放在所描述的方法之前。除了通用标记之外， 还可以使用下面的标记：

- `@param` 变量描述 

  这个标记将对当前方法的 param（参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 `@param` 标记必须放在一起。 

- `@return` 描述 

  这个标记将对当前方法添加 return（返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。 

- `@throws` 类描述 

  这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。

下面是一个方法注释的示例：

![](https://gitee.com/veal98/images/raw/master/img/20200618162730.png)

### ④ 域注释

只需要对公有域（通常指的是静态常量）建立文档。 例如：

![](https://gitee.com/veal98/images/raw/master/img/20200618162755.png)

### ⑤ 通用注释

下面的标记可以用在类文档的注释中：

![](https://gitee.com/veal98/images/raw/master/img/20200618163024.png)

### ⑥ 包与概述注释

可以直接将类、 方法和变量的注释放置在 Java 源文件中， 只要用` /** . . . */ `文档注释界 定就可以了。但是， 要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 

- 1 ) 提供一个以 `package.html` 命名的 HTML 文件。在标记 `<body></body>`的所有文本都会被抽取出来。 
- 2 ) 提供一个以 `package-info.java` 命名的 Java 文件。这个文件必须包含一个初始的以 `/**` 和 `*/` 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。 

还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为 `overview.html` 的文件中，这个文件位于包含所有源文件的父目录中。标记 `<body></body>`之间的所有文本将被抽取出来。当用户从导航栏中选择“ Overview” 时，就会显示出这些注释内容。

### ⑦ 注释的抽取

这里，假设 HTML 文件将被存放在目录 `docDirectory` 下。执行以下步骤：

- 1 ) 切换到包含想要生成文档的源文件目录。 如果有嵌套的包要生成文档， 例如 `com. horstmann.corejava`, 就必须切换到包含子目录 com 的目录（如果存在` overview.html` 文件的 话， 这也是它的所在目录)。

- 2）如果是一个包，应该运行命令: 

  ```powershell
  javadoc -d docDirectory 包名
  ```

   或对于多个包生成文档，运行: 

  ```powershell
  javadoc -d docDirectory 包名1 包名2 . . .
  ```

   如果文件在默认包中， 就应该运行：

  ```powershell
  javadoc -d docDirectory *.java
  ```

## 📚 References

- 《Java 核心技术 - 卷 1 基础知识 - 第 10 版》
- 《Thinking In Java（Java 编程思想）- 第 4 版》