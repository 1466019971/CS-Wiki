# 🍔 对象与类

---

## 1. 面向对象程序设计 OOP 概述

### ① 类 class

**类（class)** 是构造对象的模板或蓝图。由类构造（construct) 对象的过程称为创建类的**实例 （instance )**.

**封装（encapsulation , 有时称为数据隐藏）** 是与对象有关的一个重要概念。从形式上看， 封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。**对象中的数据称为实例域（ instance field )，也就是我们常说的属性、字段**。操纵数据的过程称为方法（ method ) 。对于每个特定的 类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（ state )。 无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

**封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性的关键**。 

OOP 的另一个原则会让用户自定义 Java 类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上， **在 Java 中， 所有的类都源自于一个“ 神通广大的超类”， 它就是 `Object`**。在下一章中， 读者将可以看到有关 Object 类的详细介绍。 

在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个 类的过程称为**继承（inheritance)**， 有关继承的详细内容请参看下一章。

### ② 对象

要想使用 OOP, —定要清楚对象的三个主要特性： 

- 对象的行为（behavior) — 可以对对象施加哪些操作，或可以对对象施加哪些方法？ 

- 对象的状态（state ) — 当施加那些方法时，对象如何响应？ 

- 对象标识（identity ) — 如何辨别具有相同行为与状态的不同对象？ 

同一个类的所有对象实例， 由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。 此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。**对象状态的改变必须通过调用方法实现 (如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏)。**

### ③ 类之间的关系

在类之间， 最常见的关系有 

- **依赖（`uses-a`）** 

  依赖（ dependence ),  即 “ uses-a” 关系， 是一种最明显的、 最常见的关系。例如，`Order `类使用 `Account `类是因为 `Order `对象需要访问 `Account `对象查看信用状态。但是 `Item `类不依赖于 `Account `类， 这是因为 `Item `对象与客户账户无关。因此， **如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类**。 应该尽可能地将相互依赖的类减至最少。如果类 A 不知道 B 的存在， 它就不会关心 B 的任何改变（这意味着 B 的改变不会导致 A 产生任何 bug )。用软件工程的术语来说，就是 让类之间的耦合度最小。 

- **聚合（`has-a`）** 

  聚合（aggregation ), 即“ has-a ” 关系， 是一种具体且易于理解的关系。例如， 一个 `Order `对象包含一些 `Item `对象。聚合关系意味着类 A 的对象包含类 B 的对象。

- **继承（` is-a`）** 

  继承（ inheritance ), 即“ is-a” 关系， 是一种用于表示特殊与一般关系的。例如，`RushOrder `类由 `Order `类继承而来。在具有特殊性的 `RushOrder `类中包含了一些用于优先处理的特殊方法， 以及一个计算运费的不同方法；而其他的方法， 如添加商品、 生成账单等都是从 `Order `类继承来的。一般而言， 如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会添加一些额外的功能。

## 2. 用引用操纵对象

⭐ **在 Java 中，一切都被视为对象，但操纵的标识符实际上是对象的一个引用 reference**。

💬 比如：

```java
String s;
```

**这里创建的只是引用，并不是对象**。如果此时对 s 应用 String 方法，会报错。因为此时 s 没有与任何事物相关联。因此，一种安全 的做法是：创建一个引用的同时便进行初始化：

```java
String s = "asdf";
```

不过这里用到了 Java 语言的一个特性：字符串可以用带引号的文本初始化。通常来说必须对对象采用一种更通用的初始化方法：

```java
String s = new String("asdf");
```

**new 关键字的意思就是 “给我一个新对象”**。`new `操作符的返回值也是一个引用

也可以让这个变量引用一个已存在的对象： 

```java
String str = new String("sad");
String s;
s = str
```

现在，这两个变量 `s` 和 `str` 引用同一个对象 `String`。

💬 再看下面一个例子：`Date `同样是 Java 类库中的预定义类

```java
Date deadline = new Date();
```

有两个部分。表达式 `new Date()` 构造了一个 `Date `类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 `deadline` 中。

<u>可以显式地将对象变量设置为  `null`，表明这个对象变量目前没有引用任何对象。</u>

```java
deadline = null;
```

<u>如果将一个方法应用于一个值为 `null` 的对象上，那么就会产生运行时错误。</u>

## 3. 内存分配

程序运行时，内存是怎么分配的呢？有 5 个地方可以存储数据：

- **寄存器**：最快的存储区，位于处理器内部。数量有限且我们无法直接控制。

- **堆栈**：位于通用 RAM（随机访问存储器）中。堆栈指针下移，则分配新的内存；若上移，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。

  创建程序时，Java 系统必须知道存储在堆栈内的所有项的确切生命周期，以便上下移动指针。这一约束限制了程序的灵活性，所以Java 对象并不存储在此。

  **Java 的对象引用和基本数据类型都存储在堆栈中**。比如：

  ```java
  char c = 'x';
  ```

- **堆**：一种通用的内存池，位于 RAM 中，用于**存放所有的 Java 对象（new 出来都存在堆中）**。堆不同于堆栈的好处就是：编译器不需要知道存储的数据在堆里存活多长时间。比如：

  ```java
  String s = new String("ads");
  ```

- **常量存储**：常量值 `static `通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。

- **非 RAM 存储**：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。比如流对象和持久化对象。

## 4. 作用域 scope

### ① 作用域

作用域决定了在其内定义的变量名的可见性和生命周期。在 Java、C++、C 中，作用域由花括号的位置决定。例如：

```java
{
    int x = 12;
    // Only x available
    {
        int q = 96;
        // Both x & q available
    }
    // Only x available
    // q is out of scope
}
```

不过，需要注意的是，以下代码在 C/C++ 中是合法的，但是在 Java 中不能这样写：

```java
{
    int x = 12;
    {
        int x = 123; // 非法
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200717204222.png)

🚨 **在 C/C++ 中，将一个较大作用域的变量隐藏的做法，在 Java 里是不允许的。**

### ② 对象的作用域

Java 对象不具备和基本类型一样的生命周期。当用 new 创建一个 Java 对象时，它可以存活于作用域之外。比如：

```java
{
    String s = new String("aas");
}
```

对象的引用 `s` 在作用域终点就消失了。然而，`s` 指向的 `String `对象仍占据内存空间。我们无法在作用域之后访问这个对象，因为对他唯一的引用已经超出了作用域的范围。

Java 有一个**垃圾回收器**，用来监视 `new `创建的所有对象，并辨别那些不会被再引用的对象，然后释放这些对象的内存空间。

## 5. 用户自定义类

### ① 示例

```java
class Test{
    private int birthday;
    private String sex;

    public Test(){

    }

    public Test(int birthday, String sex){
        this.birthday = birthday;
        this.sex = sex;
    }

    public int getBirthday() {
        return birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setBirthday(int birthday) {
        this.birthday = birthday;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
public class Demo {

    public static void main(String[] args){
        Test test = new Test(18,"male");
        System.out.println(test.getBirthday()); // 18
        System.out.println(test.getSex()); // male
        test.setSex("female");
        System.out.println(test.getSex()); // female
    }
}
```

注意，在这个示例程序中包含两个类：`Test `类和带有 `public `访问修饰符的 `Demo`类。`Demo `类包含了 `main `方法。源文件名是 Demo.java，🚩 因为**文件名必须与 public 类的名字相匹配。在一个源文件中， 只能有一个公有类，但可以有任意数目的非公有类。**

接下来，<u>当编译这段源代码的时候， 编译器将在目录下创建两个类文件：Demo. class 和 Test.class</u>

### ② 构造函数

```java
public Test(int birthday, String sex){
    this.birthday = birthday;
    this.sex = sex;
}
```

可以看到， **构造函数与类同名且没有返回值**。在构造 `Test `类的对象时， 构造函数会运行，以便将实例域初始化为所希望的状态。

构造函数与其他的方法有一个重要的不同。**构造函数总是伴随着 new 操作符的执行被调用， 而不能对一个已经存在的对象调用构造函数来达到重新设置实例域的目的。**

🚩 需要记住：

- 构造函数与类同名 
- 每个类可以有一个以上的构造函数
- 构造函数可以有 0 个、1 个或多个参数 
- 构造函数没有返回值 
- 构造函数总是伴随着 new 操作一起调用

> 📜 Java 构造函数的工作方式与 C++ —样。但是， 要记住所有的 Java 对象都是在堆中构造的， 构造函数总是伴随着 `new `操作符一起使用。**C++ 程序员最易犯的错误就是忘记 `new `操作符**。

### ③ 隐式参数 this 与显式参数

```java
public void setSex(String sex) {
    this.sex = sex;
}
---
test.setSex("female");
```

`setSex `方法有两个参数：

- **隐式 implict 参数**：出现在方法名前的 `test `类对象。

  👉 在每一个方法中， 关键字 `this` 表示隐式参数。

- **显式 explicit 参数**：位于方法名后面括号中的参数 `sex`

> 📜 在 C++ 中， 通常在类的外面定义方法： 
>
> ```cpp
> void Employee::raiseSalary(double byPercent) // C++, not Java { 
> 
> }
> ```
>
>  如果在类的内部定义方法且方法体足够简单， 这个方法将自动地成为内联（inline) 方法 
>
> ```cpp
> class Employee { 
> 	String getName{ 
> 		return name; 
> 	} // inline in C++
> }
> ```
>
> **在 Java 中， 所有的方法都必须在类的内部定义， 但并不表示它们是内联方法。是否将某个方法设置为内联方法是 Java 虚拟机的任务**。即时编译器会监视调用那些简洁、经常被调用、 没有被重载以及可优化的方法。

### ④ 基于类的访问权限

⭐ **一个方法可以访问所属类的所有对象的私有数据**。例如：

```java
 public static void main(String[] args) {
     Test test1 = new Test(18, "male");
     Test test2 = new Test(20, "male");
     System.out.println(test1.equals(test2)); // true
}
```

<u>这个方法访问 `test1 `的私有域， 这点并不会让人奇怪，然而， 它还访问了 `test2 `的私有域。这是合法的， 其原因是 `test2 `是 `Test `类对象， 而 `Test `类的方法可以访问 `Test `类的任何一个对象的私有域。</u>

### ⑤ 私有方法 private

在 Java 中，为了实现一个私有的方法， 只需将关键字 `public `改为 `private` 即可。这样外部的其他类就无法调用。

### ⑥ final 实例域

⭐ 可以将实例域定义为 `final`。 **构建对象时必须初始化这样的域**。也就是说， 必须确保在每一个构造函数执行之后，这个域的值被设置， **并且在后面的操作中， 不能够再对它进行修改**。 

例如，可以将 `Test` 类中的 `age` 域声明为` final`, 因为在对象构建之后，这个值不会再被修改， 即没有 `setAge` 方法。

```java
private final String sex;
```

`final` 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类 中的每个方法都不会改变其对象， 这种类就是不可变的类。例如，`String `类就是一个不可变的类。 **对于可变的类， 使用  `final` 修饰符可能会对读者造成混乱**。例如：

```java
private final StringBuilder sex;
```

在 Test 构造函数中会初始化为：

```java
sex = new StringBuilder();
```

🚩 **`final` 关键字只是表示存储在 `sex` 变量中的对象引用不会再指示其他 `StringBuilder `对象。不过这个对象可以更改**：

```java
public void finalTest{
	sex.append(":a good man")
}
```

## 6. 静态域与静态方法 static

在前面给出的示例程序中，`main `方法都被标记为 `static `修饰符。下面讨论一下这个修饰符的含义。

### ① 静态域

**如果将域定义为 `static`, 每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。**

例如， 假定需要给每一个雇员赋予唯一的标识码。这里给 `Test `类添加一个实例域 `id` 和一个静态域 `nextld`:

```java
class Test{
	private static int nextId = 1;
	private int id;
	...
}
```

⭐ 现在， 每一个 `Test `对象都有一个自己的 `id `域， 但**这个类的所有实例将共享一个 `nextId `域**。换句话说， 如果有 1000 个 `Test `类的对象， 则有 `1000 `个实例域 `id`。但是， 只有一 个静态域 `nextId`。即使没有一个 `Test `对象， 静态域 `nextId `也存在，**它属于类，而不属于任何独立的对象**。

<u>`static `初始化只有在第一次创建 `Test `对象或者调用  `Test.nextId` 的时候才会调用，在那之后，静态域不会重新初始化。初始化的顺序是首先 static，再是其他非 static 对象。</u>

**静态域可直接用类名进行调用**：

```java
Test.nextId ++;
```

### ② 静态常量 static final

静态变量使用得比较少，但静态常量却使用得比较多。例如， 在 `Math `类中定义了一个 静态常量：

```java
public class Math{
	public static final double PI = 3.14159265358979323846;
	...
}
```

在程序中，可以采用 `Math.PI` 的形式获得这个常量。

### ③ 静态方法

静态方法是一种不能向对象实施操作的方法。例如， `Math` 类的 `pow `方法就是一个静态方法。表达式 

```java
Math.pow(3, 2)
```

<u>在运算时，不使用任何 `Math `对象</u>。换句话说，没有隐式的参数。

**可以认为静态方法是没有 this 参数的方法**。

**`Test `类的静态方法不能访问非静态实例域，也不能调用非静态方法**，因为它不能操作对象（非静态方法有可能对实例域进行修改）。但是，静态方法可以访问自身类中的静态域和静态方法：

```java
public statci int getNextId{
	return nextId; // return statci field
}
```

可以通过类名调用这个方法：

```java
int n = Test.getNextId();
```

> 📜 **可以使用对象调用静态方法**。例如， 如果 `test `是一个 `Test` 对象， 可以用 `test.getNextId( )` 代替 `Test.getNextId( ) `。**不过，这种方式很容易造成混淆**，其原因是 `getNextId` 方法计算的结果与 `test `毫无关系。**我们建议使用类名， 而不是对象来调用静态方法**。

在下面两种情况下使用静态方法： 

- 方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：`Math.pow`) 
- 一个方法只需要访问类的静态域（例如：`Test.getNextId`）

> 📜 Java 中的静态域与静态方法在功能上与 C++ 相同。但是， 语法书写上却稍有所不同。在 C++ 中， 使用 `::` 操作符访问自身作用域之外的静态域和静态方法， 如 `Math::PI` 

### ④ 工厂方法

静态方法还有另外一种常见的用途。类似 `LocalDate` 和 `NumberFormat` 的类使用**静态工厂方法 (factory method)** 来构造对象。你已经见过工厂方法 `LocalDate.now` 和 `LocalDate.of`。 

`NumberFormat` 类如下使用工厂方法生成不同风格的格式化对象： 

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); 
NumberFormat percentFormatter = NumberFormat.getPercentInstance(); 
double x = 0.1; 
System.out.println(currencyFormatter.format(x)); // prints $O.10 System.out.println(percentFormatter.format(x)); // prints 10% 
```

为什么 `NumberFormat` 类不利用构造函数完成这些操作呢？ 这主要有两个原因： 

- 无法命名构造函数。构造函数的名字必须与类名相同。但是，这里希望将得到的货币实例和百分比实例采用不用的名字。 
- 当使用构造函数时，无法改变所构造的对象类型。而 `Factory` 方法将返回一个 `DecimalFormat` 类对象，这是 `NumberFormat` 的子类

### ⑤ main 方法

`main `方法也是一个静态方法。`main `方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 `main `方法将执行并创建程序所需要的对象。

💡 **每一个类可以有一个 `main `方法。这是一个常用于对类进行单元测试的技巧**。例如， 可以在 `Test `类中添加一个 `main `方法：

```java
class Test {
    private int birthday;
    private  String sex;

    public Test() {

    }

    public Test(int birthday, String sex) {
        this.birthday = birthday;
        this.sex = sex;
    }

    public int getBirthday() {
        return birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setBirthday(int birthday) {
        this.birthday = birthday;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public boolean equals(Test test){
        return sex.equals(test.sex);
    }

    public static void main(String[] args) {
        Test test1 = new Test(18, "male");
        Test test2 = new Test(20, "male");
        System.out.println(test1.equals(test2)); // true
    }
}

public class Demo {
    public static void main(String[] args) {      
    
    }
}
```

如果想要独立地测试 `Test `类， 只需要运行 `java Test` 命令。或者如下操作：

<img src="https://gitee.com/veal98/images/raw/master/img/20200618151921.png" style="zoom:80%;" />

## 7. 方法参数（按值调用）

首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。

- **按值调用 （call by value )** 表示方法接收的是调用者提供的值。
- **按引用调用 （ call by reference )** 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

⭐ **Java 程序设计语言总是采用<u>按值调用</u>。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。**

假定一个方法试图将一个参数值增加至 3 倍：

```java
public static void tripleValue(double x){
	 x *= 3;
}
--------------------------
double percent = 10;
tripleValue(percent);
```

<u>调用这个方法之后，`percent` 的值还是 10</u>。下面看一下具体的执行过程：

- x 被初始化为 `percent ` 值的一个拷贝（也就 是 10 ) 
- x 被乘以 3 后等于 30。 但是 `percent `仍然是 10 
- 这个方法结束之后，参数变量 x 不再使用。

![](https://gitee.com/veal98/images/raw/master/img/20200618152649.png)

👇 方法参数共有两种类型： 

- 基本数据类型（int、bool 等）
- 对象引用

**已经看到，一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了**，可以很容易地利用下面这个方法实现提高雇员薪金的操作：

```java
public static void tripleSalary (Employee x) {
	x.raiseSalary(200);
}
--------------------------
harry = new Emplyee(...);
tipleSalary(harry);
```

具体的执行过程为： 

- x 被初始化为 `harry `值的拷贝，这里是一个对象的引用。 
- `raiseSalary `方法应用于这个对象引用。x 和 `harry `同时引用的那个 `Employee `对象的薪金提高了 200。 
- 方法结束后，参数变量 x 不再使用。当然，对象变量 `harry `继续引用那个薪金增加 200 的对象。

![](https://gitee.com/veal98/images/raw/master/img/20200618153148.png)

📩 下面总结一下 Java 中方法参数的使用情况： 

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 
- 一个方法可以改变一个对象参数的状态。 
- 一个方法不能让对象参数引用一个新的对象。

> 📜 C++ 有值调用和引用调用。 引用参数标有 `&` 符号。 例如， 可以轻松地实现 `void tripleValue(double& x)` 方法或` void swap(Employee& x, Employee& y)` 方法实现修改它们的引用参数的目的。
>
> ```java
> int swap(int &a, int &b){
>         int temp = a;
>         a = b;
>         b = temp;
> }
> ```
>
> 这种在 C++ 中的常见写法在 Java 中是错误的

## 8. 对象构造(初始化)与清除

前面已经学习了编写简单的构造函数，可以定义对象的初始状态。但是，由于对象构造非常重要，所以 Java 提供了多种编写构造函数的机制。下面将详细地介绍这些机制。

### ① 重载

有些类有多个构造函数。例如， 可以如下构造一个空的 `StringBuilder `对象： 

```java
StringBuilder messages = new StringBuilder(); 
```

或者， 可以指定一个初始字符串：

```java
StringBuilder todoList = new StringBuilder("To do:\n"); 
```

这种特征叫做**重载（overloading)** 。**如果多个方法（比如， StringBuilder 构造函数）有相同的名字、 不同的参数，便产生了重载。**编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。<u>如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。这个过程被称为重载解析（overloading resolution)。</u>

📜 Java 允许重载任何方法， 而不只是构造函数方法。因此，要完整地描述一个方法， 需要指出方法名以及参数类型。这叫做**方法的签名（signature)**。例如， String 类有 4 个 称为 `indexOf` 的公有方法。它们的签名是 

- `indexOf(int) `
- `indexOf(int, int) `
- `indexOf(String) `
- `indexOf(String, int)` 

**返回类型和参数名不是方法签名的一部分**。也就是说， 不能有两个函数名相同、 参数类型也相同却返回不同类型值的方法。

❓ **为什么不能以返回值类型来区分重载方法呢**？

比如说有以下两个函数：

```java
void f(){
    ...
}
int  f(){
    ...
}
```

假如我们这样调用方法：

```java
f();
```

显然 Java 无法判断 `f()` 的具体调用方式，所以不能以返回值类型来区分重载方法

### ② 默认域初始化

**如果在构造函数中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、 布尔值为 false、 对象引用为 null。**然而，只有缺少程序设计经验的人才会这样做。确实， 如果不明确地对域进行初始化，就会影响程序代码的可读性。

<img src="https://gitee.com/veal98/images/raw/master/img/20200717211513.png" style="zoom: 80%;" />

🚨 然而，**上述确保初始化的方法并不适用于局部变量（即并非某个类的字段）**。因此，如果在某个方法中定义有：

```java
int x;
```

那么 变量 x 得到的是任意值，而不会被自动初始化为 0。未初始化就使用会报错：

![](https://gitee.com/veal98/images/raw/master/img/20200717212156.png)

### ③ 无参构造函数(默认构造函数)

很多类都包含一个无参数的构造函数，**对象由无参数构造函数创建时， 其状态会设置为适当的默认值**。 例如， 以下是 Test 类的无参数构造函数： 

```java
public Test { 
    // sex = "";
    // age = 0; 
} 
```

**如果在编写一个类时没有编写构造函数， 那么系统就会提供一个无参数构造函数**。这个构造函数将所有的实例域设置为默认值。

**如果类中提供了至少一个构造函数， 但是没有提供无参数的构造函数， 则在构造对象时如果没有提供参数就会被视为不合法**。

### ④ 显式域初始化

通过重载类的构造函数方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造函数，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。 可以在类定义中， 直接将一个值赋给任何域。例如：

```java
class Test{
 	private String name = "Jack";
}
```

 在执行构造函数之前，先执行赋值操作。当一个类的所有构造函数都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。

> 📜 <u>在 C++ 中， 不能直接初始化类的实例域</u>。所有的域必须在构造函数中设置。<u>但是，有一个特殊的初始化器列表语法</u>，如下所示： 
>
> ```cpp
> Test::Test(String m，int a): male(m), age(a){} // C++
> ```
>
>  C++ 使用这种特殊的语法来调用域构造函数。在 Java 中没有这种必要， 因为对象没有子对象， 只有指向其他对象的指针。

### ⑤ 调用另一个构造函数

关键字 `this` 引用方法的隐式参数。然而，这个关键字还有另外一个含义。 **如果构造函数的第一个语句形如 `this(...)`， 这个构造函数将调用同一个类的另一个构造函数**。下面是一个典型的例子：

```java
public Test(int a){
	// 调用 Test(String, int) 构造函数
	this("test1:" + s);
}
```

> 📜 在 Java 中， this 引用等价于 C++ 的 this 指针。但是， <u>在 C++ 中， 一个构造函数不能调用另一个构造函数</u> , 必须将抽取出的公共初始化代码编写成一个独立的方法。

### ⑥ 非静态初始化块 initializationblock

前面已经讲过两种初始化数据域的方法： 

- 在构造函数中设置值 
- 在声明中赋值 

实际上，Java 还有第三种机制， 称为**初始化块（initializationblock)**。在一个类的声明中， 可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：

```java
class Employee{
    private static int nextld;
    private int id;
    private String name;
    private double salary;
    // object initialization block
    {
        id = nextld;
        nextld++;
    }
    public Employee(String n, double s)
    salary = s;
    public Employee(){
        name =
        salary = 0
    }
...
}
```

**在这个示例中，无论使用哪个构造函数构造对象，id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造函数的主体部分。**

这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造函数中。

### ⑦ 静态初始化块

**静态初始化块**: 使用 `static `定义,  <u>只有当类装载到系统时执行一次，之后不再执行。在静态初始化块中仅能初始化 `static `修饰的数据成员</u>。

**非静态初始化块**: 在每个对象生成时都会被执行一次, 可以初始化类的实例变量。

⭐ 代码块执行顺序：

- 主调类的静态代码块

- 对象父类的静态代码块

- 对象的静态代码块

- 对象父类的非静态代码块

- 对象父类的构造函数
- 对象的非静态代码块

- 对象的构造函数

```java
package codes;

class Root {

    static{
        System.out.println("Root的静态初始化块");
    }

    {
        System.out.println("Root的普通初始化块");
    }

    public Root(){
        System.out.println("Root的无参构造器");
    }
}

class Mid extends Root{

    static{
        System.out.println("Mid的静态初始化块");
    }

    {
        System.out.println("Mid的普通初始化块");
    }

    public Mid(){
        System.out.println("Mid的无参构造器");
    }

    public Mid (String msg){
        //通过this来调用同一类中重载的构造器
        this();
        System.out.println("Mid的带参构造器，其参数值："+msg);
    }
}

class Leaf extends Mid{

    static{
        System.out.println("Leaf的静态初始化块");
    }

    {
        System.out.println("Leaf的普通初始化块");
    }

    public Leaf(){
        //通过super调用父类中有一个字符串参数的构造器
        super("Java程序设计");
        System.out.println("执行Leaf的构造器");
    }
}
public class Test {

    public static void main(String[] args) {

        new Leaf();
        System.out.println("---------------");
        new Leaf();

    }

}
```

执行结果：

> Root的静态初始化块
>
> Mid的静态初始化块
>
> Leaf的静态初始化块
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> **执行Leaf的构造器**
>
> Root的普通初始化块
>
> Root的无参构造器
>
> Mid的普通初始化块
>
> Mid的无参构造器
>
> Mid的带参构造器，其参数值：Java程序设计
>
> Leaf的普通初始化块
>
> 执行Leaf的构造器

### ⑧ 对象析构与 finalize 方法

有些面向对象的程序设计语言，特别是 C++, 有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中， 最常见的操作是回收分配给对象的存储空 间。**由于 Java 有自动的垃圾回收器，不需要人工回收内存， 所以 Java 不支持析构器。** 

当然，某些对象使用了内存之外的其他资源， 例如，文件或使用了系统资源的另一个对 象的句柄。在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。 **可以为任何一个类添加 `finalize` 方法。当垃圾收集器认为没有指向对象实例的引用时，会在销毁该对象之前调用 finalize() 方法。**该方法最常见的作用是确保释放实例占用的全部资源。 <u>在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为 Java 并不保证定时为对象实例调用该方法，甚至不保证方法会被调用，所以该方法不应该用于正常内存处理。</u>

- `System.gc();`  ：告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的 

- `System.runFinalization();`  ：强制调用已经失去引用的对象的 finalize 方法 

## 9. 包 package

### ① 类的导入

一个类可以使用所属包中的所有类， 以及其他包中的公有类（ public class。) 我们可以 采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。 例如： 

```java
java.time.LocalDate today = java.time.LocalDate.now();
```

这显然很繁琐。更简单且更常用的方式是使用 import 语句。

```java
import java.util.*
```

> 📜 在 C++ 中， 与包机制类似的是命名空间（namespace)。 在 Java 中， package 与 import 语句类似于 C++ 中的 namespace 和 using 指令。

### ② 静态导入

import 语句不仅可以导入类，还增加了导人静态方法和静态域的功能。 例如，如果在源文件的顶部， 添加一条指令：

```java
import static java.lang.System.*; 
```

就可以使用 System 类的静态方法和静态域，而不必加类名前缀： 

```java
out.println("Goodbye, World!"); // System.out 
exit(0); // System.exit
```

 另外，还可以导入特定的方法或域： 

```java
import static java.lang.System.out;
```

### ③ 将类放入包中

要想将一个类放入包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之前。例如，Test.java 开头是这样的： 

```java
package com.smallbeef.program_java;

public class Test { } 
```

**如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包 ( `default package` ) 中。默认包是一个没有名字的包。**

### ④ 包作用域

前面已经接触过访问修饰符 `public `和 `private`。

- 标记为 `public `的部分可以被任意的类使用；

- 标记为 `private `的部分只能被定义它们的类使用。

- **如果没有指定访问修饰符, 这部分（类、方法或变量）可以被同一个包中的所有方法访问。** 

  在 java.awt 包中的 Window 类就是一个典型的示例。`java.awt` 包 是 JDK 提供的部分源代码： 

  ```java
  public class Window extends Container { 
      String warningString; 
  } 
  ```

  请注意，这里的 `wamingString` 变量不是 `private` ! 这 意 味 着 `java.awt` 包中的所有类的方法都可以访问该变量， 并将它设置为任意值。实际上，只有 Window 类的方法访问它，因此应该将它设置为私有变量。

⭐ **下面总结一下访问修饰符**，Java 的类成员访问权限修饰词有四类：`private`，`无`（默认情况下），`protected `和 `public`。其权限控制如下表所示：

![](https://gitee.com/veal98/images/raw/master/img/20200712120116.png)

其中，默认情况下没有任何修饰词，这样的类成员具有“包访问权”，即位于同一个包中的类对其有访问权。🚩 参见下图：`name `被定义为 `private`，只有 `Dog ` 类能访问它，而 `says `字段可以被同一个包的所有类访问。

![](https://gitee.com/veal98/images/raw/master/img/20200712120501.png)

`protected` 为“继承访问权”，即该类的子类对其具有访问权（同时，位于同一个包中的类也对其具有访问权）。

## 10. 文档注释

JDK 包含一个很有用的工具，叫做 `javadoc`, 它可以由源文件生成一个 HTML 文档。

### ① 注释的插入

javadoc 实用程序（utility) 从下面几个特性中抽取信息：

- 包
- 公有类与接口
- 公有的和受保护的构造函数及方法
- 公有的和受保护的域

应该为上面几部分编写注释、 注释应该放置在所描述特性的前面。注释以 `/**`开始，并以 `*/` 结束。每个` /** . . . */ `文档注释在标记之后紧跟着自由格式文本（ free-form text )。标记由 `@` 开始， 如`@author` 或`@param`。自由格式文本的第一句应该是一个概要性的句子。javadoc 实用程序自动地将这些句子抽取出来形成概要页。

### ② 类注释

类注释必须放在 import 语句之后，类定义之前。

下面是一个类注释的例子：

![](https://gitee.com/veal98/images/raw/master/img/20200618162542.png)

### ③ 方法注释

每一个方法注释必须放在所描述的方法之前。除了通用标记之外， 还可以使用下面的标记：

- `@param` 变量描述 

  这个标记将对当前方法的 param（参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 `@param` 标记必须放在一起。 

- `@return` 描述 

  这个标记将对当前方法添加 return（返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。 

- `@throws` 类描述 

  这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。

下面是一个方法注释的示例：

![](https://gitee.com/veal98/images/raw/master/img/20200618162730.png)

### ④ 域注释

只需要对公有域（通常指的是静态常量）建立文档。 例如：

![](https://gitee.com/veal98/images/raw/master/img/20200618162755.png)

### ⑤ 通用注释

下面的标记可以用在类文档的注释中：

![](https://gitee.com/veal98/images/raw/master/img/20200618163024.png)

### ⑥ 包与概述注释

可以直接将类、 方法和变量的注释放置在 Java 源文件中， 只要用 ` /** . . . */ ` 文档注释界定就可以了。但是， 要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 

- 1 ) 提供一个以 `package.html` 命名的 HTML 文件。在标记 `<body></body>`的所有文本都会被抽取出来。 
- 2 ) 提供一个以 `package-info.java` 命名的 Java 文件。这个文件必须包含一个初始的以 `/**` 和 `*/` 界定的 Javadoc 注释， 跟随在一个包语句之后。它不应该包含更多的代码或注释。 

还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为 `overview.html` 的文件中，这个文件位于包含所有源文件的父目录中。标记 `<body></body>`之间的所有文本将被抽取出来。当用户从导航栏中选择“ Overview” 时，就会显示出这些注释内容。

### ⑦ 注释的抽取

这里，假设 HTML 文件将被存放在目录 `docDirectory` 下。执行以下步骤：

- 1 ) 切换到包含想要生成文档的源文件目录。 如果有嵌套的包要生成文档， 例如 `com. horstmann.corejava`, 就必须切换到包含子目录 com 的目录（如果存在` overview.html` 文件的 话， 这也是它的所在目录)。

- 2）如果是一个包，应该运行命令: 

  ```powershell
  javadoc -d docDirectory 包名
  ```

   或对于多个包生成文档，运行: 

  ```powershell
  javadoc -d docDirectory 包名1 包名2 . . .
  ```

   如果文件在默认包中， 就应该运行：

  ```powershell
  javadoc -d docDirectory *.java
  ```

## 📚 References

- 《Java 核心技术 - 卷 1 基础知识 - 第 10 版》
- 《Thinking In Java（Java 编程思想）- 第 4 版》