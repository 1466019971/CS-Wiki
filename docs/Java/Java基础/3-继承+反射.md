# 👑 继承 + 反射

---

## 1. 类、超类和子类

### ① 定义子类 extends

关键字 `extends` 表明正在构造的新类派生于一个已存在的类。 

- 已存在的类称为**超类 ( superclass)**、 基类（ base class) 或父类（parent class); 
- 新类称为**子类（subclass)** 、派生类 ( derived class) 或孩子类（child class)。

>📜 Java 与 C++ 定义继承类的方式十分相似。Java 用关键字 `extends` 代替了 C++ 中的冒号（`:`）。**在 Java 中， 所有的继承都是公有继承**， 而没有 C++ 中的私有继承和保护继承 .

💬 示例代码如下:

- **超类**：

    ```java
    class Employee{
        private String name;
        private double salary;
        private LocalDate hireDay;

        public Employee(String name, double salary, int year, int month, int day){
            this.name = name;
            this.salary = salary;
            hireDay = LocalDate.of(year,month,day);
        }
        public String getName(){
            return this.name;
        }
        public double getSalary(){
            return this.salary;
        }
        public LocalDate getHireDay(){
            return this.hireDay;
        }
        public void raiseSalary(double byPercent){
            double raise = salary * byPercent / 100;
            salary += raise;
        }
    }
    ```

- **子类**:

  ```java
  public class Manager extends Employee{
      private double bonus;
      ...
  	public void setBonos(double bonus){
      	this.bonus = bonus;
      }
  }
  ```

  尽管在 Manager 类中没有显式地定义 getName 和 getHireDay 等方法， 但属于 Manager 类的对象却可以使用它们，这是因为 Manager 类自动地继承了超类 Employee 中的 这些方法。 同样， 从超类中还继承了 name、 salary 和 hireDay 这 3 个域。这样一来， 每个 Manager 类对象就包含了 4 个域：name、 salary、hireDay 和 bonus。

### ② 覆盖方法

子类可以覆盖超类中的方法 :

```java
public class Manager extends Employee{
	...
	public double getSalary(){
        return salary + bonus;
    }
}
```

显然, 上述方法是有错的 ❌ , 因为**尽管每个 Manager 对象都拥有一个名为 salary 的域， 但 Manager 类并不能够直接地访问 salary 域**。只有 Employee 类的方法才能够访问私有部分。<u>如果 Manager 类的方法一定要访问私有域， 就必须借助于公有的接口， Employee 类中的 公有方法 getSalary 正是这样一个接口。</u>

下面代码是正确的: ✅

```java
public class Manager extends Employee{
	...
	public double getSalary(){
        return super.getSalary() + bonus;
    }
}
```

> 📜 有些人认为 `super` 与 `this` 引用是类似的概念， 实际上，这样比较并不太恰当。这是因为 **`super` 不是一个对象的引用， 不能将 `super` 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字**。

在子类中可以增加域、 增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。 

> 📜 在 Java 中使用关键字 super 调用超类的方法，而在 C++ 中则采用超类名加 上`::` 操作符的形式。例如， 在 Manager 类的 getSalary 方法中，应该将 super.getSalary 替换为 `Employee::getSalary`

🚨 **在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 `public`, 子类方法一定要声明为 `public`。**经常会发生这类错误：在声明子类方法的时 候， 遗漏了 public 修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

### ③ 子类构造函数

```java
public Manager(String name, double salary, int year, int month, int day){
    super(name, salary, year, month, day);
    bonus = 0;
}
```

语句 `super(n, s, year, month, day); `是 <u>调用超类 Employee 中含有 n、s、year、month 和 day 参数的构造函数</u>  的简写形式。

由于 Manager 类的构造器不能访问 Employee 类的私有域， 所以必须利用 Employee 类 的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。**使用 super 调用构造器的语句必须是子类构造器的第一条语句**。 

**如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认的构造函数（无参构造函数）**。 如果超类没有无参构造函数， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。

> 📜 关键字 this 有两个用途： 一是引用隐式参数，二是调用该类其他的构造器 。
>
>  同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。 
>
> 在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作为另 一个构造器的第一条语句出现。构造参数既可以传递给本类（ this) 的其他构造器，也可以传递给超类（super ) 的构造器。

> 📜在 C++ 的构造函数中，使用初始化列表语法调用超类的构造函数， 而不调用 super。在 C++ 中， Manager 的构造函数如下所示：
>
> ```cpp
> Manager::Manager(String name, double salary, int year, int month,int day): Employee(name, salary,year,month,day){
> 	bonus = 0;
> }
> ```

下面给出一个例子，其功能为创建一个新经理，并设置他的奖金： 

```java
Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15); 
boss.setBonus(5000) ; 
```

下面定义一个包含 3 个雇员的数组： 

```java
Employee[] staff = new Employee[3]; 
```

将经理和雇员都放到数组中：

```java
staff[0] = boss; 
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1); 
staff[2] = new Employee("Tony Tester" , 40000, 1990, 3, 15); 
```

输出每个人的薪水： 

```java
for (Employee e : staff) 
    System.out.println(e.getName() + " " + e.getSalary(); 
```

运行这条循环语句将会输出下列数据： 

> Carl Cracker 85000.0 
>
> Harry Hacker 50000.0 
>
> Tommy Tester 40000.0 

`e.getSalary()` 调用能够确定应该执行哪个 `getSalary` 方法。<u>当 e 引用 Employee 对象时， e.getSalary( ) 调用的是 Employee 类中的 getSalary 方法；当 e 引用 Manager 对象时，e.getSalary( ) 调用的是 Manager 类中的 getSalary 方法</u>。**虚拟机知道 e 实际引用的对象类型，因此能够正确地调用相应的方法。** 

一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为**多态（ polymorphism)**。 在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（ dynamic binding ）**。

> 📜 在 Java 中， 不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征， 可以将它标记为 `final`（本章稍后将介绍关键字 final）

### ④ 继承层次

由一个公共超类派生出来的所有类的集合被称为**继承层次（ inheritance hierarchy )**。在继承层次中， 从某个特定的类到其祖先的路径被称为该类的**继承链 ( inheritance chain)** 。

![](https://gitee.com/veal98/images/raw/master/img/20200619104058.png)

> 📜 **Java 不支持多继承，支持多接口。**（有关接口内容请看 <u>4-接口+lambda表达式+内部类</u>）

### ⑤ 多态

**程序中出现超类对象的任何地方都可以用子类对象置换**。

```java
Employee e;
e = new Employee(. . .); // Employee object expected
e = new Manager(. . .); // OK, Manager can be used as well
```

然而，**不能将一个超类的引用赋给子类变量**。例如：

```java
Manager boss = new Manager(. . .);
Employee[] staff = new Employee[3];
staff[0] = boss; 
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1); 
staff[2] = new Employee("Tony Tester" , 40000, 1990, 3, 15); 

Manager m = staff[1]; // Error
```

原因很清楚：不是所有的雇员都是经理。

### ⑥ 理解方法调用

弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 `x.f(args) `，隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述： 

- 1 ) **编译器査看对象的声明类型和方法名**。

  假设调用 `x.f(param)` ，且隐式参数 x 声明为 C 类的对象。需要注意的是：有可能存在多个名字为 f,  但参数类型不一样的方法。例如，可能存在方法 `f(int)` 和方法 `f(String) `。编译器将会一一列举所有 C 类中名为 `f` 的方法和其超类中访问属性为 `public` 且名为 `f` 的方法（超类的私有方法不可访问）。 至此， 编译器已获得所有可能被调用的候选方法。 

- 2 ) **接下来，编译器将査看调用方法时提供的参数类型**。

  如果在所有名为` f` 的方法中存在 一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（ overloading resolution)**。例如，对于调用 `x.f(“Hello” `）来说， 编译器将会挑选 `f(String)`，而不是 `f(int)`。

  由于允许类型转换（ int 可以转换成 double, Manager 可以转换成 Employee, 等等) ，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。 至此， 编译器已获得需要调用的方法名字和参数类型。

    > 📜 前面曾经说过， 方法的名字和参数列表称为方法的签名。例如， `f(int)` 和 `f(String) `是两个具有相同名字， 不同签名的方法。如果在子类中定义了一个与超类签名相同的方 法， 那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。 
    >
    > 不过，返回类型不是签名的一部分， 因此，在覆盖方法时， 一定要保证返回类 的兼容性。 **允许子类将覆盖方法的返回类型定义为原返回类型的子类型**。
    >
    > 例如， 假设 `Employee` 类有 
    >
    > ```java
    > public Employee getBuddy(){ . . . }
    > ```
    >
    > 在后面的子类 `Manager` 中， 可以按照如下所示的方式覆盖这个方法 
    >
    > ```java
    > public Manager getBuddy(){ . . . } // OK to change return type
    > ```
    >
    >  我们说，**这两个 `getBuddy` 方法具有可协变的返回类型**。

- 3 ) **如果是 `private` 方法、` static` 方法、` final` 方法或者构造函数， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding )**。 与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 `f(String)` 的指令。

- 4 ) 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了 方法 `f(String) `，就直接调用它；否则， 将在 D 类的超类中寻找` f(String)` ，以此类推。 

  每次调用方法都要进行搜索，时间开销相当大。因此，**虚拟机预先为每个类创建了一个方法表（ method table), 其中列出了所有方法的签名和实际调用的方法**。这样一来，在真正 调用方法的时候， 虚拟机仅查找这个表就行了。

### ⑦ 阻止继承：final 类和方法

有时候，可能希望阻止人们利用某个类定义子类。**不允许扩展的类被称为 `final` 类**。如果在定义类的时候使用了 `final` 修饰符就表明这个类是` final` 类。

例如， 假设希望阻止人们定义 `Executive` 类的子类，就可以在定义这个类的时候使用 `final `修饰符声明。声明格式如下所示： 

```java
public final class Executive extends Manager{
    ...
}
```

**类中的特定方法也可以被声明为 `final`。如果这样做，子类就不能覆盖这个方法（ <u>`final` 类中的所有方法自动地成为 final 方法</u>) 。** 例如

```java
public class Employee{
	...
	public final String getName(){ // 该方法不可被子类覆盖
		return name;
	}
	...
}
```

> 📜 前面曾经说过， 域（字段、属性）也可以被声明为 `final`。 对于 `final` 域来说，构造对象之后就不允许改变它们的值了。不过， **如果将一个类声明为 `final`， 只有其中的方法自动地成为 `final`, 而不包括域。**

### ⑧ 强制类型转换

```java
double x = 3.405;
int nx = (int) x ;
```

正像有时候需要将浮点型数值转换成整型数值一样，有时候也可能需要将某个类的对象 引用转换成另外一个类的对象引用。对象引用的转换语法与数值表达式的类型转换类似， 仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如： 

```java
Employee[] staff = new Employee[3];

Manager boss = (Manager) staff[0];
```

**进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能**。

将一个子类的引用赋给一个超类变量， 编译器是允许的。但**将一个超类的引用赋给一个子类变量， 必须进行类型转换， 这样才能够通过运行时的检査**。

如果试图在继承链上进行向下的类型转换，并且“ 谎报” 有关对象包含的内容，会发生 什么情况呢？ 

```java
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1); 

Manager boss = (Manager) staff[1]; // Error
```

 运行这个程序时， Java **运行时**系统将报告这个错误，并产生一个 `ClassCastException` 异常。 **如果没有捕获这个异常，那么程序就会终止。**因此，应该养成这样一个良好的程序 设计习惯：在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用 `instanceof` 操作符就可以实现。 例如：

```java
if(staff[1] instanceof Manager){
	Manager boss = (Manager) staff[1];
}
```

最后，**如果这个类型转换不可能成功， 编译器就不会进行这个转换**。例如，下面这个类型转换： 

```java
String c = (String) staff[1]; 
```

将会产生编译错误， 这是因为 String 不是 Employee 的子类。 

🚩 综上所述： 

- 只能在继承层次内进行类型转换。 
- 在将超类转换成子类之前，应该使用 `instanceof` 进行检查。

> 📜 如果 `x` 为 `null` , 进行下列测试 
>
> ```java
> x instanceof C
> ```
>
>  不会产生异常， 只是返回 `false`。之所以这样处理是因为 `null` 没有引用任何对象， 当然也不会引用 `C` 类型的对象。

### ⑨ 抽象类 abstract

抽象方法即没有方法体的方法，用 `abstract`表明，**包含一个或多个抽象方法的类本身必须被声明为抽象的**。例如：

```java
public abstract class Person{
	public abstract String getDescription();
}
```

**除了抽象方法之外，抽象类还可以包含具体数据和具体方法**。例如， Person 类还保存着姓名和一个返回姓名的具体方法：

```java
public abstract class Person{
    private String name;
    public Person(String name){
    	this.name = name ;
    }
    public abstract String getDescription();
    public String getName(){
    	return name;
    }
}
```

> 🚩 许多程序员认为，在抽象类中不能包含具体方法。**建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中**。

**抽象类不能被实例化。也就是说，如果将一个类声明为 abstract, 就不能创建这个类的对象。**

```java
new Person("jack"); // error
```

可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象。 例如:

```java
Person p = new Student("Jack"); 
```

这里的 p 是一个抽象类 Person 的变量，Person 引用了一个非抽象子类 Student 的实例。

> 📜 在 C++ 中， 有一种在尾部用 `=0` 标记的抽象方法， 称为**纯虚函数**， 例如： 
>
> ```java
> class Person{ 
>     public: 
>     	virtual string getDescriptionO = 0; 
> }
> ```
>
> 只要有一个纯虚函数，这个类就是抽象类。在 C++ 中， 没有提供用于表示抽象类的特殊关键字。

💬 下面定义一个扩展抽象类 Person 的具体子类 Student： 

```java
public class Student extends Person { 
    private String major; 
    public Student(String name, String major) { 
        super(name); 
        this.major = major; 
    } 
    public String getDescription(){ 
    	return "a student majoring in " + major; 
    } 
} 
```

在 Student 类中实现了父类中的抽象方法 `getDescription` 。因此，**在 Student 类中的全部方法都是非抽象的， 这个类不再是抽象类**。

👇 调用如下：

```java
Person p = new Student("Jack","Computer Science");
p.getDescription();
```

<u>由于不能构造抽象类 Person 的对象， 所以变量 p 永远不会引用 Person 对象， 而是引用诸如 Student 这样的具体子类对象， 而这些对象中都定义了 getDescription 方法。</u>

### ⑩ 受保护访问 protected

大家都知道，最好将类中的域标记为 `private`, 而方法标记为 `public`。任何声明为 `private` 的内容对其他类都是不可见的。前面已经看到， 这对于子类来说也完全适用，即子类也不能访问超类的私有域。

然而，在有些时候，人们希望超类中的某些方法允许被子类访问， 或**允许子类的方法访问超类的某个域**。为此， 需要将这些方法或域声明为 `protected`。例如，如果将超类 Employee 中的 hireDay 声明为 proteced, 而不是私有的， Manager 中的方法就可以直接地访问它。

**不过，Manager 类中的方法只能够访问 Manager 对象中的 hireDay 域， 而不能访问其他 Employee 对象中的这个域。**这种限制有助于避免滥用受保护机制，使得子类只能获得访问受保护域的权利。

在实际应用中，要谨慎使用 protected 属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护域， 由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使 用这个类的程序员。这违背了 OOP 提倡的数据封装原则。 

**受保护的方法更具有实际意义。 如果需要限制某个方法的使用， 就可以将它声明为 `protected`。这表明子类得到信任，可以正确地使用这个方法，而其他类则不行。**

> 📜 事实上，**Java 中的受保护部分对所有子类及同一个包中的所有其他类都可见**。 这与 C++ 中的保护机制稍有不同， <u>Java 中的 `protected` 概念要比 C++ 中的安全性差</u>。

🚩 下面归纳一下 Java 用于控制可见性的 4 个访问修饰符：

- 仅对本类可见 `private`
- 对所有类可见 `public`
- 对本包和所有子类可见 `protected`
- 对本包可见 — 不需要修饰符（默认）

## 2. Object：所有类的超类

### ① 概述

`Object` 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。但是并不需要这样写 :

```java
public class Employee extends Object
```

如果没有明确地指出超类，Object 就被认为是这个类的超类。由于在 Java中，每个类都 是由 Object 类扩展而来的，所以， 熟悉这个类提供的所有服务十分重要。

可以使用 Object 类型的变量引用任何类型的对象：

```java
Object obj = new Employee("Harry Hacker", 35000);
```

当然， Object 类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作， 还需要清楚对象的原始类型， 并进行相应的类型转换：

```java
Employee e = (Employee) obj;
```

**在 Java 中，只有基本类型 （primitive types) 不是对象**， 例如，数值、 字符和布尔类型的值都不是对象。

 <u>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类</u>。

```java
Employee[] staff = new Employee[10];
obj = staff; // OK
obj = new int[10]; // OK
```

> 📜 在 C++ 中没有所有类的根类，不过，每个指针都可以转换成 `void *` 指针。

### ② equals 方法

Object 类中的 `equals` 方法用于检测一个对象是否等于另外一个对象。**在 Object 类中，这 个方法将判断两个对象是否具有相同的引用（地址）**。如果两个对象具有相同的引用， 它们一定是相等的。

```java
public boolean equals(Object otherObject){
        if(this == otherObject)
            return true;
        if(otherObject == null)
            return false;
        if(getClass() != otherObject.getClass())
            return false;
        Employee other = (Employee) otherObject;
        return name.equals(other.name) && salary.equals(other.salary) && hireDay.equals(other.salary);
}
```

`getClass` 方法将返回一个对象所属的类，有关这个方法的详细内容稍后在反射章节进行介绍。

**在子类中定义 equals 方法时， 首先调用超类的 equals**。如果检测失败， 对象就不可能相等。如果超类中的域都相等， 就需要比较子类中的实例域。

```java
public class Manager extends Employee
    public boolean equals(Object otherObject){
        if (!super.equals(otherObject)) 
            return false;
        // super.equals checked that this and otherObject belong to the same class
        Manager other = (Manager) otherObject;
        return bonus == other.bonus;
    }
}
```

🚩 **equals 和 == 比较：**

- `==`: 它的作用是**判断两个对象的地址是不是相等**。即，判断两个对象是不是同一个对象。(基本数据类型 `==` 比较的是值，引用数据类型 `==` 比较的是内存地址)
- `equals()` : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
  - 情况1：<u>类没有覆盖 equals() 方法</u>。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
  - 情况2：<u>类覆盖了 equals() 方法</u>。一般，我们都覆盖 equals() 方法来判断两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

举个例子：

```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true String的 equals方法是被重写过的
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

💡 说明：

- **String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。**
- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。（第一章 Java的基本程序结构中已经解释过）

### ④ hashCode 方法

**散列码（ hash code )** 是由对象导出的一个整型值。散列码是没有规律的。**如果 x 和 y 是 两个不同的对象， `x.hashCode( )` 与 `y.hashCode( ) `基本上不会相同**。

👉 String 类使用下列算法计算散列码： 

```java
int hash = 0; 
for (int i = 0; i < length(); i++) 
	hash = 31 * hash + charAt(i);
```

由于 **hashCode方法定义在 Object 类中**， 因此每个对象都有一个默认的散列码，**其值为对象的存储地址**。来看下面这个例子。

```java
String s = "Ok";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + " " + sb.hashCode());
String t = new String("Ok");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + " " + tb.hashCode());
```

![](https://gitee.com/veal98/images/raw/master/img/20200619141650.png)

🚨 请注意， **字符串 s 与 t 拥有相同的散列码， 这是因为字符串的散列码是由内容导出的。而字符串缓冲 sb 与 tb 却有着不同的散列码， 这是因为在 StringBuffer 类中没有定义 hashCode 方法，它的散列码是由 Object 类的默认 hashCode 方法导出的对象存储地址**。

⭐ 关于 hashCode 和 equals 方法需要注意以下几点：

- **如果重新定义 equals方法，就必须重新定义 hashCode 方法**， 以便用户可以将对象插人到散列表中 

- `Equals ` 与 `hashCode` 的定义必须一致：**如果 `x.equals(y)` 返回 true, 那么 `x.hashCode( )` 就必须与 `y.hashCode( )` 具有相同的值。**

  例如， 如果用定义的 `Employee.equals` 比较雇员的 ID，那 么 `hashCode` 方法就需要散列 ID，而不是雇员的姓名或存储地址。

- **等价（equals）的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价**。

### ⑤ toString 方法

**`toString` 方法用于返回表示对象值的字符串。**

绝大多数（但不是全部）的 toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。下面是 Employee 类中的 toString 方法的实现：

```java
public String toString(){
    return "Employee[name=" + name
        + ",salary=" + salary
        + ",hireDay=" + hireDay
        + "]";
}
```

实际上，还可以设计得更好一些。最好通过调用 `getClass().getName()` 获得类名的字符串，而不要将类名硬加到 toString 方法中。

```java
public String toString(){
    return getClass().getName()
        + "[name=" + name
        + ",salary=" + salary
        + ",hireDay=" + hireDay
        + "]";
}
```

如果超类使用了 `getClass().getName()`, 那么子类只要调用 `super.toString()`就可以了。例如， 下面是 Manager 类中的 toString 方法：

```java
public class Manager extends Employee
    ...
    public String toString(){
        return super.toString()
            + "[bonus=" + bonus
            + "]";
    }
}
```

随处可见 toString方法的主要原因是：**只要对象与一个字符串通过操作符“ `+`” 连接起 来，Java 编译就会自动地调用 toString 方法，以便获得这个对象的字符串描述**。例如：

```java
Point p = new Point(10, 20);
String message = "The current position is " + p;
// automatically invokes p.toString()
```

如果 x 是任意一个对象， 并调用

```java
System.out.println(x);
```

`println` 方法就会直接地调用 `x.toString()`  ，并打印输出得到的字符串。

Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码。例如： 

```java
System.out.println(System.out)
```

 将输出下列内容： 

> java.io.PrintStream@2f6684 

之所以得到这样的结果是因为 PrintStream 类的设计者没有覆盖 toString 方法。

> 🚨 令人烦恼的是， 数组继承了 object 类的 toString 方法，数组类型将按照旧的格式打印。例如： 
>
> ```java
> int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 }; 
> String s = "" + luckyNumbers;
> ```
>
> 生成字符串`“[I@la46e30”` （前缀` [I` 表明是一个整型数组）。
>
> 修正的方式是调用静态方法 `Arrays.toString`。代码： 
>
> ```java
> String s = Arrays.toString(luckyNumbers);
> ```
>
> 将生成字符串`“[2,3,5,7,11,13]”`。 
>
> 要想打印多维数组（即， 数组的数组）则需要调用 `Arrays.deepToString` 方法。

## 3. 对象包装器与自动装箱

有时， 需要将 int 这样的基本类型转换为对象。 所有的基本类型都冇一个与之对应的类。 例如，`Integer` 类对应基本类型 int。通常， 这些类称为**包装器 （ wrapper )** 

| 基本类型 | 对应的包装类（位于 java.lang 包中） |
| -------- | ----------------------------------- |
| byte     | Byte                                |
| short    | Short                               |
| int      | **Integer**                         |
| long     | Long                                |
| float    | Float                               |
| double   | Double                              |
| char     | **Character**                       |
| boolean  | Boolean                             |
| void     | Void                                |

> 📜 前 6 个类派生于公共的超类 `Number`

对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时， 对象包装器类还是 `final`, 因此不能定义它们的子类。

假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说， 不允许写成 ArrayList。这里就用到了 Integer 对象包装器类。我们可以声明一个 Integer 对象的数组列表。 

```java
ArrayList<Integer> list = new ArrayList<>()；
```

> 🚨 由于每个值分别包装在对象中， 所以 `ArrayList` 的效率远远低于 `int[]` 数 组。 因此， 应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更重要。

有一个很有用的特性， 从而更加便于添加 int 类型的元素到 `ArrayList<Integer> `中。下面这个调用 

```java
list.add(3); 
```

将自动地变换成

```java
list.add (Integer.valueOf(3));
```

 这种变换被称为**自动装箱（autoboxing )**。

相反地， 当将一个 Integer 对象赋给一个 int 值时， 将会**自动拆箱**。也就是说， 编译器将下列语句： 

```java
int n = list.get(i);
```

 翻译成

```java
int n = list.get(i).intValue();
```

甚至**在算术表达式中也能够自动地装箱和拆箱**。例如，可以将自增操作符应用于一个包装器引用：

```java
Integer n = 3; 
n++; 
```

编译器将自动地插人一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。 

大多数情况下，容易有一种假象， 即基本类型与它们的对象包装器是一样的，只是它们的相等性不同。大家知道，` ==` 运算符也可以应用于对象包装器对象， 只不过检测的是对象是否指向同一个存储区域， 因此，下面的比较通常不会成立： 

```java
Integer a = 1000; 
Integer b = 1000; 
if (a = b) 
    // do something
```

 然而，**Java 实现却有可能让它成立**。<u>如果将经常出现的值包装到同一个对象中， 这种比较就有可能成立</u>。这种不确定的结果并不是我们所希望的。**解决这个问题的办法是在两个包装器对象比较时调用 `equals` 方法。**

> 📜 **自动装箱规范要求 `boolean`、`byte`、`char` <= 127， 介于 `-128 ~ 127` 之间的 `short` 和 `int` 被包装到固定的对象中。**
>
> 例如，如果在前面的例子中将 a 和 b 初始化为 100，对它们进行比较的结果一定成立。

使用数值对象包装器还有另外一个好处。Java 设计者发现，<u>可以将某些基本方法放置在包装器中</u>， 例如， 将一个数字字符串转换成数值。 要想将字符串转换成整型， 可以使用下面这条语句：

```java
int x = Integer.parseInt(str); 
```

这里与 Integer 对象没有任何关系， `parseInt` 是一个静态方法。但 Integer 类是放置这个方法的一个好地方。

👇 API 注释说明了 Integer 类中包含的一些重要方法。其他数值类也实现了相应的方法。

![](https://gitee.com/veal98/images/raw/master/img/20200619152608.png)

## 4. 可变参数

在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且**多个参数类型一致**，我们可以对其简化成如下格式：

```java
修饰符 返回值类型 方法名(参数类型... 形参名){  }
```

其实这个书写完全等价与

```java
修饰符 返回值类型 方法名(参数类型[] 形参名){  }
```

只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。

🚩 **JDK1.5** 以后。出现了简化操作。**`...` 用在参数上，称之为可变参数，它表明这个方法可以接收任意数量的对象。**

**同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递**，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。

代码演示：    

```java
public class ChangeArgs {
    public static void main(String[] args) {
        int[] arr = { 1, 4, 62, 431, 2 };
        int sum = getSum(arr);
        System.out.println(sum);
        //  6  7  2  12  2121
        // 求这几个元素和 6  7  2  12  2121
        int sum2 = getSum(6, 7, 2, 12, 2121);
        System.out.println(sum2);
    }

    /*
     * 所有元素的求和的原始写法
     
      public static int getSum(int[] arr){
        int sum = 0;
        for(int a : arr){
            sum += a;
        }
        
        return sum;
      }
    */
    //可变参数写法
    public static int getSum(int... arr) {
        int sum = 0;
        for (int a : arr) {
            sum += a;
        }
        return sum;
    }
}
```

> 🚨 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，**可变参数一定要写在参数列表的末尾位置。**

## 5. 反射

反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。

在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？

Java 反射机制主要提供了以下功能：

- 在运行时（动态编译）判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法和属性。

这种**动态获取信息以及动态调用对象的方法**的功能称为 Java 语言的反射机制

### ① Class 类

**在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识**。 这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。 

可以通过专门的 Java 类访问这些信息。**保存这些信息的类被称为 `Class`**，这个名字很容易让人混淆。

下面介绍获得 Class 类对象的 3 种方法：

- 🥇 `Object.getClass()`

  **`Object` 类中的 `getClass( ) `方法将会返回一个 `Class` 类型的实例**。

  ```java
  Employee e;
  Class c1 = e.getClass();
  ```

  如同用一个 Employee 对象表示一个特定的雇员属性一样， 一个 Class 对象将表示一个特定类的属性。最常用的 Class 方法是 **`getName`， 这个方法将返回类的名字**。例如，下面这条语句：

  ```java
  System.out.println(e.getClass().getName()); // Employee
  ```

  **如果类在一个包里，包的名字也作为类名的一部分**：

  ```java
  Random generator = new Random();
  Class c1 = generator.getClass();
  String name = c1.getName(); // name is set to "java.util .Random"
  ```

  

- 🥈 `Class.forName()`

  还可以调用静态方法 **`forName` 获得类名对应的 Class 对象**。

  ```java
  String className = "java.util.Random";
  Class cl = Class.forName(className);
  ```

  如果类名保存在字符串中， 并可在运行中改变， 就可以使用这个方法。当然， **这个方法只有在 `className` 是类名或接口名时才能够执行**。否则，`forName` 方法将抛出一个 `checked exception` ( 已检查异常）。<u>无论何时使用这个方法， 都应该提供一个异常处理器（ exception handler )</u> 

  > 🚩 在启动时， 包含 main 方法的类被加载。它会加载所有需要的类。这些被加载的类又要加载它们需要的类， 以此类推。对于一个大型的应用程序来说， 这将会消耗很多时 间， 用户会因此感到不耐烦。<u>可以使用下面这个技巧给用户一种启动速度比较快的幻觉</u>。 不过，要确保包含 main 方法的类没有显式地引用其他的类。
  >
  > - 首先，显示一个启动画面； 
  > - 然后，通过调用 `Class.forName` 手工地加载其他的类。

  

- 🥉 `T.class()`

  获得 Class类对象的第三种方法非常简单。如果 `T` 是任意的 Java 类型（或 void 关键字，) `T.class` 将代表匹配的类对象。例如： 

  ```java
  Class cl1 = Random.class; // if you import java.util 
  Class cl2 = int.class; 
  Class cl3 = Double[].class; 
  ```

  请注意，<u>一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如， `int` 不是类， 但 `int.class` 是一个 Class 类型的对象。</u>

<br>

虚拟机为每个类型管理一个 Class 对象。 因此，可以利用 `==` 运算符实现两个类对象比较的操作。 例如， 

```
if(e.getClass() == Employee.getClass())
```

还有一个很有用的方法 **`newInstance()`， 可以用来动态地创建一个类的实例**。例如， 

```java
e.getClass().newInstance(); 
```

创建了一个与 `e` 具有相同类类型的实例。 **`newlnstance`方法调用默认的构造函数（无参构造函数）初始化新创建的对象。如果这个类没有默认的构造函数， 就会抛出一个异常** 

 将 `forName` 与 `newlnstance` 配合起来使用， 可以根据存储在字符串中的类名创建一个对象 :

```java
String s = "java.util .Random"; 
Object m = Class.forName(s).newInstance();
```

### ② 利用反射分析类的能力

下面简要地介绍一下反射机制最重要的内容 — **检查类的结构**。 

在 `java.lang.reflect` 包中有三个类` Field`、 `Method` 和 `Constructor` 分别用于描述类的域、 方法和构造器。 

这三个类都有一个叫做 `getName` 的方法， 用来返回项目的名称。

`Field` 类有一 个 `getType` 方法， 用来返回描述域所属类型的 Class 对象。

`Method `和 `Constructor `类有能够报告参数类型的方法，`Method` 类还有一个可以报告返回类型的方法。

这  3 个类还有一个叫 做 `getModifiers `的方法， 它将返回一个整型数值，用不同的位开关描述 public 和 static 这样 的修饰符使用状况。

另外， 还可以利用 `java.lang.reflect` 包中的 `Modifier`类的静态方法分析 `getModifiers `返回的整型数值。例如， 可以使用 Modifier 类中的 `isPublic`、 `isPrivate `或 `isFinal `判断方法或构造器是否是 public、 private 或 final。 可以利用 `Modifier.toString` 方法将修饰符打印出来。

Class 类的 `getFields`、 ``getMethods` 和 `getConstructors` 方法将分别返回类提供的 public 域、 方法和构造器数组， 其中包括超类的公有成员。

⭐ Class  类的 `getDeclareFields`、 `getDeclareMethods` 和 `getDeclaredConstructors` 方法**将分别返回类中声明的全部域、 方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。**

👇 API 如下：

![](https://gitee.com/veal98/images/raw/master/img/20200619200147.png)

![](https://gitee.com/veal98/images/raw/master/img/20200619200203.png)



### ③ 在运行时使用反射分析对象

从前面一节中， 已经知道如何查看任意对象的数据域名称和类型:

- 获得对应的 Class 对象。 
- 通过 Class 对象调用 getDeclaredFields。

本节将进一步查看数据域的实际内容。当然， 在编写程序时， 如果知道想要査看的域名和类型，查看指定的域是一件很容易的事情。而**利用反射机制可以查看在编译时还不清楚的对象域**。

**查看对象域的关键方法是 Field 类中的 `get` 方法**。如果 `f` 是一个 `Field` 类型的对象（例如， 通过 `getDeclaredFields` 得到的对象) ，`obj` 是某个包含 `f` 域的类的对象，`f.get(obj)` 将返回一个 对象，其值为 obj 域的当前值。**这样说起来显得有点抽象，这里看一看下面这个示例的运行。 

```java
Employee harry = new Employee("Harry Hacker", 35000, 10, 1, 1989); 
Class cl = harry.getClass(); 
Field f = cl.getDeclaredField("name")
Object v = f.get(harry);
```

 ❌ 实际上，这段代码存在一个问题。**由于 `name` 是一个私有域， 所以 get 方法将会抛出一个 `IllegalAccessException`**。只有利用 get 方法才能得到可访问域的值。**除非拥有访问权限**，否则 Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。

为了达到这个目的， 需要调用 Field、 Method 或 Constructor 对象的 `setAccessible` 方法。例如， 

```java
f.setAtcessible(true); // now OK to call f.get(harry);
```

### ④  调用任意方法

在 C 和 C++ 中， 可以从函数指针执行任意函数。从表面上看， Java 没有提供方法指针， 即将一个方法的存储地址传给另外一个方法， 以便第二个方法能够随后调用它。事实上， Java 的设计者曾说过：方法指针是很危险的，并且常常会带来隐患。他们认为 Java 提供的 接口（interface ) (将在下一章讨论）是一种更好的解决方案。然而， **反射机制允许你调用任意方法**。

在 Method 类中有一个 `invoke` 方法， 它允许调用包装在当前 Method 对象中 的方法。i`nvoke` 方法的签名是： 

```java
Object invoke(Object obj, Object... args)
```

 第一个参数是隐式参数， 其余的对象提供了显式参数。

对于静态方法，**第一个参数可以被忽略**， 即可以将它设置为 null。 例如， 假设用 `ml` 代表 `Employee `类的 `getName` 方法，下面这条语句显示了如何调用这个 方法： 

```java
String n = (String) ml.invoke(harry); 
```

如果返回类型是基本类型， `invoke `方法会返回其包装器类型。 例如， 假设 `m2 `表示 `Employee `类的 `getSalary `方法， 那么返回的对象实际上是一个 `Double`, 必须相应地完成类型 转换。可以使用自动拆箱将它转换为一个 double: 

```java
double s = (Double) m2.invoke(harry);
```

❓ 如何得到 `Method `对象呢？ 当然， 可以通过调用 `getDeclareMethods `方法， 然后对返回 的 `Method `对象数组进行查找， 直到发现想要的方法为止。 也可以通过调用 Class 类中的 `getMethod`方法得到想要的方法。然而， **有可能存在若干个相同名字的方法**，因此要格外小心， 以确保能够准确地得到想要的那个方法。**有鉴于此，还必须提供想要的方法的参数类型**。 getMethod 的签名是： 

```java
Method getMethod(String name, Class... parameterTypes)
```

 例如， 下面说明了如何获得 `Employee `类的 `getName `方法和 `raiseSalary `方法的方法指针。

```java
Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary",double.class);
```

### ⑤ 代码实例 ⭐

创建一个我们要使用反射操作的类 `TargetObject`：

```java
package com.smallbeef;

public class TargetObject {
    private String value;

    public TargetObject() {
        value = "Java";
    }

    public void publicMethod(String s) {
        System.out.println("I love " + s);
    }

    private void privateMethod() {
        System.out.println("value is " + value);
    }
}
```

使用反射操作这个类的方法以及参数

```java
package com.smallbeef;

import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import javax.print.attribute.standard.Fidelity;

public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
            InstantiationException, InvocationTargetException, NoSuchFieldException {

        // 获取 TargetObject 类的 Class 对象并创建 TargetObject 类实例
        Class targetClass = Class.forName("com.smallbeef.TargetObject");
        TargetObject targetObject = (TargetObject)targetClass.newInstance();
                
        // 获取所有类中所有定义的方法
        Method[] methods = targetClass.getDeclaredMethods();
        for(Method m: methods){
            System.out.println(m.getName());
        }

        // 调用 publicMethod 方法 （有参）
        Method publicMethod = targetClass.getDeclaredMethod("publicMethod", String.class); // 获取指定方法
        publicMethod.invoke(targetObject, "Computer"); // 传入参数并调用

       // 获取指定参数并对参数进行修改
        Field field = targetClass.getDeclaredField("value");
        // 为了对类中的参数进行修改我们取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "C++");

        // 调用 private 方法 （无参）
        Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
        // 为了调用 private 方法我们取消安全检查
        privateMethod.setAccessible(true);
        privateMethod.invoke(targetObject);
    }
}
```

输出结果：

> publicMethod
>
> privateMethod
>
> I love Computer
>
> value is C++

### ⑥ 反射机制优缺点

**优点**： 动态编译。运行期类型的判断，动态加载类，提高代码灵活度。

**缺点**：

- 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
- 安全问题：让我们可以动态操作改变类的属性同时也增加了类的安全隐患。

### ⑦ 反射的应用场景

**反射是框架设计的灵魂。**

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

举例：

- 我们在使用 JDBC 连接数据库时使用 `Class.forName()`通过反射加载数据库的驱动程序；
- Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；
- 动态配置实例的属性；

## 📚 References

- 《Java 核心技术 - 卷 1 基础知识 - 第 10 版》
- [java经验总结-208道面试题](https://www.zhihu.com/question/27858692/answer/787505434)