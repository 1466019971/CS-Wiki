# ✂ 分治法 Divide and Conquer

---

## 169. 多数元素 

👉 [169. Majority Element — Easy](https://leetcode-cn.com/problems/majority-element/)

- 📜 【 题目描述 】：

    Given an array of size n, **find the majority element**. The majority element is the element that appears **more than ⌊ n/2 ⌋** times.

    You may assume that the array is non-empty and the majority element always exist in the array.

    **Example 1**:

    ```
    Input: [3,2,3]
    Output: 3
    ```

    **Example 2**:

    ```
    Input: [2,2,1,1,1,2,2]
    Output: 2
    ```

- 💡 【 解题思路 】：

  本题题面中没有给出数据范围，但最简单的暴力方法（即枚举数组中的每个元素，再遍历一遍数组统计其出现次数，时间复杂度为 $O(N^2)$ 的算法会超出时间限制，因此我们需要找出时间复杂度小于 $O(N^2)$ 的其他做法。

  采用**分治法**：

  假设数 a 是数组 nums 的众数，**如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数**。

  这样，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，如果 a1 和 a2 相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在**整个区间内**出现的次数来决定该区间的众数。

- ✅ 【 具体代码 】：

  使用经典的**分治算法递归求解**，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917145152.png" style="zoom: 50%;" />

  

  ```java
  class Solution {
  
      // 查找数组中出现次数最多的数（众数）
      private int majorityElementRec(int[] nums, int low, int high) {
          // 如果该数组中只有一个数，返回该数（递归出口)
          if(low == high)
              return nums[low];
  
          // 分治递归
          int mid = (high - low) / 2 + low;
          int left = majorityElementRec(nums, low, mid); // 递归寻找左半部分的众数
          int right = majorityElementRec(nums, mid + 1, high); // 递归寻找右半部分的众数
  
          // 如果左右两部分的众数相同，则该数就是最终结果
          if(left == right)
              return left;
  
          // 如果左右两部分的众数不相同，则选择在整个数组中两者出现次数较多的那个
          int leftCount = countInRange(nums, left, low, high);
          int rightCount = countInRange(nums, right, low, high);
  
          return leftCount > rightCount ? left : right;
      }
  
      // 查找在 nums 数组中，从下标 low 到 high， num 的出现次数
      private int countInRange(int[] nums, int num, int low, int high){
          int count = 0;
          for(int i = low; i <= high; i ++){
              if(nums[i] == num)
                  count ++;
          }
          return count;
  
      }
  
      public int majorityElement(int[] nums){
          return majorityElementRec(nums, 0, nums.length - 1);
      }
  }
  ```

- 🆚 【复杂度分析 】：

  **时间复杂度**：$O(nlogn)$：

  函数 `majorityElementRec` 会求解 2 个长度为 $\dfrac{n}{2}$ 的子问题，并做两遍长度为 n 的线性扫描。因此，分治算法的时间复杂度可以表示为：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917150918.png" style="zoom: 80%;" />

  根据 **主定理**：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200916143502.png" style="zoom: 67%;" />

  $a = 2, b = 2, f(n) = 2n, n^{log_b^a} = n$，显然，$f(n)$ 和 $n^{log_b^a}$ 处于同一个量级，满足第 2 中情况，所以时间复杂度可以表示为：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917151151.png" style="zoom:80%;" />

  **空间复杂度**：$O(\log n)$：

  尽管分治算法没有直接分配额外的数组空间，但<u>在递归的过程中使用了额外的栈空间</u>。算法每次将数组从中间分成两部分，所以数组长度变为 1 之前需要进行 $O(\log n)$ 次递归，即空间复杂度为 $O(\log n)$。

  

## 53. 最大连续子序列和

👉 [53. Maximum Subarray — Easy](https://leetcode-cn.com/problems/maximum-subarray/)

- 📜 【 题目描述 】：

  Given an integer array nums, find the **contiguous (相邻的) subarray (containing at least one number) which has the largest sum** and return its sum.

  Follow up: If you have figured out the O(n) solution, try coding another solution using the **divide and conquer** approach, which is more subtle
  
  **Example 1**:
  
    ```
    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
    Output: 6
    Explanation: [4,-1,2,1] has the largest sum = 6.
    ```
  
    **Example 2**:
  
    ```
    Input: nums = [1]
    Output: 1
    ```
  
    **Example 3**:
  
    ```
    Input: nums = [0]
    Output: 0
    ```
  
    **Example 4**:
  
    ```
    Input: nums = [-1]
    Output: -1
    ```
  
    **Example 5**:
  
    ```
    Input: nums = [-2147483647]
    Output: -2147483647
    ```
  
    **Constraints**:
  
    ```
    1 <= nums.length <= 2 * 104
    -231 <= nums[i] <= 231 - 1
    ```


- 💡 【 解题思路 】：

  我们定义一个操作 `get(a, l, r)` 表示查询 a 序列 `[l, r`] 区间内的最大子段和，那么最终我们要求的答案就是 `get(nums, 0, nums.size() - 1)`。如何分治实现这个操作呢？对于一个区间 `[l, r]`，我们取 $m = \lfloor \frac{l + r}{2} \rfloor$
  	
  对区间 `[l, m]` 和 `[m + 1, r]` 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」即进行合并操作。这个时候我们考虑如何通过 `[l, m]`  区间的信息和 `[m + 1, r]`  区间的信息合并成区间 `[l, r]` 的信息。最关键的两个问题是：

  - 我们要维护区间的哪些信息呢？

  - 我们如何合并这些信息呢？

  对于一个区间 `[l, r]`，我们可以维护四个量：

  - `lSum` 表示 `[l, r]`内以 l 为左端点的最大子段和
  - `rSum `表示 `[l, r]` 内以 r 为右端点的最大子段和
  - `mSum `表示 `[l, r]` 内的最大子段和
  - `iSum `表示 `[l, r]` 的区间和

  举个例子：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917154358.png" style="zoom:67%;" />

  以下简称 `[l, m]` 为 `[l, r]` 的「左子区间」，`[m + 1, r]` 为 `[l, r]` 的「右子区间」。

  - 对于长度为 1 的区间` [i, i]`，四个量的值都和 $a_i$ 相等。

  - 对于长度大于 1 的区间：

  - 首先最好维护的是 `iSum`，区间 `[l, r]` 的 `iSum `就等于「左子区间」的 `iSum `加上「右子区间」的 `iSum`。

    对于` [l, r]` 的 `lSum`，存在两种可能，它要么等于「左子区间」的 `lSum`，要么等于「左子区间」的 iSum 加上「右子区间」的 `lSum`，二者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917154629.png" style="zoom:67%;" />

    对于 ` [l, r]`  的 `rSum`，同理，它要么等于「右子区间」的 `rSum`，要么等于「右子区间」的 iSum 加上「左子区间」的 `rSum`，二者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917154706.png" style="zoom:67%;" />

  

  当计算好上面的三个量之后，就很好计算 ` [l, r]`  的 mSum 了。我们可以考虑 ` [l, r]`  的 mSum 对应的区间是否跨越 m：

  - 它可能不跨越 m，也就是说 ` [l, r]`  的 `mSum `可能是「左子区间」的 `mSum `和 「右子区间」的 `mSum `中的一个；

  - 它也可能跨越 m，可能是「左子区间」的 `rSum `和 「右子区间」的 `lSum `求和。三者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917155138.png" style="zoom:67%;" />

  

- ✅ 【 具体代码 】：

  ```java
  class Solution {
  
      // 区间状态（四个值)
      public class Status {
          public int lSum, rSum, mSum, iSum;
  
          public Status(int lSum, int rSum, int mSum, int iSum) {
              this.lSum = lSum;
              this.rSum = rSum;
              this.mSum = mSum;
              this.iSum = iSum;
          }
      }   
  
      // 分治递归获取各个子区间的状态（四个值）
      public Status getInfo(int[] a, int l, int r){
          if(l == r){ // 递归出口
              return new Status(a[l], a[l], a[l], a[l]);
          }
          int m = (l + r) >> 1; // 位运算比 （l+r)/2 速度快
          Status lSub = getInfo(a, l, m);
          Status rSub = getInfo(a, m + 1, r);
          return pushUp(lSub, rSub); // 根据左右子区间的状态获取整个区间的状态
      }
  
      // 获取整个区间的状态（四个值）
      public Status pushUp(Status l, Status r){
          int iSum = l.iSum + r.iSum;
          int lSum = Math.max(l.lSum, l.iSum + r.lSum);
          int rSum = Math.max(r.rSum, r.iSum + l.rSum);
          // 获取最大连续子序列和（三种情况中的最大值）
          int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
          return new Status(lSum, rSum, mSum, iSum);
      }
  
      public int maxSubArray(int[] nums) {
          return getInfo(nums, 0, nums.length - 1).mSum;
      }
  }
  ```

  

- 🆚 【复杂度分析 】：

  假设序列 a 的长度为 n。

  **时间复杂度**：$O(n)$

  假设我们<u>把递归的过程看作是一颗二叉树的先序遍历</u>，那么这颗二叉树的深度的渐进上界为 $O(logn)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为 O(n)。

  **空间复杂度**：$O(logn)$

  递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。


## 241. 为运算符表达式设计优先级

👉 [241. Different Ways to Add Parentheses(插入语) — Medium](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

- 📜 【 题目描述 】：

  Given a string of numbers and operators, return all possible results from computing all the **different possible ways to group numbers and operators**. The valid operators are `+`, `-` and `*`.

  其实就是为表达式添加括号，改变其运算优先级以求出不同的结果

  **Example 1**:

  ```
  Input: "2-1-1"
  Output: [0, 2]
  Explanation: 
  ((2-1)-1) = 0 
  (2-(1-1)) = 2
  ```

  **Example 2**:

  ```
  Input: "2*3-4*5"
  Output: [-34, -14, -10, -10, 10]
  Explanation: 
  (2*(3-(4*5))) = -34 
  ((2*3)-(4*5)) = -14 
  ((2*(3-4))*5) = -10 
  (2*((3-4)*5)) = -10 
  (((2*3)-4)*5) = 10
  ```

  

- 💡 【 解题思路 】：

  对于一个形如 `x op y`（op 为运算符，x 和 y 为数） 的算式而言，它的结果组合取决于 x 和 y 的结果组合数。因此，该问题的子问题就是 `x op y` 中的 `x1 op x2` 和 `y1 op y2`：**以运算符分隔**的左右两侧算式解。

  然后我们来进行 分治算法三步走：

  - 分解：按运算符分成左右两部分，分别求解

  - 解决：实现一个递归函数，输入算式，返回算式解

  - 合并：根据运算符合并左右两部分的解，得出最终解

  💬 以 `2-1-1` 为例：

  遇见第一个运算符 `-` 进行第一次分治：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200919152820.png" style="zoom:55%;" />

  遇见第二个运算符 `-` 进行第二次分治：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200919152751.png" style="zoom:55%;" />

- ✅ 【 具体代码 】：

  ```java
  class Solution {
  
      // 存储各个字符串对应的不同运算结果的个数
      public Map<String,List<Integer>> resultMap = new HashMap<>();
  
      // 存储输入的input字符串对应的不同运算结果，返回该结果的集合
      public List<Integer> diffWaysToCompute(String input) {
          // 去 map 中查找该输入input是否已经计算存储过，避免重复计算。
          if(resultMap.containsKey(input))
              return resultMap.get(input);
  
          List<Integer> resultList = new ArrayList<>(); // 存储运算结果
  
          int len = input.length();
          for(int i = 0; i < len; i++){
              char c = input.charAt(i); 
              // 如果是运算符号，则递归求解其前半段和后半段。
              if(c == '+' || c == '-' || c == '*'){
                  List<Integer> left = diffWaysToCompute(input.substring(0,i));
                  List<Integer> right = diffWaysToCompute(input.substring(i+1, input.length()));
              
                  // 对左右两侧的结果进行合并
                  for(int l : left) {
                      for(int r : right){
                          switch(c){
                              case '+':
                                  resultList.add(l + r);
                                  break;
                              case '-':
                                  resultList.add(l - r);
                                  break;
                              case '*':
                                  resultList.add(l * r);
                                  break;
                          }
                      }
                  }
              } // if End
          } // for End
  
          // 没有运算符的情况(只有数字)，直接存储该数字即可
          if(resultList.size() == 0)
              resultList.add(Integer.valueOf(input));
  
          resultMap.put(input, resultList);
  
          return resultList;
          
      }
  }
  ```

## 215. 数组中第 K 大的元素

👉 [215. Kth Largest Element in an Array — Medium](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

- 📜 【 题目描述 】：

  Find **the kth largest element** in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

  Example 1:

  ```
  Input: [3,2,1,5,6,4] and k = 2
  Output: 5
  ```


  Example 2:

  ```
  Input: [3,2,3,1,2,4,5,5,6] and k = 4
  Output: 4
  ```

  Note:

  You may assume k is always valid, 1 ≤ k ≤ array's length.

  

- 💡 【 解题思路 】：

  <u>基于快速排序的分治算法</u>：

  快速排序是一个典型的分治算法，快排的核心在于 `partition`（切分）操作，即每一次排序后都会确定一个元素的最终位置，即 x 的最终位置为 j，并且保证 $a[l \cdots j - 1]$ 中的每个元素小于等于 a[j]，且 a[j] 小于等于 $a[j + 1 \cdots r]$ 中的每个元素。

  所以**只要某次划分的 j 为倒数第 k个下标的时候，我们就已经找到了答案**。 我们只关心这一点，至于 $a[l \cdots j - 1]$ 和 $a[j+1 \cdots r]$ 是否是有序的，我们不关心。

  **如果 j 比目标下标小，就递归右子区间，否则递归左子区间**。

  这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200921103938.png" style="zoom: 45%;" />

  

- ✅ 【 具体代码 】：

  ```java
  class Solution {
      public int findKthLargest(int[] nums, int k) {
          int len = nums.length;
          int left = 0;
          int right = len - 1;
  
          int target = len - k; // 第 K 大元素经过排序后的下标
  
          while(true){
              int pivot = partition(nums, left, right);
              if(pivot == target)
                  return nums[pivot];
              else if(pivot < target){
                  left = pivot + 1;
              }
              else
                  right = pivot - 1;
          }
      }
  
      // 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 pivot 排序以后应该在的位置
      private int partition(int[] nums, int left, int right){
          int pivot = nums[left]; // 选择 pivot 为最左边的数
          int j = left;
          for(int i = left + 1; i <= right; i ++){
              if(nums[i] < pivot){
                  // 小于 pivot 的元素都被交换到前面
                  j ++;
                  swap(nums, j, i);
              }
          }
          // 遍历一遍后将 pivot 置于最终位置 j
          swap(nums, j, left);
          return j;
      }
  
      private void swap(int[] nums, int a, int b){
          int temp = nums[a];
          nums[a] = nums[b];
          nums[b] = temp;
      }
  }
  ```

  不过上面的代码是有缺陷的：我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n - 1，每次递归的时候又向 n - 1 的集合中递归，这种情况是最坏的（**顺序数组或者逆序数组**），时间代价是 $O(n ^ 2)$，根本达不到减治的效果。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200921110958.png" style="zoom: 80%;" />

  我们可以引入**随机化**来加速这个过程，它的时间代价的期望是 $O(n)$。

  所谓随机化就是随机 pivot 的取值（并非固定的最左边的数），可以在循环一开始的时候，随机交换第 1 个元素（最左边的元素）与它后面的任意 1 个元素的位置：

  ```java
  import java.util.Random;
  
  class Solution {
  
      private static Random random = new Random(System.currentTimeMillis());
  
      public int findKthLargest(int[] nums, int k) {
          int len = nums.length;
          int left = 0;
          int right = len - 1;
  
          int target = len - k; // 第 K 大元素经过排序后的下标
  
          while(true){
              int pivot = partition(nums, left, right);
              if(pivot == target)
                  return nums[pivot];
              else if(pivot < target){
                  left = pivot + 1;
              }
              else
                  right = pivot - 1;
          }
      }
  
      // 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 pivot 排序以后应该在的位置
      private int partition(int[] nums, int left, int right){
          // 在区间随机选择一个元素作为标定点
          if(right > left){
              int randomIndex = left + 1 + random.nextInt(right - left);
              swap(nums, left, randomIndex);
          }
  
          int pivot = nums[left]; // 选择 pivot 为最左边的数
          int j = left;
          for(int i = left + 1; i <= right; i ++){
              if(nums[i] < pivot){
                  // 小于 pivot 的元素都被交换到前面
                  j ++;
                  swap(nums, j, i);
              }
          }
          // 遍历一遍后将 pivot 置于最终位置 j
          swap(nums, j, left);
          return j;
      }
  
      private void swap(int[] nums, int a, int b){
          int temp = nums[a];
          nums[a] = nums[b];
          nums[b] = temp;
      }
  }
  ```

  OK，时间复杂度大大降低了：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200921111033.png" style="zoom:80%;" />

## 📚 References

- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)