# ✂ 分治法 Divide and Conquer

---

## 169. 多数元素

👉 [169. Majority Element](https://leetcode-cn.com/problems/majority-element/)

- 📜 【 题目描述 】：

    Given an array of size n, **find the majority element**. The majority element is the element that appears **more than ⌊ n/2 ⌋** times.

    You may assume that the array is non-empty and the majority element always exist in the array.

    **Example 1**:

    ```
    Input: [3,2,3]
    Output: 3
    ```

    **Example 2**:

    ```
    Input: [2,2,1,1,1,2,2]
    Output: 2
    ```

- 💡 【 解题思路 】：

  本题题面中没有给出数据范围，但最简单的暴力方法（即枚举数组中的每个元素，再遍历一遍数组统计其出现次数，时间复杂度为 $O(N^2)$ 的算法会超出时间限制，因此我们需要找出时间复杂度小于 $O(N^2)$ 的其他做法。

  采用**分治法**：

  假设数 a 是数组 nums 的众数，**如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数**。

  这样，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，如果 a1 和 a2 相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在**整个区间内**出现的次数来决定该区间的众数。

- ✅ 【 具体代码 】：

  使用经典的**分治算法递归求解**，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917145152.png" style="zoom: 50%;" />

  

  ```java
  class Solution {
  
      // 查找数组中出现次数最多的数（众数）
      private int majorityElementRec(int[] nums, int low, int high) {
          // 如果该数组中只有一个数，返回该数（递归出口)
          if(low == high)
              return nums[low];
  
          // 分治递归
          int mid = (high - low) / 2 + low;
          int left = majorityElementRec(nums, low, mid); // 递归寻找左半部分的众数
          int right = majorityElementRec(nums, mid + 1, high); // 递归寻找右半部分的众数
  
          // 如果左右两部分的众数相同，则该数就是最终结果
          if(left == right)
              return left;
  
          // 如果左右两部分的众数不相同，则选择在整个数组中两者出现次数较多的那个
          int leftCount = countInRange(nums, left, low, high);
          int rightCount = countInRange(nums, right, low, high);
  
          return leftCount > rightCount ? left : right;
      }
  
      // 查找在 nums 数组中，从下标 low 到 high， num 的出现次数
      private int countInRange(int[] nums, int num, int low, int high){
          int count = 0;
          for(int i = low; i <= high; i ++){
              if(nums[i] == num)
                  count ++;
          }
          return count;
  
      }
  
      public int majorityElement(int[] nums){
          return majorityElementRec(nums, 0, nums.length - 1);
      }
  }
  ```

- 🆚 【复杂度分析 】：

  **时间复杂度**：$O(nlogn)$：

  函数 `majorityElementRec` 会求解 2 个长度为 $\dfrac{n}{2}$ 的子问题，并做两遍长度为 n 的线性扫描。因此，分治算法的时间复杂度可以表示为：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917150918.png" style="zoom: 80%;" />

  根据 **主定理**：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200916143502.png" style="zoom: 67%;" />

  $a = 2, b = 2, f(n) = 2n, n^{log_b^a} = n$，显然，$f(n)$ 和 $n^{log_b^a}$ 处于同一个量级，满足第 2 中情况，所以时间复杂度可以表示为：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917151151.png" style="zoom:80%;" />

  **空间复杂度**：$O(\log n)$：

  尽管分治算法没有直接分配额外的数组空间，但<u>在递归的过程中使用了额外的栈空间</u>。算法每次将数组从中间分成两部分，所以数组长度变为 1 之前需要进行 $O(\log n)$ 次递归，即空间复杂度为 $O(\log n)$。

  

## 53. 最大连续子序列和

👉 [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)

- 📜 【 题目描述 】：

  Given an integer array nums, find the **contiguous (相邻的) subarray (containing at least one number) which has the largest sum** and return its sum.

  Follow up: If you have figured out the O(n) solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

   

  **Example 1**:

  ```
  Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
  Output: 6
  Explanation: [4,-1,2,1] has the largest sum = 6.
  ```

  **Example 2**:

  ```
  Input: nums = [1]
  Output: 1
  ```

  **Example 3**:

  ```
  Input: nums = [0]
  Output: 0
  ```

  **Example 4**:

  ```
  Input: nums = [-1]
  Output: -1
  ```

  **Example 5**:

  ```
  Input: nums = [-2147483647]
  Output: -2147483647
  ```

  **Constraints**:

  ```
  1 <= nums.length <= 2 * 104
  -231 <= nums[i] <= 231 - 1
  ```

  

- 💡 【 解题思路 】：

  我们定义一个操作 `get(a, l, r)` 表示查询 a 序列 `[l, r`] 区间内的最大子段和，那么最终我们要求的答案就是 `get(nums, 0, nums.size() - 1)`。如何分治实现这个操作呢？对于一个区间 `[l, r]`，我们取 $m = \lfloor \frac{l + r}{2} \rfloor$
  	
  对区间 `[l, m]` 和 `[m + 1, r]` 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」即进行合并操作。这个时候我们考虑如何通过 `[l, m]`  区间的信息和 `[m + 1, r]`  区间的信息合并成区间 `[l, r]` 的信息。最关键的两个问题是：

  - 我们要维护区间的哪些信息呢？

  - 我们如何合并这些信息呢？

  对于一个区间 `[l, r]`，我们可以维护四个量：

  - `lSum` 表示 `[l, r]`内以 l 为左端点的最大子段和
  - `rSum `表示 `[l, r]` 内以 r 为右端点的最大子段和
  - `mSum `表示 `[l, r]` 内的最大子段和
  - `iSum `表示 `[l, r]` 的区间和

  举个例子：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200917154358.png" style="zoom:67%;" />

  以下简称 `[l, m]` 为 `[l, r]` 的「左子区间」，`[m + 1, r]` 为 `[l, r]` 的「右子区间」。

  - 对于长度为 1 的区间` [i, i]`，四个量的值都和 $a_i$ 相等。

  - 对于长度大于 1 的区间：

  - 首先最好维护的是 `iSum`，区间 `[l, r]` 的 `iSum `就等于「左子区间」的 `iSum `加上「右子区间」的 `iSum`。

    对于` [l, r]` 的 `lSum`，存在两种可能，它要么等于「左子区间」的 `lSum`，要么等于「左子区间」的 iSum 加上「右子区间」的 `lSum`，二者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917154629.png" style="zoom:67%;" />

    对于 ` [l, r]`  的 `rSum`，同理，它要么等于「右子区间」的 `rSum`，要么等于「右子区间」的 iSum 加上「左子区间」的 `rSum`，二者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917154706.png" style="zoom:67%;" />

  

  当计算好上面的三个量之后，就很好计算 ` [l, r]`  的 mSum 了。我们可以考虑 ` [l, r]`  的 mSum 对应的区间是否跨越 m：

  - 它可能不跨越 m，也就是说 ` [l, r]`  的 `mSum `可能是「左子区间」的 `mSum `和 「右子区间」的 `mSum `中的一个；

  - 它也可能跨越 m，可能是「左子区间」的 `rSum `和 「右子区间」的 `lSum `求和。三者取大。

    <img src="https://gitee.com/veal98/images/raw/master/img/20200917155138.png" style="zoom:67%;" />

  

- ✅ 【 具体代码 】：

  ```java
  class Solution {
  
      // 区间状态（四个值)
      public class Status {
          public int lSum, rSum, mSum, iSum;
  
          public Status(int lSum, int rSum, int mSum, int iSum) {
              this.lSum = lSum;
              this.rSum = rSum;
              this.mSum = mSum;
              this.iSum = iSum;
          }
      }   
  
      // 分治递归获取各个子区间的状态（四个值）
      public Status getInfo(int[] a, int l, int r){
          if(l == r){ // 递归出口
              return new Status(a[l], a[l], a[l], a[l]);
          }
          int m = (l + r) >> 1; // 位运算比 （l+r)/2 速度快
          Status lSub = getInfo(a, l, m);
          Status rSub = getInfo(a, m + 1, r);
          return pushUp(lSub, rSub); // 根据左右子区间的状态获取整个区间的状态
      }
  
      // 获取整个区间的状态（四个值）
      public Status pushUp(Status l, Status r){
          int iSum = l.iSum + r.iSum;
          int lSum = Math.max(l.lSum, l.iSum + r.lSum);
          int rSum = Math.max(r.rSum, r.iSum + l.rSum);
          // 获取最大连续子序列和（三种情况中的最大值）
          int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
          return new Status(lSum, rSum, mSum, iSum);
      }
  
      public int maxSubArray(int[] nums) {
          return getInfo(nums, 0, nums.length - 1).mSum;
      }
  }
  ```

  

- 🆚 【复杂度分析 】：

  假设序列 a 的长度为 n。

  **时间复杂度**：$O(n)$

  假设我们<u>把递归的过程看作是一颗二叉树的先序遍历</u>，那么这颗二叉树的深度的渐进上界为 $O(logn)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为 O(n)。

  **空间复杂度**：$O(logn)$

  递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。

  