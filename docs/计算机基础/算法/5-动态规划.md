# 🌳 动态规划 Dynamic Programming

---

## 1. 基本思想

**动态规划算法与分治法类似，其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，再结合这些子问题的解得到原问题的解。**

与分治法不同的是，**适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的**。若用分治法来解这类问题，则分解得到的子问题数目太多，以至最后解决原问题需要耗费指数级时间。

**动态规划问题的一般形式就是求最值**。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要<u>「备忘录」</u>或者<u>「辅助表 DP table」</u>来记录所有已解决的子问题的答案，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。<u>在实际的算法问题中，**写出状态转移方程是最困难的**。</u>

⭐ 动态规划算法适用于最优化问题，通常有以下 4 个步骤：

- ① 找出最优解的性质，并刻画其结构特征（最优子结构）
- ② 递归地定义最优值（状态转移方程）
- ③ 以自底向上的方式计算最优值
- ④ 根据计算最优值时得到的信息，构造最优解（若不需要最优解则第 ④ 步可省略）

## 2. 引例：矩阵连乘问题

**【问题描述】**：给定 n 个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。

例如，给定三个连乘矩阵{A1，A2，A3}的维数分别是 $10*100$，$100*5$和$5*50$，采用$(A1A2)A3$，乘法次数为$10*100*5+10*5*50=7500次$，而采用$A1(A2A3)$，乘法次数为$100*5*50+10*100*50=75000次$乘法，显然，最好的次序是$(A1A2)A3$，乘法次数为7500次。

首先考虑计算两个矩阵乘积所需的计算量。假设 A 是 $p * q$ 的矩阵，B 是 $q * r$ 的矩阵，则 C = AB 是一个 $p * r$ 的矩阵，一共需要 $p * q * r$ 次数乘。在计算多个矩阵的连乘的时候，不同的加括号方式对整个计算量来说具有很大的影响。下面我们用动态规划法来求解该问题：

### ① 分解最优解的结构 (最优子结构)

该问题符合【最优子结构】：

<img src="https://gitee.com/veal98/images/raw/master/img/20201003205948.png" style="zoom: 55%;" />

### ② 递归定义最优值 (状态转移方程)

<img src="https://gitee.com/veal98/images/raw/master/img/20201003210401.png" style="zoom: 40%;" />

**辅助表 `m[i][j]` 记录了最优值，即计算 `A[i:j]` 所需的最少数乘次数**。同时确定了计算 `A[i:j]` 的最优次序中的断开位置 `k`。

若将对应 `m[i:j]` 的断开位置 `k` 记为 `s[i][j]`，则在计算出最优质 `m[i][j]` 后，可递归地由 `s[i][j]` 构造出相应的最优解。

### ③ 自底向上计算最优值

由上一步的递归式可以看出，递归的过程中会出现很多的**重复子问题**。可以用两个  `n * n` 维的辅助表：

- `m[n][n]`  表示最优乘积代价（最少数乘次数）
- `s[n][n]`  表示每个子问题的最优分割位置 k

对于一组矩阵: $A1(30*35),A2(35*15),A3(15*5),A4(5*10),A5(10*20),A6(20*25)  $ ，个数 n = 6

那么 p 数组保存它们的行数和列数：$p={30,35,15,5,10,20,25}$，共有 n+1 即 7 个元素

`p[0], p[1]` 分别代表第一个矩阵的行数和列数，`p[1],p[2]` 分别代表第二个矩阵的行数和列数...... `p[5],p[6]` 代表第六个矩阵的行数和列数

> 🔗 下图来源 [动态规划算法之矩阵连乘问题思路](https://blog.csdn.net/qq_32919451/article/details/80643118)

![](https://gitee.com/veal98/images/raw/master/img/20201004105239.png)

⭐ 辅助表 `s[n][n]` 可以由 2 种方法构造（下节会详细讲解）：

- 一种是**自底向上（动态规划算法）**构建，该方法要求按照递增的方式逐步填写子问题的解，也就是先计算 2 个矩阵连乘的最优分割位置，然后计算 3 个矩阵连乘的最优分割位置，直到长度 n；
- 另一种是**自顶向下（备忘录法）**，该方法将表的每个元素初始化为某特殊值(本问题中可以将最优乘积代价设置为一极大值)，以表示待计算，在递归的过程中逐个填入遇到的子问题的解。

<u>采用动态规划自底向上的方式，则计算顺序为</u>：

![](https://gitee.com/veal98/images/raw/master/img/20201004105431.png)：

辅助表 `m[i][j]`代表从矩阵 $A_i，A_{i+1}，A_{i+2}......$ 直到矩阵 $A_j$ 连乘的最小的相乘次数，比如 `m[2][5]` 代表矩阵 `A2 A3 A4 A5` 最小的相乘次数，即最优的乘积代价。我们看上图，从矩阵 A2 到 A5 有三种断链方式：`A2{A3A4A5}`、`{A2A3}{A4A5}`、`{A2A3A4}A5`，我们分别算出这三个不同断链方式的总乘积次数，然后选出最小的一个，就是 `m[2][5]` 的值。同时保留断开的位置 k 在 `s[2][5]` 数组中。

<img src="https://gitee.com/veal98/images/raw/master/img/20201004110056.png" style="zoom: 50%;" />

即 `m[2][5] = 7125, s[2][5] = 3`

```java
// p 存储矩阵的行列数
// n 表示一共多少个矩阵
// m 数组存储每个子问题的最优值(计算量)
// s 数组存储每个子问题的最优断开位置
public void MatixChain(int[] p, int n, int[][] m, int[][] s){

    // m[i][i]只有一个矩阵，所以相乘次数为0，即 m[i][i] = 0;
    for(int i = 1; i <= n; i ++)
        m[i][i] = 0; 

    // r 表示矩阵链的长度（r 个矩阵相乘）
    for(int r = 2; r <= n; r ++){
        for(int i = 1; i <= n-r+1; i ++){
            // 以 i 为起始位置，j 为长度为 n 的矩阵链的末位
            int j = i + r - 1;
            // 将链 A[i:j] 划分为 A(i) * ( A[i+1:j] ) 
            m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j];
            s[i][j] = i; // 初始化断开点位置

            // 将链 A[i:j] 划分为 A[i:k] * A[k+1:j]
            for(int k = i + 1; k < j; k ++){
                int temp = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                if(temp < m[i][j]){
                    m[i][j] = temp; // 更新最优值
                    s[i][j] = k; // 更新断开点位置
                }
            }
        }
    }
}
```

至此，我们比计算出来矩阵连乘的最少数乘次数，接下来我们需要计算什么样的的计算次序能够达到此最少数乘次数 👇

### ④ 构造最优计算次序

<img src="https://gitee.com/veal98/images/raw/master/img/20201003214047.png" style="zoom:40%;" />

```java
// 返回 s 数组 i~j 范围内的最优值
public void Traceback(int i, int j, int[][] s){
    if(i == j)
       return ;
    Traceback(i, s[i][j], s);
    Traceback(s[i][j]+1, j, s);
    System.out.println("Multiply  A" + i + "," + s[i][j] + " and A" + (s[i][j] + 1) + "," + j);
}
```

要输出 `A[1:n]` 的最优计算次序只需要调用  `Traceback(1,n,s)` 即可。

### ⑤ 完整程序 (Java)

整合一下上述代码段，将其写成一个完整的程序：

```java

public class Matrix {
    
    private static int n = 6; // 表示一共 n 个矩阵
    private  int[] p; // 存储矩阵的行列数
    private  int[][] m; // 存储每个子问题的最优值(计算量)
    private  int[][] s; // 存储每个子问题的最优断开位置

    public Matrix(){
        p = new int[]{30, 35, 15, 5, 10, 20, 25};
        m = new int[n+1][n+1];
        s = new int[n+1][n+1];
    }
	
    // 核心算法（状态转移方程）
    public void MatixChain(){

        // m[i][i]只有一个矩阵，所以相乘次数为0，即 m[i][i] = 0;
        for(int i = 1; i <= n; i ++)
            m[i][i] = 0; 
        
        // r 表示矩阵链的长度（r 个矩阵相乘）
        for(int r = 2; r <= n; r ++){
            for(int i = 1; i <= n-r+1; i ++){
                // 以 i 为起始位置，j 为长度为 n 的矩阵链的末位
                int j = i + r - 1;
                // 将链 A[i:j] 划分为 A(i) * ( A[i+1:j] ) 
                m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j];
                s[i][j] = i; // 初始化断开点位置
                
                // 将链 A[i:j] 划分为 A[i:k] * A[k+1:j]
                for(int k = i + 1; k < j; k ++){
                    int temp = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                    if(temp < m[i][j]){
                        m[i][j] = temp; // 更新最优值
                        s[i][j] = k; // 更新断开点位置
                    }
                }
            }
        }
    }

    // 返回 s 数组 i~j 范围内的最优值
    public void Traceback(int i, int j){
        if(i == j)
           return ;
        Traceback(i, s[i][j]);
        Traceback(s[i][j]+1, j);
        System.out.println("Multiply  A" + i + "," + s[i][j] + " and A" + (s[i][j] + 1) + "," + j);
    }

    public static void main(String[] args){
        Matrix matrix = new Matrix();
        matrix.MatixChain();
        matrix.Traceback(1, n);
    }
}
```

## 3. 动态规划算法的基本要素

动态规划算法的有效性依赖于问题本身所具有的两个重要性质：

- 最优子结构
- 子问题重叠性质

### ① 最优子结构

**当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质**。 

问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。

举个例子：给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

比如说 `k = 3`，面值分别为 1，2，5，总金额 `amount = 11`。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

上述问题就符合最优子结构。比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。

### ② 重叠子问题

在用递归算法自顶向下计算该问题时，每次产生的子问题并不总是新的问题，有些子问题被反复计算。以上面的矩阵连乘为例，我们直接使用递归计算 `A[i:j]` 的最小数乘次数：

```java
// 递归求解矩阵连乘最少次数
public int RecurMatirxChain(int i, int j){
    if(i == j)
        return 0;
    int u = RecurMatirxChain(i,i) + RecurMatirxChain(i+1,j) + p[i-1] * p[i] * p[j];
    s[i][j] = i;
    for(int k = i + 1; k < j; k ++){
        int t = RecurMatirxChain(i,k) + RecurMatirxChain(k+1,j) + p[i-1] * p[k] * p[j];
        if(t < u){
            u = t;
            s[i][j] = k;
        }
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20201004145544.png" style="zoom:40%;" />

可以证明该算法的计算时间 T(n) 具有指数下界：

<img src="https://gitee.com/veal98/images/raw/master/img/20201004151112.png" style="zoom:40%;" />

有两种方法可以解决重叠子问题带来的问题 👇

#### Ⅰ 自底向上（动态规划）

如上面的解法，动态规划算法正是利用了这种子问题的重叠性质，对每个子问题只求解一次，然后**按照递增（自底向上）的方式逐步将子问题的解存储在辅助表内**，当再次需要解此问题时，查找该辅助表即可。

> 💡 **自底向上**：注意上图 3-2 的递归树（或者说图）。动态规划算法就是从问题规模最小的基本情况（base case）比如 `A[2:2]` 开始逐层往上推导，直到我们想要的上层答案比如 `A[1:4]`。这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

**相比于直接递归的指数级时间复杂度，动态规划的主要计算量取决于程序中的三重循环，时间复杂度只有 $O(n^3)$**

#### Ⅱ 自顶向下（备忘录法）

💉 **备忘录方法是动态规划算法的变形**。与动态规划算法一样，备忘录法需要使用辅助表存储已解决的子问题的答案。不同的是，**动态规划算法是自底向上递归的，而备忘录法是自顶向下递归的**。因此，**备忘录法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以便需要时查看**。

> 💡 **自顶向下**：注意上图 3-2 的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题向下逐渐分解规模，直到类似于 `A[2: 2]` 这种基本情况 (base case)，然后自底层逐层向上返回答案，这就叫「自顶向下」。

💧 **备忘录方法为每个子问题建立一个记录项，并将其初始化为某个特殊的值，表示该子问题尚未求解。在递归的过程中，对每个待求的子问题，首先查找对应的记录项**，若为初始值，则表示该子问题是第一次遇到，则计算出该子问题的解并存储在对应的记录项中，以便需要时查看。

以矩阵连乘问题为例，备忘录方法的代码如下：

```java
// 备忘录
public int MemoizeMatirxChain(int n, int[][] m, int[][] s){
    for(int i = 1; i <= n; i++){
        for(int j = i; j <= n; j++){
            m[i][j] = 0; // 初始化备忘录
        }
        return LookupChain(1, n);
    }
}

public int LookupChain(int i, int j){
    if(m[i][j] > 0)
        return m[i][j];
    if(i == j)
        return 0;
    int u = LookupChain(i,i) + LookupChain(i+1,j) + p[i-1] * p[i] * p[j];
    s[i][j] = i;
    for(int k = i + 1; k < j; k ++){
        int t = LookupChain(i,k) + LookupChain(k+1,j) + p[i-1] * p[k] * p[j];
        if(t < u){
            u = t;
            s[i][j] = k;
        }
    }
    m[i][j] = u; // 更新备忘录
    return u;
}
```

显然，大家也能看出来，😊 <u>备忘录算法不过就是在直接递归算法的基础上加入了一个用来记忆的数组罢了</u>。

对于上述代码，**备忘录算法的时间复杂度和动态规划一样**同为 $O(n^3)$：共有 $O(n^2)$ 个备忘录项 `m[n][n]`，这些记录项的初始化时间为 $O(n^2)$，每个记录项值填入一次，共耗费 $O(n)$ 时间，因此，备忘录算法填入 $O(n^2)$ 个记录项总共耗费 $O(n^3)$ 的计算时间。

#### Ⅲ 两种方法的比较

一般来讲：

- 当一个问题的所有子问题都需要至少求解一次时，用动态规划算法比用备忘录方法好。

- 当部分子问题可不必求解时，用备忘录方法则比较有利，因此从其控制结构来说，该方法只解决那些确实需要求解的问题。

## 4. 实例：最长公共子序列 LCS

下面我们来看一个完整的动态规划问题的解题流程 👇

**【问题描述】**：

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列 (`Longest Common Subsequence, LCS`) 的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```


示例 2:

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```


示例 3:

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

下面按照动态规划算法的设计步骤来解决此问题 👇

### ① 分解最优解的结构 (最优子结构)

<img src="https://gitee.com/veal98/images/raw/master/img/20201004154015.png" style="zoom:42%;" />

由此可见，**两个序列的最长公共子序列必然包含着这两个序列的前缀的最长公共子序列**。举个例子：

比如：text1 = "abcde"，text2 = "abqcwe"

取 text1 前面某些部分 "abc"，取 text2 前面某个部分"abqc"，那么这两个子序列的最长公共子序列为 "abc"

显然 text1 和 text2 的最长公共子序列 "abce" 是包含 "abc" 的

### ② 递归定义最优值 (状态转移方程)

<img src="https://gitee.com/veal98/images/raw/master/img/20201004155021.png" style="zoom:42%;" />

比如说对于字符串 `b a b c d e` 和字符串 `a c e` 构造一个辅助表 c：

<img src="https://gitee.com/veal98/images/raw/master/img/20201004212648.png" style="zoom:60%;" />

其中，`c[i][j]` 的含义是：对于 `s1[1..i]` 和 `s2[1..j]`，它们的最长公共子序列长度是 `c[i][j]`。比如上图的例子，`c[2][4]` 的含义就是：对于 `"ac"` 和 `"babc"`，它们的最长公共子序列长度是 2。**我们最终想得到的答案应该是 `c[3][6]`**。

注意，**我们在辅助表的外围加了一圈 0（第 0 行和第 0 列不用）**，方便计算。比如 `c[0][3]=0` 的含义是：对于字符串 `""` 和 `"bab"`，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。

```java
// m 是第一个序列的长度，n 是第二个序列的长度
// 由于我们辅助表的第 0 行和第 0 列不用，所以需要 new int[m+1][n+1]
int[][] c = new int[m+1][n+1];
```

### ③ 自底向上计算最优值

计算最长公共子序列的长度：

```java
/**
 * @param m 序列 x 的个数：X_1, X_2 ...  X_m
 * @param n 序列 y 的个数：Y_1, Y_2 ...  Y_n
 * @param x 序列 x
 * @param y 序列 y
 * @param c c[i][j] 存储 X_i 和 Y_j 的最长公共子序列的长度
 * @param b b[i][j] 记录 c[i][j] 的值是由哪个子问题的解得到的
 */
public void LCSlength(int m, int n, char[] x, char[] y, int[][] c, int[][] b){
    // 初始化辅助表的第一列
    for(int i = 1; i <= m; i ++){
        c[i][0] = 0;
    }
    // 初始化辅助表的第一行
    for(int i = 1; i <= n; i++){
        c[0][i] = 0;
    }

    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            // 注意一下这个地方, 因为我们在辅助表的外围加了一圈 0
            // 所以对应于字符串的下标需要相应的 - 1，看一下上面的图就明白了
            if(x[i-1] == y[j-1]){ // 情况 1
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = 1;
            }
            // 取较大值为最大公共子序列长度
            else if(c[i-1][j] >= c[i][j-1]){  // 情况 2
                c[i][j] = c[i-1][j];
                b[i][j] = 2;
            }
            else{ // c[i][j-1] > c[i-1][j])  情况 3 
                c[i][j] = c[i][j-1];
                b[i][j] = 3;
            }
        }
    }
}
```

> 💡 上面两段初始化辅助表的过程其实是可以省略的，因为 new 的时候就已经初始成 0 了。

⏰ 上述代码的时间复杂度主要在于两个 for 循环，因此算法 `LCSLength` 时间复杂度为 `O(mn)`

#### 状态压缩

**如果只需要计算最长公共子序列的长度，则上述算法还能够继续优化**。我们在计算 `c[i][j]` 的时候，只用到数组 c 的第 i 行和 第 i-1 行，只需要用两行的数组空间就可以计算出最长公共子序列的长度。

💡 **这就是状态压缩的技巧。也就是说我们发现每次状态转移只需要辅助表 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，从而实现进一步减少空间复杂度**

<img src="https://gitee.com/veal98/images/raw/master/img/20201006120306.png" style="zoom: 45%;" />

准备几个变量：

- `last`:表示是当前 `dp[j](dp[i][j])` 左上角的数，相当于 `dp[i-1][j-1]` ,初始化的时候为 0
- `temp`:表示是当前 `dp[j](dp[i][j])` 正上方的数，相当于 `dp[i- 1][j]` 
- `c[j-1]`:表示是当前 `dp[j](dp[i][j])` 左边的数，相当于 `dp[i][j-1]`
- 每一轮结束后，`last `的值都向前滚动一个，变成正上方的数，也就是 `temp`

之前的状态转移方程为：

`c[i][j] = 0 / c[i-1][j-1] + 1 / max{ c[i][j-1] | c[i-1][j] }`

转换为：

`c[j] = 0 / last + 1 / max{ c[j-1] | temp }`

代码如下：

```java

// 计算最长公共子序列的长度
public void LCSlength(char[] x, char[] y){
    int m = x.length;
    int n = y.length;
    int[] c = new int[n+1]; // 辅助数组
    int temp = 0;
    for(int i = 1; i <= m; i ++){
        int last = 0;
        for(int j = 1; j <= n; j++){
            temp = c[j];
            if(x.charAt(i-1) == y.charAt(j-1))
                c[j] = last + 1;
            else if(temp >= c[j-1])
                c[j] = temp;
            else
                c[j] = c[j-1];
            last = temp;
        }
    }
    return c[n];
}

```

空间复杂度降至 `O(min{m,n})`

### ④ 构造最长公共子序列

根据上述代码算出的 `b[i][j]`，我们开始构造最长公共子序列：

```java
/**
 * @param i X_1, X_2 ... X_i
 * @param j Y_1, Y_2 ... Y_j
 * @param x 序列 X（这里我们传入一个序列用来输出公共子序列，X Y 随便哪个都可以）
 * @param b 由 LCSlength 计算出来的 b[i][j]，表示 i 到 j 范围的子问题属于哪种情况
 */
public void LCS(int i, int j, char[] x, int[][] b){

    if(i == 0 || j == 0)
        return ;
    if(b[i][j] == 1){
        LCS(i-1, j-1, x, b);
        System.out.println(x[i-1]);
    }
    else if(b[i][j] == 2){
        LCS(i-1, j, x, b);
    }
    else{
        LCS(i, j-1, x, b);
    }
}
```

⏰ 每次递归调用使 `i` 或 `j` 减 1，因此算法 `LCS` 时间复杂度为 `O(m+n)`

### ⑤ 完整程序 (Java)

整理一下上述代码，将其写成一个完整的程序：

```java
public class LCSTest {

    private char[] x; // 序列 X
    private char[] y; // 序列 Y
    private int m; // 序列 X 的长度（字符个数）
    private int n; // 序列 Y 的长度
    private int[][] c; // c[i][j] 存储 X_i 和 Y_j 的最长公共子序列的长度
    private int[][] b; // b[i][j] 记录 c[i][j] 的值是由哪个子问题的解得到的

    public LCSTest(){
        x = new char[]{'a', 'b', 'c', 'd', 'f','e'};
        y = new char[]{'a', 'c', 'f', 'e'};
        m = x.length;
        n = y.length;
        b = new int[m+1][n+1];
        c = new int[m+1][n+1];
    }

    public static void main(String[] args){
        LCSTest lcsTest = new LCSTest();
        lcsTest.LCSlength();
        lcsTest.LCS(lcsTest.m, lcsTest.n);
    }
	
    // 核心算法（状态转移方程）
    public void LCSlength(){
        
        // 初始化的代码可以省略~

        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(x[i-1] == y[j-1]){ // 情况 1
                    c[i][j] = c[i-1][j-1] + 1;
                    b[i][j] = 1;
                }
                // 取较大值为最大公共子序列长度
                else if(c[i-1][j] >= c[i][j-1]){  // 情况 2
                    c[i][j] = c[i-1][j];
                    b[i][j] = 2;
                }
                else{ // c[i][j-1] > c[i-1][j])  情况 3 
                    c[i][j] = c[i][j-1];
                    b[i][j] = 3;
                }
            }
        }
    }
    /**
     * @param i X_1, X_2 ... X_i
     * @param j Y_1, Y_2 ... Y_j
     */
    public void LCS(int i, int j){

        if(i == 0 || j == 0)
            return ;
        if(b[i][j] == 1){
            LCS(i-1, j-1);
            System.out.println(x[i-1]); // 这里我们传入一个序列用来输出公共子序列，X Y 随便哪个都可以
        }
        else if(b[i][j] == 2){
            LCS(i-1, j);
        }
        else{
            LCS(i, j-1);
        }
    }   
}
```

## ✍ 动态规划对应的 LeetCode

- 😎 [1025 - 除数博弈](计算机基础/算法/LeetCode/动态规划/1025-除数博弈.md)
- 😎 [303 - 区域和检索 - 数组不可变](计算机基础/算法/LeetCode/动态规划/303-区域和检索-数组不可变.md)
- 😎 [53 - 最大连续子序列和](计算机基础/算法/LeetCode/动态规划/53-最大连续子序列和.md)
- 👻 [1143 - 最长公共子序列](计算机基础/算法/LeetCode/动态规划/1143-最长公共子序列.md)

## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)
- [动态规划算法之矩阵连乘问题思路](https://blog.csdn.net/qq_32919451/article/details/80643118)
- [动态规划---矩阵连乘问题](https://blog.csdn.net/qq_22238021/article/details/78859946?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)