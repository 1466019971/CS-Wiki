# 🌳 动态规划

---

## 1. 基本思想

**动态规划算法与分治法类似，其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，再结合这些子问题的解得到原问题的解。**

与分治法不同的是，适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，以至最后解决原问题需要耗费指数级时间。

在用分治法求解时，有些子问题被重复计算了多次，为了能够保存已解决的子问题的答案，可以**用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否会用到，只要它被计算过，就将其结果填入表中**。这就是动态规划的基本思想。

动态规划算法适用于最优化问题，通常有以下 4 个步骤：

- ① 找出最优解的性质，并刻画其结构特征
- ② 递归地定义最优值
- ③ 以自底向上的方式计算最优值
- ④ 根据计算最优值时得到的信息，构造最优解

## 2. 矩阵连乘问题

<img src="https://gitee.com/veal98/images/raw/master/img/20201003203045.png" style="zoom: 55%;" />

首先考虑计算两个矩阵乘积所需的计算量。假设 A 是 $p * q$ 的矩阵，B 是 $q * r$ 的矩阵，则 C = AB 是一个 $p * r$ 的矩阵，一共需要 $p * q * r$ 次数乘。在计算多个矩阵的连乘的时候，不同的加括号方式对整个计算量来说具有很大的影响。下面我们用动态规划法来求解该问题：

### ① 分解最优解的结构

<img src="https://gitee.com/veal98/images/raw/master/img/20201003205948.png" style="zoom: 55%;" />

因此，矩阵连乘计算次序**问题的最优解包含着其子问题的最优解**，这种性质称为**最优子结构性质**。<u>问题的最优子结构性质是该问题可用于动态规划算法求解的显著特征。</u>

### ② 递归定义最优值

<img src="https://gitee.com/veal98/images/raw/master/img/20201003210401.png" style="zoom: 40%;" />

`m[i][j]` 给出了最优值，即计算 `A[i:j]` 所需的最少数乘次数。同时确定了计算 `A[i:j]` 的最优次序中的断开位置 `k`。

若将对应 `m[i:j]` 的断开位置 `k` 记为 `s[i][j]`，则在计算出最优质 `m[i][j]` 后，可递归地由 `s[i][j]` 构造出相应的最优解。

### ③ 自底向上计算最优值

<img src="https://gitee.com/veal98/images/raw/master/img/20201003211352.png" style="zoom:40%;" />

```java
// p 是输入数组
// n 是 p 的长度
// m 数组存储每个子问题的最优值(计算量)
// s 数组存储每个子问题的断开位置
public void MatixChain(int[] p, int n, int[][] m, int[][] s){
    for(int i = 1; i <= n; i ++)
        m[i][j] = 0; // 初始化最优值数组
   	for(int r = 2; r <= n; r ++){
        for(int i = 1; i <= n-r+1; i ++){
            int j = i + r - 1;
            m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j]
            s[i][j] = 1;
            for(int k = i + 1; k < j; k ++){
                int t = m[i][k] + m[k+1]m[j] + p[i-1]*p[k]*p[j];
                if(t < m[i][j]){
                    m[i][j] = t; // 更新最优值
                    s[i][j] = k; // 更新断开点位置
                }
            }
        }
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20201003213449.png" style="zoom: 55%;" />

### ④ 构造最优解

<img src="https://gitee.com/veal98/images/raw/master/img/20201003214047.png" style="zoom:40%;" />

```java
// 返回 s 数组 i~j 范围内的最优值
public void Traceback(int i, int j, int[][] s){
    if(i == j)
        return ;
    Traceback(i, s[i][j], s);
    Traceback(s[i][j]+1, j, s);
}
```

要输出 `A[1:n]` 的最优计算次序只需要调用  `Traceback(1,n,s)` 即可。

## 3. 最长公共子序列

## 4. 最大子段和



## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)
- [二分查找、二分边界查找算法的模板代码总结](https://segmentfault.com/a/1190000016825704)
- [labuladong 的算法小抄](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie#si-luo-ji-tong-yi)