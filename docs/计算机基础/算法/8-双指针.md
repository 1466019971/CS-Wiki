# 📍 双指针

---

双指针技巧分为两类：

- **「快慢指针」**，主要解决链表中的问题，比如典型的判定链表中是否包含环
- **「左右指针」**，主要解决数组（或者字符串）中的问题，比如字符串逆置，二分查找

## 1. 左右指针

左右指针在数组中实际是指两个索引值，一般初始化为 `left = 0, right = nums.length - 1` 。

### ① 二分查找

前文关于二分查找有详细讲解，这里只写最标准的二分查找算法，旨在突出它的双指针特性：

```java
// 二分查找某个数
public int binarySearch(int[] nums, int target) {java
    int left = 0;
    int right = nums.length - 1; 
    while (left <= right) { // 注意
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) 
            return mid;
        else if (nums[mid] > target)
            right = mid - 1; 
        else // (nums[mid] < target)
            left = mid + 1; 
    }
    return -1;
}
```

### ② 两数之和

👉 [167. 两数之和 II - 输入有序数组 — Easy](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

**【题目描述】**：给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

示例:

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

【解题思路】：只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 `left` 和 `right` 可以调整 `sum` 的大小：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int len = numbers.length;
        int left = 0;
        int right = len - 1;
        int[] res = new int[2];
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                // 题意中下标从 1 开始
                res[0] = left + 1;
                res[1] = right + 1;
                break;
            }
            else if(sum < target)
                left ++;
            else
                right --;    
        }

        return res;
    }
}
```

### ③ 反转字符串/数组

👉 [344. 反转字符串 — Easy](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        int left = 0;
        int right = len - 1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left ++;
            right --;
        }
    }
}
```

### ④ 滑动窗口算法

滑动窗口算法是双指针里面最难的一部分，不过这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。该算法的大致逻辑如下：

```java
int left = 0, right = 0;

while (right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

以这个题目为例：👉 [76. 最小覆盖子串 — Hard](https://leetcode-cn.com/problems/minimum-window-substring/)

**【题目描述】**：

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```


示例 2：

```
输入：s = "a", t = "a"
输出："a"
```

**【解题思路】**：

***1、***我们在字符串`S`中使用双指针中的左右指针技巧，初始化`left = right = 0`，**把索引左闭右开区间`[left, right)`称为一个「窗口」**。

***2、***我们先不断地增加`right`指针扩大窗口`[left, right)`，直到窗口中的字符串符合要求（包含了`T`中的所有字符）。

***3、***此时，我们停止增加`right`，转而不断增加`left`指针缩小窗口`[left, right)`，直到窗口中的字符串不再符合要求（不包含`T`中的所有字符了）。同时，每次增加`left`，我们都要更新一轮结果。

***4、***重复第 2 和第 3 步，直到`right`到达字符串`S`的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，**也就是最短的覆盖子串。

下面画图理解一下，`needs`和`window`相当于计数器，分别记录`T`中字符以及出现次数和窗口中的字符以及出现次数。

> 🔗 图片来源 [labuladong 的算法小抄](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bei-bao-wen-ti)

<img src="https://gitee.com/veal98/images/raw/master/img/20201112223737.png" style="zoom:50%;" />![](https://gitee.com/veal98/images/raw/master/img/20201112223912.png)

<img src="https://gitee.com/veal98/images/raw/master/img/20201112223912.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201112223937.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201112224010.png" style="zoom:50%;" />

之后重复上述过程，先移动`right`，再移动`left`…… 直到`right`指针到达字符串`S`的末端，算法结束

```java
class Solution {

    // 记录 t 中的字符及其对应的个数，比如 A B B C ，则存储[A:1 B:2 C:1]
    HashMap<Character, Integer> need = new HashMap<>(); 
    // 记录窗口中的字符及其对应的个数
    HashMap<Character, Integer> window = new HashMap<>(); 

    // t 目标字符串，返回 s 中涵盖 t 所有字符的最小子串
    public String minWindow(String s, String t) {
        int tLen = t.length(); 
        int sLen = s.length();
        if(tLen == 0 || sLen == 0)
            return "";
        
        for(int i = 0; i < tLen; i ++){
            char c = t.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int vaild = 0; // 表示窗口 window 中满足 need 条件的字符个数

        int len = Integer.MAX_VALUE; // 最小覆盖子串的起始长度
        int start = 0; // 最小覆盖子串的起始索引

        //当右指针去到字符串末尾前
        while(right < sLen){
            char c = s.charAt(right); // s 中第一个字符

            right ++; // 右指针右滑
            
            // 如果右指针指向的这个字符存在于目标字符串 t 中，则更新窗口数据以及 vaild
            if(need.containsKey(c)){
                // 更新窗口数据
                window.put(c, window.getOrDefault(c, 0) + 1);
                
                // 窗口中的该字符满足 need 条件，则 vaild ++
                if(window.get(c).equals(need.get(c)))
                    vaild ++;
            }

            // 如果窗口已完全覆盖了字符串 t
            // 收缩左边界直到刚好不满足t中的字符为止
            while(vaild  == need.size()){
                if(right - left < len){
                    start = left;
                    len = right - left;
                }

                char d = s.charAt(left);

                left ++; // 收缩左边界
                
                if(need.containsKey(d)){
                    if(window.get(d).equals(need.get(d)))
                        vaild --;
                    window.put(d, window.getOrDefault(d, 0) - 1);
                }
            }
        }

        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);

    }
}
```

## 2. 快慢指针

## ✍ LeetCode 汇总 — 回溯法

**【左右指针】**：

- 😎 [344 - 反转字符串](计算机基础/算法/LeetCode/双指针/344-反转字符串.md)
- 😎 [167 - 两数之和 II - 输入有序数组](计算机基础/算法/LeetCode/双指针/167-两数之和II-输入有序数组.md)
- 👽  [76 - 最小覆盖子串](计算机基础/算法/LeetCode/双指针/76-最小覆盖子串.md)

**【快慢指针】**：

## 📚 References

- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)
- [labuladong 的算法小抄](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bei-bao-wen-ti)