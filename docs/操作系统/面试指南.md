# 操作系统基础

## 1. 什么是操作系统

- 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
- 操作系统本质上是运行在计算机上的软件程序 ；
- 操作系统为用户提供一个与系统交互的操作界面 ；
- 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。

> 关于内核多插一嘴：内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。 内核就是操作系统背后黑盒的核心。

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586311138828-79fb5c23-9aab-4e88-a958-2a0f256bad77.png" alt="image.png" style="zoom:67%;" />



## 2. 什么是系统调用

了解系统调用之前我们必须先了解用户态和内核态

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

- 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
- 内核态(kernel mode): 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。



我们运行的程序基本都是运行在用户态，如果我们想调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了！



**也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。**



这些系统调用按功能大致可分为如下几类：

- **设备管理**。完成设备的请求或释放，以及设备启动等功能。
- **文件管理**。完成文件的读、写、创建及删除等功能。
- **进程控制**。完成进程的创建、撤销、阻塞及唤醒等功能。
- **进程通信**。完成进程之间的消息传递或信号传递等功能。
- **内存管理**。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

# 进程和线程

## 3. 进程和线程的区别

总结：

**线程是进程划分成的更小的运行单位, 一个进程在其执行的过程中可以产生多个线程**。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。



详细如下：

- Ⅰ `拥有资源` 
  **进程是资源分配的基本单位，但是线程不拥有资源(只拥有很少的资源)，线程可以访问隶属进程的资源。**
- Ⅱ `调度` 
  **线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换**，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- Ⅲ `系统开销` 
  由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而**线程切换时只需保存和设置少量寄存器内容，开销很小。**
- Ⅳ `通信方面` 
  **线程间可以通过直接读写同一进程中的数据进行通信**，但是进程通信需要借助 进程通信IPC。

## 4. 进程有哪几种状态

我们一般把进程大致分为 5 种状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586314490798-3111e30e-861a-4aa0-b95a-f5ebfb54744d.png)

应该注意以下内容：

- **只有就绪态和运行态可以相互转换，其它的都是单向转换**。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- **阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间**，缺少 CPU 时间会从运行态转换为就绪态。

## 5. 进程间的通信方式

大概有 7 种常见的进程间的通信方式。

- **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。只存在于内存中的文件。
- **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。**有名管道以磁盘文件的方式存在**，可以实现本机任意两个进程通信。
- **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。

管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：

存在于实际的磁盘介质或者文件系统）不同的是**消息队列存放在内核中，只有在内核重启(即，操作系统重启)**

**或者显示地删除一个消息队列时，该消息队列才会被真正的删除。**

消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更

有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。**

- **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
- **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
- **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 6. 进程的调度算法

- **先来先服务 FCFS：非抢占式。**按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。
- **短作业优先** **SJF：非抢占式。**每次调度时选择当前 已到达的 且 运行时间最短的 作业/进程。
- **最短剩余时间优先 SRTN：抢占式。**最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。

当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则

挂起当前进程，运行新的进程。否则新的进程等待。

- **高响应比优先 HRRN：非抢占式。**只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选 **响应比最高的** 进程执行。

响应比 = (等待时间+要求服务时间) / 要求服务时间

## 7. 操作系统的内存管理主要是做什么

操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？主要包括以下四个方面：

- 内存空间的分配与回收
- 内存空间的扩充（虚拟存储技术）
- 地址转换（逻辑地址和物理地址的转化）
- 存储保护（保证各进程在各自存储空间内运行，互不干扰）

# 内存管理

## 8. 内存管理有那几种方式/常见的内存管理机制

分为**连续分配管理方式**和**非连续分配管理方式**这两种。



**连续分配管理方式：**是指为一个用户程序分配一个连续的内存空间。

- 单一连续分配：内存中只能有一道用户程序，用户程序独占整个用户区空间。有内部碎片（如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片），存储利用率低下。
- 固定分区分配：将整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业
- 动态分区分配：这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。



**非连续分配管理方式：**允许一个程序使用的内存分布在离散或者说不相邻的内存中。

- 页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。

- 段式管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。

  段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。

  段式管理通过段表对应逻辑地址和物理地址。

- 段页式管理：段页式管理机制结合了段式管理和页式管理的优点。

  简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页.

  也就是说 段页式管理机制 中**段与段之间以及段的内部的都是离散的**。

## 9. 快表和多级页表

页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。

在分页内存管理中，很重要的两点是：

- 虚拟地址到物理地址的转换要快。
- 解决虚拟地址空间大，页表也会很大的问题。



**快表 :** **为了解决虚拟地址到物理地址的转换速度**，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。

我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。

由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

- 根据虚拟地址中的页号查快表；
- 如果该页在快表中，直接从快表中读取相应的物理地址；
- 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
- 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。



**多级页表：**引入多级页表的主要目的是为了**避免把全部页表一直放在内存中占用过多空间**，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于**时间换空间**的典型场景。



**总结：**为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理

## 10. 分页机制和分段机制的共同点和区别

**共同点 ：**

- 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。
- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

**区别 ：**

- 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

## 11. 逻辑地址和物理地址

**逻辑地址是相对地址，物理地址是绝对地址**。

我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，**逻辑地址由操作系统决定**。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。**物理地址是内存单元真正的地址**。

## 12. CPU 寻址了解吗?为什么需要虚拟地址空间?

**CPU寻址：**

现代处理器使用的是一种称为 **虚拟寻址(Virtual Addressing)** 的寻址方式。使用虚拟寻址，**CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存**。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 **内存管理单元**（Memory Management Unit, **MMU**） 的硬件。如下图所示：

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586320392269-06285515-7cf3-41ac-81ea-1333fe33a416.png)



**为什么要有虚拟地址空间呢？**

**没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存** 。但是这样有什么问题呢？

- 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。
- 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。



**总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。**



**通过虚拟地址访问内存有以下优势：**

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

# 虚拟内存

## 13. 什么是虚拟内存(Virtual Memory)?

我们都知道一个进程是与其他进程共享CPU和内存资源的。正因如此，操作系统需要有一套完善的内存管理机制才能**防止进程之间内存泄漏**的问题。



为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉**（每个进程拥有一片连续完整的内存空间）。 正是因为 虚拟内存 的存在，**通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。**目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等

> **虚拟内存和交换空间**，这两个概念要和操作系统一起说，window下的“虚拟内存”实际上是存在磁盘上的页面文件，和linux的交换空间概念一样，**都是物理上实际存在的东西**，如果内存够用，没有缺页，你禁掉这两个东西不会影响虚拟存储器；然而撇开操作系统，只谈理论，虚拟内存还是一种技术，它允许执行进程不必完全放在内存中。这两种其实都属于交换技术，交换技术除了因为内存紧张要使用之外，还有在一些操作系统如分时系统中为了改善进程组合(CPU密集型和IO密集型)也要用它进行中期调度。



- 电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即**匀出一部分硬盘空间来充当内存使用**。

  **虚拟内存在硬盘上其实就是为一个硕大无比的文件**，文件名是 PageFile.Sys，所以**虚拟内存也称页面文件**。

   虽然把它当做内存用，可**这块空间毕竟是在硬盘，速度肯定不如真是内存，所以说它是虚的。**

- 当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。若计算机运行程序或操作所需的随机存储器（RAM）不足时，则Windows会用虚拟存储器进行补偿。它将计算机的RAM和硬盘上的临时空间组合。
- 当RAM运行速率缓慢时，它便将数据从RAM移动到称为“分页文件”的空间中。将数据移入分页文件可释放RAM，以便完成工作。一般而言，计算机的RAM容量越大，程序运行得越快。
- 若计算机的速率由于RAM可用空间匮乏而减缓，则可尝试通过增加虚拟内存来进行补偿。但是，计算机从RAM读取数据的速率要比从硬盘读取数据的速率快，因而扩增RAM容量（可加内存条）是最佳选择。



## 14. 局部性原理

要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，**局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念**。



🙋 局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。



早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，**也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。**



局部性原理表现在以下两个方面：

- **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
- **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。



时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。

空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。

## 15. 什么是虚拟存储器

**虚拟存储器是一种机制，是整个CPU访问内存过程的体现。**



**基于局部性原理**，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。

在程序执行过程中，当**所访问的信息不在内存时，由操作系统将所需要的部分调入内存**，然后继续执行程序。另一方面，操作系统**将内存中暂时不使用的内容换到外存上**，从而腾出空间存放将要调入内存的信息。这样，**计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。**

## 16. 如何实现虚拟内存技术

虚拟内存的实现需要**建立在离散分配的内存管理方式的基础上**。 虚拟内存的实现有以下三种方式：

- **请求分页存储管理** ：建立在分页管理之上，**为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。**请求分页是目前最常用的一种实现虚拟存储器的方法。

请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的

过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到

主存，同时操作系统也可以将暂时不用的页面置换到外存中。

- **请求分段存储管理** ：建立在分段存储管理之上，**增加了请求调段功能、分段置换功能**。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
- **请求段页式存储管理**

## 17. 请求分页存储管理 和 (基本)分页存储管理 的区别

请求分页存储管理建立在分页管理之上。**他们的根本区别是****是否将程序所需的全部地址空间都装入主存**，这也是请求分页存储管理可以提供虚拟内存的原因。

**请求分页存储管理不要求将作业全部地址空间同时装入主存**。**在分页存储管理的基础上增加了请求调页和页面置换的功能，**基于这一点，**请求分页存储管理可以提供虚存，而分页存储管理不能提供虚拟内存**。

## 18. 页面置换算法

- **最佳置换算法 OPT**

被换出的页面将是**最长时间内不再被访问的**，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

- **先进先出置换算法 FIFO**

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

- **最近最久未使用置换算法 LRU**

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。

LRU 将**最近最久未使用的页面换出**。

- **时钟置换算法 Clock / 最近未用算法 NRU**

为每个页面设置一个**访问位**，当被访问时，访问位置为1。

当发生缺页中断时，NRU 算法**只需检查页的访问位，如果是0（未被访问），就将该页换出**；

如果是1，就将其置为0，暂不换出，继续检查下一个页面