# 1. 什么是事务?

事务是逻辑上的一组操作，**要么都执行，要么都不执行**。



事务最经典也经常被拿出来说例子就是转账了。

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。

万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。**事务就是保证这两个关键操作要么都成功，要么都要失败**。

# 2. 事务的特性(ACID)



![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069498120-8528472e-be68-4847-ae9d-b072644c6b2e.png)



- `原子性（Atomicity）`
   **事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。** 
  回滚可以用**回滚日志**（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
- `一致性（Consistency）`
   **数据库在事务执行前后都保持一致性状态**。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
   例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的.
- `隔离性（Isolation）`
   **一个事务所做的修改在最终提交以前，对其它事务是不可见的。**
- `持久性（Durability）`
   **一旦事务提交，则其所做的修改将会永远保存到数据库中**。即使系统发生崩溃，事务执行的结果也不能丢失。 
  系统发生奔溃可以用**重做日志**（Redo Log）进行恢复，从而实现持久性。
   与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久性是为了能应对系统崩溃的情况。 
  图片来源：CS-Nodes
   ![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069498244-8d0ba32c-1921-45c9-8f99-eb03de68d919.png)

# 3. 并发事务带来的问题

> 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。



- 脏读（Dirty read）
  **当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据**。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据” ，依据 “脏数据” 所做的操作可能是不正确的。
   （T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。）
   <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498406-979df4fe-4a95-4315-a8d9-7d01999e1dca.jpeg" alt="img" style="zoom:67%;" />

- 丢失修改（Lost to modify）

  指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
   （T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。）
   <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498305-bfbf8384-1e93-408e-8d49-a6197f8a4e5c.jpeg" alt="img" style="zoom:67%;" />

- 不可重复读（Unrepeatableread）

  **一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样**。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
   （T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同）
   <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498417-9804c852-4548-4f12-a81d-631962e65586.jpeg" alt="img" style="zoom:67%;" />

- 幻读（Phantom read）

  幻读与不可重复读类似。**它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。**
   （T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。）
   <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498330-cc4b21ea-cbe7-4d22-bf69-a8ad4a88cfa9.jpeg" alt="img" style="zoom:67%;" />



> **不可重复度和幻读区别**：
>
> ```
> 不可重复读的重点是修改，幻读的重点在于新增或者删除。
> ```
>
> 
>
> 
>
> **例1**（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：
>
> 事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。
>
> 
>
> 
>
> **例2**（同样的条件, 第1次和第2次读出来的记录数不一样 ）：
>
> 假如某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

# 4. 事务的隔离级别



SQL 标准定义了四个隔离级别：

- READ-UNCOMMITTED(读取未提交)：
  
  最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ-COMMITTED(读取已提交)：
  
  允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE-READ(可重复读)：
  
  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- SERIALIZABLE(可串行化)：
  
  最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
   （该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。）



<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586069498290-e0cc5fbd-5f45-475e-be79-8f7eeb9cfc6b.png" alt="img" style="zoom:67%;" />



> ```
> MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）
> ```
>
> 
>
> 
>
> 这里需要注意的是：与 SQL 标准不同的地方在于 **InnoDB 存储引擎在REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)** 隔离级别。
>
> 
>
> 
>
> 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。
>
> InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)** 隔离级别。



# 5. 封锁

## 封锁粒度

MySQL 中提供了两种封锁粒度：`行级锁` 以及 `表级锁` 。



> - 表级锁： MySQL中锁定 粒度最大 的一种锁，**对当前操作的整张表加锁**，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
> - 行级锁： MySQL中锁定 粒度最小 的一种锁，**只针对当前操作的行进行加锁**。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。



应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。



但是**加锁需要消耗资源**，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。**因此封锁粒度越小，系统开销就越大。**



在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。



## 封锁类型

### 读写锁

- - `互斥锁（Exclusive）`，简写为 `X 锁`，又称 `写锁` 。
  - `共享锁（Shared）`，简写为 `S 锁` ，又称 `读锁` 。



有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。**加X锁期间其它事务不能对 A 加任何锁**。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。**加S锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。**



<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498324-1786f0b1-0149-41fb-bc59-36159ba9f0a7.jpeg" alt="img" style="zoom:67%;" />



### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。



在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的**任意一行**加了锁（检测是否存在行级锁），那么就需要对表 A 的每一行都检测一次，这是非常耗时的。



意向锁在原来的 X/S 锁之上引入了 `IX / IS`，IX / IS 都是表锁，**用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁**。有以下两个规定：



- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。



通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X / IX / S / IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。



各种锁的兼容关系如下：（**表级锁**）

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498356-e780ccd1-9003-4258-b8f7-82cafbeb8daf.jpeg" alt="img" style="zoom:67%;" />



总结如下：

- X 锁 不兼容任何锁
- 任意IS / IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁
- 这里兼容关系针对的是表级锁，而 `表级的 IX 锁和行级的 X 锁兼容`，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）



## 封锁协议

### 三级封锁协议



- 一级封锁协议

  **事务 T 要`修改数据 A 时必须加 X 锁`，直到 T 结束才释放锁。**

  可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498457-d8e21d67-69bf-43d2-a9db-3df7547d77c4.jpeg" alt="img" style="zoom:50%;" />



- 二级封锁协议

  **在一级的基础上，要求`读取数据 A 时必须加 S 锁, 读取完马上释放 S 锁。`**

  可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498161-39df2810-5bc6-40f4-928a-0cc90fb72916.jpeg" alt="img" style="zoom: 50%;" />



- 三级封锁协议

  **在二级的基础上，要求`读取数据 A 时必须加 S 锁，直到 事务结束了 才能释放 S 锁`。**

  可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1237282/1586069498358-27d8a8d2-95bb-4381-9767-68c2088a482a.jpeg" alt="img" style="zoom: 50%;" />



### 两段锁协议

**加锁 和 解锁 分为两个阶段进行。**



`可串行化调度` 是指，通过并发控制，**使得并发执行的事务结果与某个串行执行的事务结果相同**。串行执行的事务互不干扰，不会出现并发一致性问题。



**事务遵循两段锁协议是保证可串行化调度的充分条件**。例如以下操作满足两段锁协议，它是可串行化调度。

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```



**但不是必要条件**，例如以下操作不满足两段锁协议，但它还是可串行化调度。

```
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```



# 6. 多版本并发控制 MVCC

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 **MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式**.

用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。



# 7. Next-Key Locks

**Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。**



MVCC 不能解决幻影读问题，**Next-Key Locks 就是为了解决这个问题而存在的**。在可重复读（REPEATABLE READ）隔离级别下，使用 `MVCC + Next-Key Locks` 可以 `解决幻读问题`。



## InnoDB存储引擎的三种锁的算法

- `Record Locks`

**锁定一个记录上的索引，而不是记录本身。**


如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。




- `Gap Locks`

**锁定索引之间的间隙，但是不包含索引本身**。


例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```




- `Next-Key Locks`

它是 Record Locks 和 Gap Locks 的结合，**不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间**.


例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```
