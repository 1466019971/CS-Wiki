# 📐 基于概率论的分类方法：朴素贝叶斯

---

> 贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。本章首先介绍贝叶斯分类算法的基础——贝叶斯定理。最后，我们通过实例来讨论贝叶斯分类的中最简单的一种: 朴素贝叶斯分类。

## 1. 基于贝叶斯决策理论的分类方法

朴素贝叶斯是**贝叶斯决策理论**的一部分：

我们现在有一个数据集，它由两类数据组成，数据分布如下图所示:

<img src="https://gitee.com/veal98/images/raw/master/img/20200708105615.png" style="zoom:80%;" />

我们现在用 p1(x,y) 表示数据点 (x,y) 属于类别 1（图中用圆点表示的类别）的概率，用 p2(x,y) 表示数据点 (x,y) 属于类别 2（图中三角形表示的类别）的概率。

那么对于一个新数据点 (x,y)，可以用下面的规则来判断它的类别:

- 如果 p1(x,y) > p2(x,y) ，那么类别为1
- 如果 p2(x,y) > p1(x,y) ，那么类别为2

也就是说，我们会选择高概率对应的类别。这就是**贝叶斯决策理论的核心思想，即选择具有最高概率的决策**。

## 2. 条件概率  conditional probability 

### ① 条件概率

有一个装了 7 块石头的罐子，其中 3 块是白色的，4 块是黑色的。如果从罐子中随机取出一块石头，那么是白色石头的可能性是多少？

<img src="https://gitee.com/veal98/images/raw/master/img/20200708110247.png" style="zoom: 67%;" />

显然，取出白色石头的概率为 3/7 ，取到黑色石头的概率是 4/7 。我们使用 P(white) 来表示取到白色石头的概率，其概率值可以通过白色石头数目除以总的石头数目来得到。

❓ **如果这 7 块石头如下图所示，放在两个桶中，那么上述概率应该如何计算**？

<img src="https://gitee.com/veal98/images/raw/master/img/20200708110356.png" style="zoom:67%;" />

要计算 P(white) 或者 P(black) ，显然，石头所在桶的信息是会改变结果的，这就是**条件概率 conditional probability**。假定计算的是<u>从 B 桶取到白色石头的概率</u>，这个概率可以记作 `P(white|bucketB)` ，我们称之为 “**在已知石头出自 B 桶的条件下，取出白色石头的概率**”。很容易得到，`P(white|bucketA)` 值为 2/4 ，`P(white|bucketB) `的值为 1/3 。

条件概率的计算公式如下:

⭐ `P(white|bucketB) = P(white and bucketB) / P(bucketB)`

公式解读：

- `P(white|bucketB)`：在已知石头出自 B 桶的条件下，取出白色石头的概率 

- `P(white and bucketB)`：取出 B 桶中 白色石头的概率 = 1/ 7

- `P(bucketB)`：取出 B 桶中石头的概率 3 / 7

### ② 贝叶斯准则

另外一种有效计算条件概率的方法称为**贝叶斯准则**。贝叶斯准则告诉我们如何交换条件概率中的条件与结果，即如果已知 `P(x|c)`，要求 `P(c|x)`，那么可以使用下面的计算方法:

⭐ <img src="https://gitee.com/veal98/images/raw/master/img/20200708111100.png" style="zoom:80%;" />

OK，我们讨论了条件概率，接下来将其应用到分类器中。👇

## 3. 使用条件概率来分类

第 1 节提到贝叶斯决策理论需要计算两个概率：p1(x, y) 和 p2(x, y) 

- 如果 p1(x, y) > p2(x, y) ，那么类别为 1
- 如果 p2(x, y) > p1(x, y) ，那么类别为 2

**这并不是贝叶斯决策理论的所有内容**。使用 p1( ) 和 p2( ) 只是为了尽可能简化描述，而**真正需要计算和比较的是 `p(c1|x, y)` 和` p(c2|x, y)`** 。这些符号所代表的具体意义是：<u>给定某个由 x、y 表示的数据点，那么该数据点来自类别 c1 的概率是多少？数据点来自类别 c2 的概率又是多少？</u>注意这些概率与概率 `p(x, y|c1)` 并不一样，不过可以使用贝叶斯准则来交换概率中条件与结果。具体地，应用贝叶斯准则得到:

<img src="https://gitee.com/veal98/images/raw/master/img/20200708111645.png" style="zoom:80%;" />

⭐ 使用上面这些定义，可以定义贝叶斯分类准则为:

- 如果 `P(c1|x, y) > P(c2|x, y)`, 那么属于类别 c1；
- 如果 `P(c2|x, y) > P(c1|x, y)`, 那么属于类别 c2。

使用贝叶斯准则，可以通过已知的三个概率值来计算未知的概率值。后面会给出利用贝叶斯准则来计算概率并对数据进行分类的代码。

下一节将介绍一个简单但功能强大的贝叶斯分类器的应用案例。

## 4. 使用朴素(navie)贝叶斯进行文档分类

机器学习的一个重要应用就是文档的自动分类。

在文档分类中，整个文档（如一封电子邮件）是实例，而电子邮件中的某些元素则构成特征。我们可以观察文档中出现的词，并**把每个词作为一个特征**，而每个词的出现或者不出现作为该特征的值，<u>这样得到的特征数目就会跟词汇表中的词的数目一样多。</u>

**朴素贝叶斯是上面介绍的贝叶斯分类器的一个扩展**，是用于文档分类的常用算法。

朴素贝叶斯的一般过程：

- 收集数据: 可以使用任何方法。比如 RSS 源
- 准备数据: 需要数值型或者布尔型数据。
- 分析数据: 有大量特征时，绘制特征作用不大，此时使用直方图效果更好。
- 训练算法: 计算不同的独立特征的条件概率。
- 测试算法: 计算错误率。
- 使用算法: 一个常见的朴素贝叶斯应用是文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。

假设词汇表有 1000 个单词 ，要得到好的概率分布，就需要足够的数据样本。如果每个特征需要 N 个样本，那么对于 10 个特征将需要 $N^{10}$ 个样本，对于包含 1000 个特征（单词）的词汇表就需要 $N^{1000}$ 个样本。可以看到，所需要的样本数会随着特征数目的增大而迅速增长。

- ⚪ 朴素贝叶斯分类器假设特征之间 **相互独立** 。那么样本数就可以从 $N^{1000}$ 减少到 $1000 × N$。 所谓 **独立(independence)** 指的是统计意义上的独立，即**一个特征或者单词出现的可能性与它和其他单词相邻没有关系**，比如说，‘我’ 出现在 ‘们’ 的前面的概率和 出现在 ‘们’ 的后面的概率相同（当然，我们知道这种假设并不正确）。这个假设正是朴素贝叶斯分类器中 **朴素(naive)** 一词的含义。

- ⚪ 朴素贝叶斯分类器中的另一个假设是，**每个特征同等重要**。

## 5. 使用 Python 进行文本分类

使用朴素贝叶斯构建一个快速过滤器来屏蔽在线社区留言板上的侮辱性言论。如果某条留言使用了负面或者侮辱性的语言，那么就将该留言标识为内容不当。对此问题建立两个类别: 侮辱类和非侮辱类，使用 1 和 0 分别表示。

### ① 准备工作：从文本中构建词向量

我们将把文本看成单词向量或者此条向量，也就说将句子转换成向量。考虑出现在文档中的所有单词，再决定将哪些词纳入词汇表或者说所要的词汇的集合。

📑 词表到向量的转换函数：

> 这里的数据集是我们手动输入的，一个列表代表一篇文档

```python
def loadDataSet():
    """
    创建数据集
    :return: 单词列表postingList, 所属类别 classVec
    """
    postingList = [['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], # 文档1
                   ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], # 文档2
                   ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], # 文档3
                   ['stop', 'posting', 'stupid', 'worthless', 'garbage'], # 文档4
                   ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], # 文档5
                   ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] # 文档6
    classVec = [0, 1, 0, 1, 0, 1]    # 各篇文档中是否带侮辱性文字：1 代表侮辱性文字，0 代表正常言论
    return postingList, classVec

def createVocabList(dataSet):
    """
    获取所有单词去重后的集合
    :param dataSet: 数据集
    :return: 所有单词的集合(即不含重复元素的单词列表)
    """
    vocabSet = set([])  # 创建一个空集
    for document in dataSet:
        vocabSet = vocabSet | set(document)  # 操作符 | 用于求两个集合的并集
    return list(vocabSet)

def setOfWords2Vec(vocabList, inputSet):
    """
    遍历查看该单词是否出现，出现该单词则将该单词置 1
    :param vocabList: 所有单词集合列表（词汇表）
    :param inputSet: 输入数据集
    :return: 匹配列表[0,1,0,1...]，其中 1 与 0 表示词汇表中的单词是否出现在输入的数据集中
    """
    returnVec = [0]*len(vocabList) # 创建一个和词汇表等长的向量，并将其元素都设置为0
    # 遍历文档中的所有单词，如果出现了词汇表中的单词，则将输出的文档向量中的对应值设为1
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] = 1
        else: print("the word: %s is not in my Vocabulary!" % word)
    return returnVec
```

看看这些函数的效果：

```python
listOPosts,listClasses = loadDataSet()
myVocabList = createVocabList(listOPosts)
```

![](https://gitee.com/veal98/images/raw/master/img/20200708121442.png)

![](https://gitee.com/veal98/images/raw/master/img/20200708121452.png)

### ② 训练算法：从词向量计算概率

前面介绍了如何将一组单词转换为一组数字，接下来看看如何使用这些数字计算概率。

现在已经知道一个词是否出现在一篇文档中，也知道该文档所属的类别。接下来我们重写贝叶斯准则，<u>将之前的 x, y 替换为 **w**，表示这是一个向量，即它由多个值组成</u>。在这个例子中，数值个数与词汇表中的词个数相同。

<img src="https://gitee.com/veal98/images/raw/master/img/20200708122025.png" style="zoom:80%;" />

我们使用上述公式，对每个类计算该值，然后比较这两个概率值的大小。

首先可以通过类别 i (侮辱性留言或者非侮辱性留言)中的文档数除以总的文档数来计算概率 $p(c_i)$ 。接下来计算$ p(w | c_i) $，这里就要用到**朴素贝叶斯假设**。如果将 w 展开为一个个独立特征，那么就可以将上述概率写作 $p(w_0, w_1, w_2...w_n | c_i) $。这里假设所有词都互相独立，该假设也称作**条件独立性假设**，它意味着**可以使用$ p(w_0 | c_i) × p(w_1 | c_i) × p(w_2 | c_i) × ... × p(w_n | c_i) $来计算上述概率**，这样就极大地简化了计算的过程。

该函数的伪代码如下：

<img src="https://gitee.com/veal98/images/raw/master/img/20200708122534.png" style="zoom:80%;" />

```python
import numpy as np

def _trainNB0(trainMatrix, trainCategory):
    """
    朴素贝叶斯分类器训练函数
    :param trainMatrix: 文件单词矩阵 [[1,0,1,1,1....],[],[]...]
    :param trainCategory: 文件对应的类别[0,1,1,0....]，列表长度等于单词矩阵数，其中的1代表对应的文件是侮辱性文件，0代表不是侮辱性矩阵
    :return:
    """
   
    numTrainDocs = len(trainMatrix)  # 文件数
    numWords = len(trainMatrix[0])  # 单词数
    pAbusive = sum(trainCategory) / float(numTrainDocs) # 侮辱性文件的出现概率，即 trainCategory 中所有的1的个数(0 1 相加即得 1 的个数)
    # 构造单词出现次数列表
    p0Num = np.zeros(numWords) # [0,0,0,.....]
    p1Num = np.zeros(numWords) # [0,0,0,.....]

    # 整个数据集单词出现总数
    p0Denom = 0.0 # 0 非侮辱性词汇出现总数
    p1Denom = 0.0 # 1 侮辱性词汇出现总数
    
    for i in range(numTrainDocs):
        # 是否是侮辱性文件
        if trainCategory[i] == 1:
            # 如果是侮辱性文件，对侮辱性文件的向量进行加和
            p1Num += trainMatrix[i] # [0,1,1,....] + [0,1,1,....] -> [0,2,2,...]
            # 对向量中的所有元素进行求和，也就是计算所有侮辱性文件中出现的单词总数
            p1Denom += sum(trainMatrix[i])
        else:
            p0Num += trainMatrix[i]
            p0Denom += sum(trainMatrix[i])
            
    # 类别1，即侮辱性文档的[P(F1|C1),P(F2|C1),P(F3|C1),P(F4|C1),P(F5|C1)....]列表
    # 即在1类别下，每个单词出现的概率
    p1Vect = p1Num / p1Denom # [1,2,3,5]/90->[1/90,2/90,3/90,5/90]
    
    # 类别0，即正常文档的[P(F1|C0),P(F2|C0),P(F3|C0),P(F4|C0),P(F5|C0)....]列表
    # 即在0类别下，每个单词出现的概率
    p0Vect = p0Num / p0Denom
    return p0Vect, p1Vect, pAbusive
```

使用该函数进行分类之前，还需解决函数中的一些缺陷。

### ③ 测试算法：根据现实情况修改分类器

在利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算 $p(w_0|1) * p(w_1|1) * p(w_2|1)$。**如果其中一个概率值为 0，那么最后的乘积也为 0**。为降低这种影响，可以将所有词的出现数初始化为 1，并将分母初始化为 2 （取1 或 2 的目的主要是为了保证分子和分母不为0，大家可以根据业务需求进行更改）。

```python
# 构造单词出现次数列表
p0Num = np.ones(numWords) # [1,1,1,.....]
p1Num = np.ones(numWords) # [1,1,1,.....]

# 整个数据集单词出现总数
p0Denom = 2.0 # 0 非侮辱性词汇出现总数
p1Denom = 2.0 # 1 侮辱性词汇出现总数
```

另一个遇到的问题是**下溢出**，这是由于**太多很小的数相乘**造成的。当计算乘积 $p(w_0|c_i) * p(w_1|c_i) * p(w_2|c_i)... p(w_n|c_i)$ 时，由于大部分因子都非常小，所以程序会下溢出或者得到不正确的答案。（用 Python 尝试相乘许多很小的数，**最后四舍五入后会得到 0**）。一种解决办法是对乘积取自然对数。在代数中有 `ln(a * b) = ln(a) + ln(b)`, 于是通过求对数可以避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。

```python
p1Vect = log(p1Num / p1Denom)
p0Vect = log(p0Num / p0Denom)
```

下图给出了函数 f(x) 与 ln(f(x)) 的曲线。可以看出，它们在相同区域内同时增加或者减少，并且在相同点上取到极值。它们的取值虽然不同，但不影响最终结果。

<img src="https://gitee.com/veal98/images/raw/master/img/20200708150554.png" style="zoom:67%;" />

训练函数的优化版本如下：

```python
def trainNB0(trainMatrix, trainCategory):
    """
    训练数据优化版本
    :param trainMatrix: 文件单词矩阵
    :param trainCategory: 文件对应的类别
    :return:
    """
    # 总文件数
    numTrainDocs = len(trainMatrix)
    # 总单词数
    numWords = len(trainMatrix[0])
    # 侮辱性文件的出现概率
    pAbusive = sum(trainCategory) / float(numTrainDocs)
    # 构造单词出现次数列表
    # p0Num 正常的统计
    # p1Num 侮辱的统计
    p0Num = ones(numWords)#[0,0......]->[1,1,1,1,1.....]
    p1Num = ones(numWords)

    # 整个数据集单词出现总数，2.0根据样本/实际调查结果调整分母的值（2主要是避免分母为0，当然值可以调整）
    # p0Denom 正常的统计
    # p1Denom 侮辱的统计
    p0Denom = 2.0
    p1Denom = 2.0
    for i in range(numTrainDocs):
        if trainCategory[i] == 1:
            # 累加辱骂词的频次
            p1Num += trainMatrix[i]
            # 对每篇文章的辱骂的频次 进行统计汇总
            p1Denom += sum(trainMatrix[i])
        else:
            p0Num += trainMatrix[i]
            p0Denom += sum(trainMatrix[i])
    # 类别1，即侮辱性文档的[log(P(F1|C1)),log(P(F2|C1)),log(P(F3|C1)),log(P(F4|C1)),log(P(F5|C1))....]列表
    p1Vect = log(p1Num / p1Denom)
    # 类别0，即正常文档的[log(P(F1|C0)),log(P(F2|C0)),log(P(F3|C0)),log(P(F4|C0)),log(P(F5|C0))....]列表
    p0Vect = log(p0Num / p0Denom)
    return p0Vect, p1Vect, pAbusive
```

Ok，现在我们可以来构建完整的分类器了：

```python
# 朴素贝叶斯分类函数
def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1):
    """
    :param vec2Classify: 待测数据[0,1,1,1,1...]，即要分类的向量
    :param p0Vec: 类别0，即正常文档的[log(P(F1|C0)),log(P(F2|C0)),log(P(F3|C0)),log(P(F4|C0)),log(P(F5|C0))....]列表
    :param p1Vec: 类别1，即侮辱性文档的[log(P(F1|C1)),log(P(F2|C1)),log(P(F3|C1)),log(P(F4|C1)),log(P(F5|C1))....]列表
    :param pClass1: 类别1，侮辱性文件的出现概率
    :return: 类别1 or 0
    """
    p1 = sum(vec2Classify * p1Vec) + np.log(pClass1) # P(w|c1) * P(c1) ，即贝叶斯准则的分子
    p0 = sum(vec2Classify * p0Vec) + np.log(1.0 - pClass1) # P(w|c0) * P(c0) ，即贝叶斯准则的分子
    if p1 > p0:
        return 1
    else:
        return 0
```

```python
# 测试朴素贝叶斯算法
def testingNB():
    # 1. 加载数据集
    listOPosts, listClasses = loadDataSet() 
    # 2. 创建单词集合
    myVocabList = createVocabList(listOPosts)  
    # 3. 计算单词是否出现并创建数据矩阵
    trainMat = []
    for postinDoc in listOPosts: 
        # 返回 m*len(myVocabList)的矩阵， 记录的都是0，1信息
        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))
    # 4. 训练数据
    p0V, p1V, pAb = trainNB0(np.array(trainMat), np.array(listClasses))
    # 5. 测试数据
    testEntry = ['love', 'my', 'dalmation']
    thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry))
    print(testEntry, 'classified as: ', classifyNB(thisDoc, p0V, p1V, pAb))
    testEntry = ['stupid', 'garbage']
    thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry))
    print(testEntry, 'classified as: ', classifyNB(thisDoc, p0V, p1V, pAb))
```

![](https://gitee.com/veal98/images/raw/master/img/20200708152658.png)

### ④ 词袋模型

目前为止，我们将每个词的出现与否作为一个特征 ，这可以被描述为词集模型 set-of-words model，每个的单词只能出现一次。

而在词袋模型中 bag-of-words model，每个单词可以出现多次。下面给出基于词袋模型的朴素贝叶斯代码，它于 `setOfWords2Vec` 基本相同，但是每遇到一个单词时，它会增加词向量中的对应值，而不只是将对应的数值设为 1

```python
#  朴素贝叶斯词袋模型
def bagOfWords2VecMN(vocabList, inputSet):
    returnVec = [0]*len(vocabList)
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] += 1
        else: print("the word: %s is not in my Vocabulary!" % word)
    return returnVec
```

> ✅ OK，至此为止，分类器已经构建好了，接下来我们利用该分类器来过滤垃圾邮件。

## 6. 使用朴素贝叶斯过滤垃圾邮件

## 7. 使用朴素贝叶斯分类器从个人广告中获取区域倾向



## 📚 References

- 《Machine Learning in Action》
- [Github - AiLearning](https://github.com/apachecn/AiLearning/)