![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587832260807&di=5513c963f865d50abe9a0eeabbf6b409&imgtype=0&src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2018-11-30%2F5c00da538ca8d.jpg)

<br>



> 🚨 本文仅为准备 **考研复试** 使用，只包含 C++ 的基础语法，比如继承、多态、重载、模板等，并不包含 STL、异常等内容

<br>



# 一、基本概念

## 1. 简述你对“面向过程”和“面向对象”编程思想的认识与思考

**面向过程**：面向过程的设计思路是自顶向下的，按功能划分称若干个基本模块，形成一个树状结构，各个模块的功能上相对独立。

面向过程的**优点**主要是：

- 有效的将一个复杂的程序分解成多个小的、容易处理的子任务，便于维护和开发。

**缺点**主要是

- 可重用性差、数据安全性差；
- 当数据结构改变的时候，所有相关的处理过程都要进行相应的修改；
- 难以开发图形化界面；把数据和操作数据的过程分离开来。

**面向对象：**将数据和对数据的操作方法封装在一起，作为一个不可分割的整体——对象。对同类型的对象抽象出它们的共性，形成类。类通过外部接口public，与外部进行交互。

面向的对象的四大特性：抽象、封装、继承、多态。

面向对象的**优点**主要是：

- 各个模块之间的关系更见简单，模块之间的独立性、安全性都大大提高；
- 通过继承和多态，大大提高了程序的可重用性，便于开发和维护

## 2. 面向对象程序“接口和实现方法分离”有啥优点

接口定义了交互的标准。接口的实现细节对用户是隐藏的。

接口和是实现方法分离使得程序更容易修改，只要接口保持不变，接口实现的改变不会影响用户。提高了代码的可维护性，使得代码变得清晰。

## 3. 简述你对C++中数据类型和ADT的理解

**数据类型**是一组性质相同的具有一定范围的值和集合以及定义在这个集合上的一组操作。C++中既有内部类型：int、char、bool、float、double，又有外部数据类型：枚举类型enum、结构类型struct、联合类型union、数组类型int[]、类类型class。

**ADT** 即抽象数据类型，是基于已有类型而组成的复合数据类型，类就是抽象数据类型的描述形式。


## 4. 枚举函数是如何定义和使用的

`Enum Week{Mon,Tue,Wed,Thu,Fri,Sat,Sun);` <br />对应0，1，2，3，4，5，6；<br />枚举是对整数区间的自定义类型，一旦定义则不能改变，常用于代替整数常量，使得代码更加清晰。

## 5. 什么是逻辑错误，什么是语法错误

**语法错误：**是对语言规则的违背，当编译器不能正确识别语句的时候，就会导致语法错误（比如句子末尾少个分号），他们都是在编译期间就被检查出来的错误，所以也叫编译错误。<br />**逻辑错误**：指代码逻辑上的错误，编译能通过，程序可以完成运行，但是不会产生正确的结果（比如死循环）

## 6. 控制语句有哪几种，请画出他们的流程图

三种控制语句：

- 顺序
- 循环
- 选择

<img src="https://gitee.com/veal98/images/raw/master/img/20200425221326.png" style="zoom:80%;" />

## 7. 什么是else摇摆问题


```cpp
if(a>0){
	if(b>0)
        //do something
else
    //do something
}
```

这里的else匹配第二个if 而非第一个

即else匹配**最近一个未和else匹配的if**

<br>



# 二、数据的共享和保护

## 1. C++ 中的作用域

- **函数原型作用域：**在函数原型声明时形参的作用范围就是函数原型作用域**。**即只在形参的小括号内有用，出了小括号就死亡
- **局部作用域/块作用域：**函数形参列表中形参的作用域**。**从形参的声明处开始，到整个函数体结束为止；函数体内声明的变量，其作用域从声明处开始，到整个函数体结束为止
- **类作用域**
- **全局作用域/文件作用域：**在任何函数外部声明的标识符的作用范围都是文件作用域，从声明标识符开始，到文件末尾结束，这之间的任何函数都可以访问该标识符

## 2. C++中的存储类型指示符

- **auto**

  auto标名一个变量具有自动存储周期，该说明符只能用在具有局部作用域的变量声明中。比如一般的局部变量或是在函数原型中的参数

- **static**

  使用static声明的局部变量仅被其所声明所在的函数所知，外部无法共享该变量，static局部变量在函数返回后仍保存着变量的值

- **extern**

  表明在其他地方定义了该变量（该关键字用于全局变量）

- **register**

  只能用在具有局部作用域的变量，请求一个变量存储在寄存器中快速使用，但是不能获得该变量的地址。register通常是不必要的

  |   类型   |                      特性                       |
  | :------: | :---------------------------------------------: |
  |   auto   |       代码块作用域/局部作用域，自动存储期       |
  | register |       代码块作用域/局部作用域，自动存储期       |
  |  static  | 代码块作用域 或者 文件 / 全局作用域，静态存储期 |
  |  extern  |           文件/全局作用域，静态存储期           |

## 3. const

- **常量**：const 用于定义常量，const修饰的数据无法被改变，可以用于保护被修饰的变量，防止意外的修改，增强程序的健壮性。

- **指向常量的指针 / 指针常量**：const 可用于修饰指针，分为指向常量的指针（`const int * p1`：指针指向的内容不能被修改）和指针常量（`int * const p2`：指针本身不可被修改）

  > 方便记忆可以理解为 `*` 在 const 前面 则为指针常量

- **常引用**：const 可用于修饰引用，指向常量的引用，用于形参类型，既避免了拷贝、又避免了函数对值的修改

- **常成员函数**：const 可用于修饰成员函数，说明该成员函数内不能修改成员变量

## 4. static

- **静态成员变量**：static 声明静态数据成员，具有全局生命周期，不随函数的消亡而消亡，static 修改的数据不属于任何一个对象，该类的所有对象共享。
- **静态成员函数**：static 修饰成员函数，使得不需要对象就能访问该静态成员函数，但是在静态函数内不能访问或修改非静态成员变量或非静态成员函数。
- **静态普通变量**：static 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，具有静态生命周期，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
- **静态普通函数**：static 修饰普通函数，表明函数的作用范围，<u>仅在定义该函数的文件内才能使用</u>。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

<br>



# 三、继承和派生

## 1. 为什么说继承是面向对象的主要特征之一

继承是软件重用的一种形式。我**们可以通过继承这一方式，从现有的类中吸收数据和方法，并添加现有的类中所没有的新的数据和方法**。通过继承这一方式，提高了程序的抽象程度，更加接近人的思维方式，使程序结构清晰并且有利于开发和维护。

## 2. this 

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针。**它指向调用该成员函数的那个对象**。

2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。

3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。

4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；

5. <u>`this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。</u>

6. 在以下场景中，经常需要显式引用 `this` 指针：

   - 为实现对象的链式引用；

   - 为避免对同一对象进行赋值操作；

   - 在实现一些数据结构时，如 `list`。

<br>



# 四、多态

## 1. 静态绑定 和 动态绑定

- 绑定机制：

  <u>绑定是将一个标识符名和一个存储地址联系在一起的过程</u>

- 编译时的多态通过**静态绑定**实现

  绑定工作在程序**编译**连接阶段运行

- 运行时的多态通过**动态绑定**实现

  绑定工作在程序**运行**阶段运行

## 2. C++ 多态的实现

多态是指同样的消息被不同类型的对象接收时产生不同的行为，是对类的特定成员函数的再抽象。

C++ 多态的实现：

- **重载多态**：编译期的多态，静态绑定 —— 函数重载、运算符重载；
- **子类型多态**：运行期的多态，动态绑定 ——  虚函数；
- **参数多态**：编译器的多态，静态绑定 ——  函数模板、类模板；
- **强制多态**：编译期或者运行期的多态 ——  强制类型转换、自定义类型转换。

重载（函数重载、运算符重载）和虚函数是多态实现的主要方式。

## 3. 虚函数 virtual

### ① 如何区别虚函数和纯虚函数？两者都有啥作用

```cpp
virtual void fun(); //虚函数
virtual void fun() = 0; //纯虚函数
```

- **虚函数使得基类和派生类的同名函数具有不同的操作，实现多态**。

- 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，**纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。**
- 有纯虚函数的类称为抽象类。这种类不能直接生成对象，只有被继承，并且纯虚函数在子类中必须给出实现，否则该子类仍是纯虚函数
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类给出实现才可以实例化子类

### ② 虚析构函数的作用

**析构函数**：类的析构函数是为了释放内存资源，析构函数不被调用的话就会造成内存泄漏。

**虚析构函数**：**定义为虚析构函数是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用**。

但并不是要把所有类的析构函数都写成虚函数。**只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。**

```cpp
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```

### ③ 虚指针、虚表

- **虚指针**：每个对象有一个指向当前类的虚表的指针。
- **虚表**：每个多态类都有一个虚表，**虚表中存放当前类的各个虚函数的入口地址**，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。
- 动态绑定的实现：
  - 构造函数中为对象的虚指针赋值；
  - 通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址
  - 通过该地址调用虚函数

## 4. 重载 operator 

## 5. 模板 template

