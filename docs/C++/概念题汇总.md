# 🥟 概念题汇总

---



### 1. 简述你对“面向过程”和“面向对象”编程思想的认识与思考
**面向过程**：面向过程的设计思路是自顶向下的，按功能划分称若干个基本模块，形成一个树状结构，各个模块的功能上相对独立。

面向过程的**优点**主要是：

- 有效的将一个复杂的程序分解成多个小的、容易处理的子任务，便于维护和开发。

**缺点**主要是

- 可重用性差、数据安全性差；
- 当数据结构改变的时候，所有相关的处理过程都要进行相应的修改；
- 难以开发图形化界面；把数据和操作数据的过程分离开来。

**面向对象：**将数据和对数据的操作方法封装在一起，作为一个不可分割的整体——对象。对同类型的对象抽象出它们的共性，形成类。类通过外部接口public，与外部进行交互。

面向的对象的四大特性：抽象、封装、继承、多态。

面向对象的**优点**主要是：

- 各个模块之间的关系更见简单，模块之间的独立性、安全性都大大提高；
- 通过继承和多态，大大提高了程序的可重用性，便于开发和维护

### 2. 为什么说继承是面向对象的主要特征之一
继承是软件重用的一种形式。我们可以通过继承这一方式，从现有的类中吸收数据和方法，并添加现有的类中所没有的新的数据和方法。通过继承这一方式，提高了程序的抽象程度，更加接近人的思维方式，使程序结构清晰并且有利于开发和维护。

### 3. 面向对象程序“接口和实现方法分离”有啥优点
接口定义了交互的标准。接口的实现细节对用户是隐藏的。<br />接口和是实现方法分离使得程序更容易修改，只要接口保持不变，接口实现的改变不会影响用户。提高了代码的可维护性，使得代码变得清晰。

### 4. 简述你对C++中数据类型和ADT的理解
**数据类型**是一组性质相同的具有一定范围的值和集合以及定义在这个集合上的一组操作。C++中既有内部类型：int、char、bool、float、double，又有外部数据类型：枚举类型enum、结构类型struct、联合类型union、数组类型int[]、类类型class。<br />**ADT**即抽象数据类型，是基于已有类型而组成的复合数据类型，类就是抽象数据类型的描述形式。

### 5. const和static有啥作用
const 用于定义常量，const修饰的数据无法被改变，可以用于保护被修饰的变量，防止意外的修改，增强程序的健壮性。<br />static声明静态数据成员，具有全局生命周期，不随函数的消亡而消亡，static修改的数据不属于任何一个对象，该类的所有对象共享。

### 6. C++多态的实现
多态是指同样的消息被不同类型的对象接收时产生不同的行为，是对类的特定成员函数的再抽象。<br />重载（函数重载、运算符重载）和虚函数是多态实现的主要方式。

### 7. 如何区别虚函数和纯虚函数？两者都有啥作用
```cpp
virtual void fun(); //虚函数
virtual void fun() = 0; //纯虚函数
```
虚函数使得基类和派生类的同名函数具有不同的操作，实现多态。<br />纯虚函数没有函数体，是用来实现抽象类的。

### 8. 哪几个运算符必须重载为成员函数

- `()`
- `[`
- `->`
- `=`

### 9. 什么是运算符重载
对已有的运算符赋予多重含义，使用一个运算符作用于不同类型的数据时产生不同的行为。

### 10. 函数模板和函数重载的区别和联系
**函数模板**：若一个函数的功能是对任意类型的数据做同样的处理，比如一个加法函数可以处理float、int、char等多种类型，则将所处理的数据类型说明为参数，就可以把这个函数声明为模板`<template>` 。函数模板代表的是具有相同功能的一类函数，**函数模板的参数都是抽象的**。<br />**函数重载：**同一函数名定义多个函数，这些函数的参数个数，参数类型不同，这就是函数重载（不以返回值判定是否是重载）。**函数重载的参数都是具体的。**

### 11. 函数模板和模板函数的区别与联系
**函数模板：**函数模板就是数据类型参数化的函数定义，是一类函数。当编译系统发现用指定数据调用函数模板的时候，就创建了一个模板函数，**模板函数就是函数模板实例化的结果。**

### 12. 枚举函数是如何定义和使用的
`Enum Week{Mon,Tue,Wed,Thu,Fri,Sat,Sun);` <br />对应0，1，2，3，4，5，6；<br />枚举是对整数区间的自定义类型，一旦定义则不能改变，常用于代替整数常量，使得代码更加清晰。

### 13. 什么是逻辑错误，什么是语法错误
**语法错误：**是对语言规则的违背，当编译器不能正确识别语句的时候，就会导致语法错误（比如句子末尾少个分号），他们都是在编译期间就被检查出来的错误，所以也叫编译错误。<br />**逻辑错误**：指代码逻辑上的错误，编译能通过，程序可以完成运行，但是不会产生正确的结果（比如死循环）

### 14. 控制语句有哪几种，请画出他们的流程图
三种控制语句：

- 顺序
- 循环
- 选择

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586522466459-546cc2dd-c3d5-41e4-9b48-926ed469bc32.png#align=left&display=inline&height=219&name=image.png&originHeight=367&originWidth=827&size=86480&status=done&style=none&width=491)

### 15. 什么是else摇摆问题


```cpp
if(a>0){
	if(b>0)
        //do something
else
    //do something
}
```
这里的else匹配第二个if 而非第一个<br />即else匹配**最近一个未和else匹配的if**

### 16. C++中有几种作用域

- **函数原型作用域：**在函数原型声明时形参的作用范围就是函数原型作用域**。**即只在形参的小括号内有用，出了小括号就死亡
- **局部作用域/块作用域：**函数形参列表中形参的作用域**。**从形参的声明处开始，到整个函数体结束为止；函数体内声明的变量，其作用域从声明处开始，到整个函数体结束为止
- **类作用域**
- **全局作用域/文件作用域：**在任何函数外部声明的标识符的作用范围都是文件作用域，从声明标识符开始，到文件末尾结束，这之间的任何函数都可以访问该标识符

### 17. 存储类说明符有哪些

- **auto**

auto标名一个变量具有自动存储周期，该说明符只能用在具有局部作用域的变量声明中。比如一般的局部变

量或是在函数原型中的参数

- **static**

使用static声明的局部变量仅被其所声明所在的函数所知，外部无法共享该变量，static局部变量在函数返回<br />后仍保存着变量的值

- **extern**

表明在其他地方定义了该变量（该关键字用于全局变量）

- **register**

只能用在具有局部作用域的变量，请求一个变量存储在寄存器中快速使用，但是不能获得该变量的地址。register通常是不必要的
![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586523397457-5475710b-4cd9-40da-b508-179fda27e247.png)