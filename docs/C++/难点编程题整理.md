# 难点编程题整理

# 1. 高精度算法
定义HugeInt类能处理20亿以上的整数并重载+和<<<br />

> 32位整数的机器所能表示的整数范围大概是-20亿~20亿


<br />**思路：将大数存入数组，再对数组进行逐位操作**
<a name="83175ad0"></a>
## 代码实现


```c++
#include <cstring>
#include <string>
#include <iostream>
using std::ostream;

class HugeInt
{
public:
    HugeInt(long val = 0);            // long型数转换构造为HugeInt型
    HugeInt(const char *s);        // 字符存储的大数转换构造为HugeInt型
    HugeInt operator +(HugeInt &rhs);  // +重载
    friend ostream &operator <<(ostream &os, HugeInt &rhs); // <<重载
private:
    short integer[30];
};

// 转换构造函数
HugeInt::HugeInt(long val)
{
    for (int i = 0; i <= 29; i++)
        integer[i] = 0; // 将数组初始化为0
    for (int i = 29; val != 0 && i >= 0; i --)
    {//从后往前依次填入数组，不满30位的前面补0
        integer[i] = val % 10;
        val /= 10;
    }
}
HugeInt::HugeInt(const char *s)
{
    for (int i = 0; i <= 29; i++)
        integer[i] = 0;
    for (int i = 30 - strlen(s), j = 0; i <= 29; i++, j++)
        integer[i] = s[j]-'0';
}
// 巨型整数相加
HugeInt HugeInt::operator +(HugeInt &op2)
{
    HugeInt temp;
    int carry = 0; //进位
    for (int i = 29; i >= 0; i--)
    {
        temp.integer[i] = integer[i] + op2.integer[i] + carry;
        if (temp.integer[i] > 9)
        {
            temp.integer[i] %= 10;
            carry = 1;
        }
        else
            carry = 0;
    }
    return temp;
}
ostream &operator <<(ostream &output, HugeInt &num)
{
    int i = 0;
    for (; (num.integer[i] == 0) && (i <= 29); i++)
        ; // 跳过前导0
    if (i == 30)
        output << 0;
    else
        for (; i <= 29; i++)
            output << num.integer[i];
    return output;
}

int  main()
{
    using std::cout;
    using std::endl;
    HugeInt n1(7654321),n2(1234567);  //测试long型
    HugeInt n3("12345678987654321"), n4("12345678987654321"); //测试字符串型
    cout << "n1 is " << n1 << "\nn2 is " << n2 << "\nn3 is " << n3 << "\nn4 is " << n4 <<endl;
    HugeInt n5 = n1+n2;
    HugeInt n6 = n3+n4;
    HugeInt n7 = n3 + n1;
    cout<< "n1+n2="<<n5<<endl;  //测试long型大数相加
    cout<< "n3+n4="<<n6<<endl;  //测试字符串型大数相加
    cout<< "n1+n3=" << n7 << endl;  //测试long型和字符串型相加
}
```


<a name="97c957fc"></a>
## 运行结果

![](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153226359-85881894-b965-40f9-b395-932fb6311956.png#align=left&display=inline&height=169&originHeight=169&originWidth=304&size=0&status=done&style=none&width=304)<br />


## Q&A

**Q: Error: identifier "cout" is undefined**<br />**A:**<br />

```c
using std::cout;
using std::endl;

cout << .... << endl;
```

<br />**Q: Error: identifier ＂ostream＂ is undefined error**<br />**A:**<br />

```c
using std::ostream;
```


<a name="u3XvQ"></a>
# 2. 冒泡排序改进
## 冒泡排序


```c++
/**
 * 冒泡排序
 */
void sort(int a[], const int size)
{
    for (int i = 0; i < size - 1; i++){
        for (int j = 0; j < size; j++){
            if (a[j] > a[j + 1]){
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```



## 改进版1
在第一遍排序后，最大值必定在数组最大编号的元素中；第二遍排序后，最大的两个值都在最终位置了，依次类推。所以，修改这个冒泡排序法（假设数组中有10个元素），使得在第二遍排序时比较8次，在第三遍排序时比较7次，而不是每次排序时都比较9次<br />

```c++
/**
 * 冒泡排序改进版1
 */ 
void sort2(int a[], const int size){
    for(int i = 0; i < size-1; i++){
        for(int j = 0;j<size-i-1;j++){
            if(a[j]>a[j+1]){
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}
```


<a name="jcb39"></a>
## 改进版2
如果某趟冒泡排序没有发生交换，即说明数组中的元素已经全部有序，此时无需再进行排序<br />

```c++
/**
 * 冒泡排序改进版2
 */
void sort3(int a[], const int size)
{
    for (int i = 0; i < size - 1; i++){
        int ifSwap = false;
        for (int j = 0; j < size - i - 1; j++){
            if (a[j] > a[j + 1]){
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
                ifSwap = true;
            }
        }
        if(ifSwap == false)
            break;
    }
}
```

<br />


# 3. 读取不重复数字
读取20个在10-100之间的不重复的数并存入数组，如果重复数字，则不存入数组且给出提示。同时，尽可能使用最小数组。<br />

```c++
int main()
{
   const int SIZE = 20; // size of array
   int a[ SIZE ] = {};
   int subscript = 0; ////动态下标，根据有效数字的个数动态增长
   int duplicate; //是否存在有相同的数字
   int value; // number entered by user

   cout << "Enter 20 integers between 10 and 100:\n";

   // get 20 nonduplicate integers in the range between 10 and 100
   for ( int i = 0; i < SIZE; ) 
   {
      duplicate = 0;
      cin >> value;

      // validate input and test if there is a duplicate
      if ( value >= 10 && value <= 100 )
      {
         for ( int j = 0; j < subscript; j++ )
         {
            if ( value == a[ j ] ) 
            {
               duplicate = 1;
               break;
            } // end if
         } // end for

         // if number is not a duplicate, enter it in array
         if ( !duplicate )
         {
            a[ subscript++ ] = value;
            ++i;
         } // end if
         else
            cout << "Duplicate number.\n";
      } // end if
      else
         cout << "Invalid number.\n";
   } // end for

   cout << "\nThe nonduplicate values are:\n";

   // display array of nonduplicates
   for ( int i = 0; i < SIZE; i++ )
      cout << a[ i ] << ' ';

   cout << endl;
} // end main
```


<a name="u8mYM"></a>
# 4. 桶排序 bucket sort 
桶排序 bucket srot，一维数组存储待排序的数字，二维数组存放排序过程。<br />二维数组的行下标从0-9，列下标从0~n-1，n是一维数组中待排序值的个数。<br />**二维数组的每一行称为一个桶**<br />**<br />具体排序算法如下：

- 第一遍排序：根据待排数组中值的**个位数**将其放到桶数组的各行中

比如：97个位数是7，放在二维数组的第7行，3放在二维数组的第3行，100放在二维数组的第0行<br />这称为**分布过程**<br />分布过程结束后，在**二维数组中逐行进行循环遍历**，**并根据遍历的顺序将数字重新放回一维数组**。<br />这称为**收集过程**<br />比如：上述二维数组中第0行100，第2行无数字，第3行3，第4行无数字。。。第7行97。。<br />依次返回一维数组100，3，97

- 第二遍排序：根据第一遍排序的一维数组中的值的**十位数**将其放到桶数组的各行中

比如：100十位数是0，放在第0行，3放在第0行，97放在第9行。分布过程结束。<br />收集过程：循环遍历二维数组按序放回一维数组，第0行100，3，第9行97<br />依次放入一维数组100，3，97

- 第三遍排序：根据第二遍排序的一维数组中的值的百**位数**将其放到桶数组的各行中    

比如：100放入第1行，3放入第0行，97放入第0行<br />循环遍历桶数组并按序放入一维数组：0，97，100。原始数组有序！<br />
<br />数组中**值的最大位数就是排序的次数**<br />**
```c++
// constant size must be defined as the array size for bucketSort to work
const int SIZE = 12;

void bucketSort( int [] ); //桶排序
void distributeElements( int [], int [][ SIZE ], int ); //分布过程
void collectElements( int [], int [][ SIZE ] ); //收集过程
int numberOfDigits( int [], int ); //确定排序的次数，即数组中值的最大位数
void zeroBucket( int [][ SIZE ] ); //初始化桶数组

int main()
{
   int array[ SIZE ] = { 19, 13, 5, 27, 1, 26, 31, 16, 2, 9, 11, 21 };

   // display the unsorted array
   cout << "Array elements in original order:\n";

   for ( int i = 0; i < SIZE; i++ )
      cout << setw( 3 ) << array[ i ];

   cout << '\n';
   bucketSort( array ); // sort the array

   cout << "\nArray elements in sorted order:\n";

   // display sorted array
   for ( int j = 0; j < SIZE; j++ )
      cout << setw( 3 ) << array[ j ];

   cout << endl;
} // end main

// Perform the bucket sort algorithm
void bucketSort( int a[] )
{
   int totalDigits;
   int bucket[ 10 ][ SIZE ] = {};

   totalDigits = numberOfDigits( a, SIZE );

   // put elements in buckets for sorting
   // once sorted, get elements from buckets
   for ( int i = 1; i <= totalDigits; i++ ) 
   {
      distributeElements( a, bucket, i );
      collectElements( a, bucket );

      if ( i != totalDigits )
         zeroBucket( bucket ); // set all bucket contents to zero
   } // end for
} // end function bucketSort

// Determine the number of digits in the largest number
int numberOfDigits( int b[], int arraySize )
{
   int largest = b[ 0 ];
   int digits = 0;

   // find largest array element
   for ( int i = 1; i < arraySize; i++ )
   {
      if ( b[ i ] > largest )
         largest = b[ i ];
   } // end for

   // find number of digits of largest element
   while ( largest != 0 ) 
   {
      digits++;
      largest /= 10;
   } // end while

   return digits;
} // end function numberOfDigits

// Distribute elements into buckets based on specified digit
void distributeElements( int a[], int buckets[][ SIZE ], int digit )
{
   int divisor = 10; //确定每次排序的被除数
   int bucketNumber; //要存放的二维数组的行数
   int elementNumber; //要存放的二维数组的列数

   for ( int i = 1; i < digit; ++i ) // determine the divisor
      divisor *= 10; // used to get specific digit

   for ( int k = 0; k < SIZE; ++k ) 
   {
      // bucketNumber example for hundreds digit:
      // (1234 % 1000 - 1234 % 100) / 100 --> 2
      bucketNumber = ( a[ k ] % divisor - a[ k ] %
         ( divisor / 10 ) ) / ( divisor / 10 );

      // retrieve value in buckets[bucketNumber][0] to determine
      // which element of the row to store a[i] in.
      elementNumber = ++buckets[ bucketNumber ][ 0 ];
      buckets[ bucketNumber ][ elementNumber ] = a[ k ];
   } // end for
} // end function distributeElements

// Return elements to original array
void collectElements( int a[], int buckets[][ SIZE ])
{
   int subscript = 0;

   // retrieve elements from buckets
   for ( int i = 0; i < 10; i++ )
   {
      for ( int j = 1; j <= buckets[ i ][ 0 ]; j++ )
         a[ subscript++ ] = buckets[ i ][ j ];
   } // end for
} // end function collectElements

// Set all buckets to zero
void zeroBucket( int buckets[][ SIZE ] )
{
   // set all array elements to zero
   for ( int i = 0; i < 10; i++ )
   {
      for ( int j = 0; j < SIZE; j++ )
         buckets[ i ][ j ] = 0;
   } // end for
} // end function zeroBucket
```


<a name="2BfSB"></a>
# 5. 回文 递归判断
回文：即正读和反读字符串都会得到同样的结果，比如：radar<br />

```c++
bool testPalindrome( string palindrome, int left, int right )
{
   // test array to see if a palindrome
   if ( left == right || left > right )
      return true;
   else if ( palindrome[ left ] != palindrome[ right ] )
      return false;
   else
      return testPalindrome( palindrome, left + 1, right - 1 );
}
```


<a name="KJXq9"></a>
# 6. 递归逆序打印字符串


```c++
// function to reverse a string
void stringReverse( string stringToReverse, int startSubscript )
{
   // return when null character is encountered
   if ( startSubscript == stringToReverse.length() )
      return;

   // recursively call stringReverse with new substring
   stringReverse( stringToReverse, startSubscript + 1 );
   cout << stringToReverse[ startSubscript ]; // output character
} // end function stringReverse
```


<a name="T0Gec"></a>
# 7. 递归查询最小元素


```c++
// function to recursively find minimum array element
const int MAXRANGE = 1000;
int recursiveMinimum( const int array[], int low, int high )
{
   static int smallest = MAXRANGE;

   // if first element of array is smallest so far
   // set smallest equal to that element
   if ( array[ low ] < smallest )
      smallest = array[ low ];

   // if only one element in array, return smallest
   // else recursively call recursiveMinimum with new subarray
   return low == high ? 
      smallest : recursiveMinimum( array, low + 1, high );
}
```


<a name="HnQ29"></a>
# 8. 有理数类 Rational
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586255295789-1829d0e3-3435-4330-a703-1dacf90a59d8.png#align=left&display=inline&height=223&name=image.png&originHeight=431&originWidth=1235&size=236570&status=done&style=none&width=639)<br />

```c++
class Rational{
    public:
        Rational();
        Rational(int, int);
        Rational add(const Rational&);
        Rational sub(const Rational&);
        Rational multi(const Rational&);
        Rational div(const Rational&);
        void printRational();
        void printRationalAsDouble();
    private:
        int numerator; //分子
        int denominator; //分母
        Rational reduction(); //分数化简，不允许外部使用
};

Rational::Rational(){
    numerator = 1;
    denominator = 1;
}
Rational::Rational(int n, int d){
    numerator = n;
    denominator = d;
}
Rational Rational :: add(const Rational &rhs){
    Rational result;
    result.denominator = denominator * rhs.denominator;
    result.numerator = numerator * rhs.denominator + rhs.numerator * denominator;
    return result.reduction();
}
Rational Rational :: sub(const Rational &rhs){
    Rational result;
    result.denominator = denominator * rhs.denominator;
    result.numerator = numerator * rhs.denominator - rhs.numerator * denominator;
    return result.reduction();
}
Rational Rational ::multi(const Rational &rhs){
    Rational result;
    result.denominator = denominator * rhs.denominator;
    result.numerator = numerator * rhs.numerator;
    return result.reduction();
}
Rational Rational ::div(const Rational &rhs){
    Rational result;
    result.denominator = denominator * rhs.numerator;
    result.numerator = numerator * rhs.denominator;
    return result.reduction();
}
Rational Rational :: reduction(){
    Rational result;
    int largest = numerator > denominator ? numerator : denominator;
    int gcd = 0; //最大公因数
    for(int i = 2; i < largest; i++){
        if(denominator % i == 0 && numerator % i == 0)
            gcd = i;
    }
    if(gcd != 0){
        numerator /= gcd;
        denominator /= gcd;
    }
    result.numerator = numerator;
    result.denominator = denominator;
    return result;
}
void Rational :: printRational(){
    Rational result = this->reduction();
    cout<<result.numerator<<" / "<<result.denominator<<endl;
}
void Rational :: printRationalAsDouble(){
    double result = numerator/denominator;
    cout<<result<<endl;
}
```
<a name="oVT3f"></a>
# 9. 多项式类重载 Polynomial
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586329500511-ac3caeeb-210b-41e4-9547-7d1a4d73faf7.png#align=left&display=inline&height=177&name=image.png&originHeight=279&originWidth=996&size=125550&status=done&style=none&width=633)<br />

```c++
#include<iostream>
using namespace std;

class Polynomial{
    public:
        static const int maxTerms = 100; //最大项数
        Polynomial();
        Polynomial operator +(const Polynomial&) const;
        Polynomial operator -(const Polynomial &) const;
        Polynomial operator *(const Polynomial &) const;
        Polynomial &operator =(const Polynomial &);
        Polynomial &operator +=(const Polynomial &);
        Polynomial &operator -=(const Polynomial &);
        Polynomial &operator *=(const Polynomial &);
        void enterTerms(); //输入多项式
        void printPolynomial() const; //打印多项式
        int getNumberOfTerms() const; //获取项数
        int getTermExponent(int) const; //获取某项的指数
        int getTermCoefficient(int) const; //获取某项的系数
        int& setTermExponent(); //设置某项的指数
        void setCoefficient(int, int); //设置某项的系数
        ~Polynomial();

    private:
        int numberOfTerms; //项数
        int exponents[maxTerms]; //指数项
        int coefficients[maxTerms]; //系数项 coefficients[1] 对应指数为 1 的系数
        static void polynomialCombine(Polynomial &); //合并同类项
};

Polynomial::Polynomial(){
    for(int i = 0;i<maxTerms; i++){
        coefficients[i] = 0;
        exponents[i] = 0;
    }
    numberOfTerms = 0;
}

void Polynomial ::printPolynomial() const{
    int start;
    bool zero = false; //确定多项式中是否有项
    
    //如果第0项存在
    if(coefficients[0]){
        cout<<coefficients[0];
        start = 1;
        zero = true; //表示第0项存在，多项式中至少有一项
    }
    //如果第0项不存在
    else{
        //第1项存在
        if(coefficients[1]){
            cout<<coefficients[1]<<'x';
            if(exponents[1]!=0 && exponents[1]!=1)
                cout<<'^'<<exponents[1];

            zero = true; //表示第1项存在，多项式中至少有一项
        }
        start = 2;
    }

    //输出剩余的其他项
    for(int x = start; x<maxTerms; x++){
        //如果该项系数存在
        if(coefficients[x] != 0){
            cout << showpos << coefficients[x] << noshowpos << 'x';
            if(exponents[x]!=0 && exponents[x]!=1)
                cout<<'^'<<exponents[x];

            zero = true; //表示第x项存在，多项式中至少有一项
        }
    }

    //如果多项式中一项也没有
    if(!zero)
        cout<<'0';

    cout<<endl;
}

Polynomial &Polynomial::operator = (const Polynomial &rhs){
    exponents[0] = rhs.exponents[0];
    coefficients[0] = rhs.coefficients[0];
    for(int i = 1; i < maxTerms; i ++){
        //若rhs的指数不为0
        if(rhs.exponents[i]!=0){
            exponents[i] = rhs.exponents[i];
            coefficients[i] = rhs.coefficients[i];
        }
        //若rhs的指数为0
        else{
            //如果待复制的项指数也为0
            if(exponents[i] == 0)
                break;
            //如果待复制的项指数不为0
            exponents[i] = 0;
            coefficients[i] = 0;
        }
    }
    return *this;
}
Polynomial Polynomial::operator+(const Polynomial &r) const
{
    Polynomial temp;
    bool exponentExists;
    int s;

    // process element with a zero exponent
    temp.coefficients[0] = coefficients[0] + r.coefficients[0];

    // copy right arrays into temp object; s will be used to keep
    // track of first open coefficient element
    for (s = 1; (s < maxTerms) && (r.exponents[s] != 0); s++)
    {
        temp.coefficients[s] = r.coefficients[s];
        temp.exponents[s] = r.exponents[s];
    } // end for

    for (int x = 1; x < maxTerms; x++)
    {
        exponentExists = false; // assume exponent will not be found

        for (int t = 1; (t < maxTerms) && (!exponentExists); t++)
            if (exponents[x] == temp.exponents[t])
            {
                temp.coefficients[t] += coefficients[x];
                exponentExists = true; // exponent found
            }                          // end if

        // exponent was not found, insert into temp
        if (!exponentExists)
        {
            temp.exponents[s] = exponents[x];
            temp.coefficients[s] += coefficients[x];
            s++;
        } // end if
    }     // end for

    return temp;
} // end function operator+

Polynomial &Polynomial::operator+=(const Polynomial &r)
{
    *this = *this + r;
    return *this;
} // end function operator+=

Polynomial Polynomial::operator-(const Polynomial &r) const
{
    Polynomial temp;
    bool exponentExists;
    int s;

    // process element with a zero exponent
    temp.coefficients[0] = coefficients[0] - r.coefficients[0];

    // copy left arrays into temp object; s will be used to keep
    // track of first open coefficient element
    for (s = 1; (s < maxTerms) && (exponents[s] != 0); s++)
    {
        temp.coefficients[s] = coefficients[s];
        temp.exponents[s] = exponents[s];
    } // end for

    for (int x = 1; x < maxTerms; x++)
    {
        exponentExists = false; // assume exponent will not be found

        for (int t = 1; (t < maxTerms) && (!exponentExists); t++)

            if (r.exponents[x] == temp.exponents[t])
            {
                temp.coefficients[t] -= r.coefficients[x];
                exponentExists = true; // exponent found
            }                          // end if

        // exponent was not found, insert into temp
        if (!exponentExists)
        {
            temp.exponents[s] = r.exponents[x];
            temp.coefficients[s] -= r.coefficients[x];
            s++;
        } // end if
    }     // end for

    return temp;
} // end function operator-

Polynomial &Polynomial::operator-=(const Polynomial &r)
{
    *this = *this - r;
    return *this;
} // end function operator-=

Polynomial Polynomial::operator*(const Polynomial &r) const
{
    Polynomial temp;
    int s = 1; // subscript location for temp coefficient and exponent

    for (int x = 0; (x < maxTerms) &&
                    (x == 0 || coefficients[x] != 0);
         x++)

        for (int y = 0; (y < maxTerms) &&
                        (y == 0 || r.coefficients[y] != 0);
             y++)

            if (coefficients[x] * r.coefficients[y])

                if ((exponents[x] == 0) && (r.exponents[y] == 0))
                    temp.coefficients[0] +=
                        coefficients[x] * r.coefficients[y];
                else
                {
                    temp.coefficients[s] =
                        coefficients[x] * r.coefficients[y];
                    temp.exponents[s] = exponents[x] + r.exponents[y];
                    s++;
                } // end else

    polynomialCombine(temp); // combine common terms
    return temp;
} // end function operator*

void Polynomial::polynomialCombine(Polynomial &w)
{
    Polynomial temp = w;

    // zero out elements of w
    for (int x = 0; x < maxTerms; x++)
    {
        w.coefficients[x] = 0;
        w.exponents[x] = 0;
    } // end for

    for (int x = 1; x < maxTerms; x++)
    {
        for (int y = x + 1; y < maxTerms; y++)
            if (temp.exponents[x] == temp.exponents[y])
            {
                temp.coefficients[x] += temp.coefficients[y];
                temp.exponents[y] = 0;
                temp.coefficients[y] = 0;
            } // end if
    }         // end outer for

    w = temp;
} // end function polynomialCombine

Polynomial &Polynomial::operator*=(const Polynomial &r)
{
    *this = *this * r;
    return *this;
} // end function operator*=

void Polynomial::enterTerms()
{
    bool found = false;
    int c, e, term;

    cout << "\nEnter number of polynomial terms: ";
    cin >> numberOfTerms;

    for (int n = 0; n < maxTerms && n < numberOfTerms; n++)
    {
        cout << "\nEnter coefficient: ";
        cin >> c;
        cout << "Enter exponent: ";
        cin >> e;

        if (c != 0)
        {
            // exponents of zero are forced into first element
            if (e == 0)
            {
                coefficients[0] += c;
                continue;
            } // end if

            for (term = 1; (term < maxTerms) &&
                           (coefficients[term] != 0);
                 term++)

                if (e == exponents[term])
                {
                    coefficients[term] += c;
                    exponents[term] = e;
                    found = true; // existing exponent updated
                }                 // end if

            if (!found) // add term
            {
                coefficients[term] += c;
                exponents[term] = e;
            } // end if
        }     // end outer if
    }         // end outer for
} // end function endTerms

int Polynomial::getNumberOfTerms() const
{
    return numberOfTerms;
} // end function getNumberOfTerms

int Polynomial::getTermExponent(int term) const
{
    return exponents[term];
} // end function getTermExponent

int Polynomial::getTermCoefficient(int term) const
{
    return coefficients[term];
} // end function getTermsCoefficient

void Polynomial::setCoefficient(int term, int coefficient)
{
    if (coefficients[term] == 0) // no term at this location
        cout << "No term at this location, cannot set term." << endl;
    else // otherwise, set term
        coefficients[term] = coefficient;
} // end function setTerm

// destructor
Polynomial::~Polynomial()
{
    // empty destructor
} // end destructor

```
<a name="BHJBF"></a>
# 10. 字符串简单加密
利用 `旋转13` 算法对字符串进行加密，即字符串后移13位，比如 a——>n，x——>k。<br />使用对称密钥进行加密，在加密和解密的同时使用相同的密钥<br />

```c++
/**
 * Encrypt
 */ 
int main(){
   string m;
   int key = 13; //密钥
   cout<<"Enter a string: ";
   getline(cin, m);

   string ::iterator mi = m.begin(); // 迭代器，相当于指针，初始化指向第一个字符
   while(mi != m.end()){
      *mi += key; //加密
       mi ++; //指针后移，继续加密
   }
   cout << "\nEncrypted string is: " << m << endl;
}
```
解密即 `*mi -= key`<br />

<a name="3Spqv"></a>
# 11. 垃圾邮件扫描
![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586417619305-00529f81-8bee-498b-8875-bb6d76424953.png#align=left&display=inline&height=114&name=image.png&originHeight=173&originWidth=1011&size=121867&status=done&style=none&width=670)<br />

```c++
#include <cctype>
#include <iostream>
#include <string>
using namespace std;

const int spamSize = 30; //垃圾邮件关键词个数

const string spamWords[spamSize] = {
    "nigerian", "disclaimer", "urgent", "necessary", "free", "4u",
    "guarantee", "profits", "congratulations", "opportunity",
    "unlimited", "scam", "casino", "profits", "amazing", "mailto",
    "mlm", "unsecured", "winner", "winning", "hormone", "insurance",
    "spam", "ringtones", "pharmacy", "blackjack", "cwas", "chatroom",
    "duty-free", "shoes"};

// 将用户输入的单词转化为小写
string toLow(string text){
   string temp;
   for(int i = 0; i < text.size(); i++)
      temp += tolower(text[i]);
   return temp;
}

int main(){
   string word;
   int wordCount = 0; //记录输入的单词个数
   int spamCount = 0; // 记录垃圾单词个数
   cout<<"Enter message: "<<endl;
   cout<<"Enter ctrl-Z to stop!"<<endl;
   while(cin >> word){
      //cin是不读取空白字符的
      //cin读取到空白字符就会停止进行下一次读取
      wordCount ++;
      for(int i = 0; i < spamSize; i++)
         if(toLow(word) == spamWords[i])
            ++ spamCount;
   }
   // display score
   cout << "Score: " << spamCount << endl;
   int percent = (wordCount == 0 ? 0 : 100 * spamCount / wordCount);
   cout << "Percentage: " << percent << '%' << endl;
}
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586417596045-ab510ddd-d653-4dc9-9fd6-c26eae16466c.png#align=left&display=inline&height=134&name=image.png&originHeight=149&originWidth=502&size=7008&status=done&style=none&width=447)<br />
